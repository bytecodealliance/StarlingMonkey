#ifndef rust_multipart_bindings_h
#define rust_multipart_bindings_h

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <cstdarg>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>


namespace jsmultipart {

enum class RetCode : uint8_t {
  Ok = 0,
  Eos = 1,
  Error = 2,
};

struct State;

/// A slice of bytes as seen from C.
struct Slice {
  const uint8_t *data;
  size_t len;
};

/// A C view of a parsed entry. For optional fields, a NULL data pointer means not present.
struct Entry {
  Slice name;
  Slice value;
  Slice filename;
  Slice content_type;
};


extern "C" {

/// Crates a new parser with data provided.
///
/// # Safety
///
/// The caller must ensure that the input data remains valid for the entire
/// lifetime of the parser's state.
State *multipart_parser_new(Slice *data, const char *boundary);

/// Free parser created by `multipart_parser_new`.
///
/// # Safety
///
/// The caller must ensure that the state is a valid parser pointer.
void multipart_parser_free(State *state);

/// Retrieve the next entry from the parser into provided entry.
///
/// # Safety
///
/// The caller must ensure that the state and entry are valid pointers.
RetCode multipart_parser_next(State *state, Entry *entry);

/// Retrieve the boundary from content-type header
///
/// # Safety
///
/// The caller must ensure that the content_type and boundary are valid pointers.
void boundary_from_content_type(Slice *content_type, Slice *boundary);

}  // extern "C"

}  // namespace jsmultipart

#endif  // rust_multipart_bindings_h
