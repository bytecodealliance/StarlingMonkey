mod raw {
  #[allow(unused_imports)]
  pub use crate::raw::*;
  pub use crate::raw::JS::*;
  pub use crate::raw::JS::dbg::*;
  pub use crate::raw::JS::detail::*;
  pub use crate::raw::js::*;
  pub use crate::raw::jsglue::*;
}

wrap!(raw: pub fn ToBooleanSlow(v: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn ToNumberSlow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, dp: *mut f64) -> bool);
wrap!(raw: pub fn ToInt8Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut i8) -> bool);
wrap!(raw: pub fn ToUint8Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut u8) -> bool);
wrap!(raw: pub fn ToInt16Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut i16) -> bool);
wrap!(raw: pub fn ToInt32Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut i32) -> bool);
wrap!(raw: pub fn ToUint32Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut u32) -> bool);
wrap!(raw: pub fn ToUint16Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut u16) -> bool);
wrap!(raw: pub fn ToInt64Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut i64) -> bool);
wrap!(raw: pub fn ToUint64Slow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, out: *mut u64) -> bool);
wrap!(raw: pub fn ToStringSlow(cx: *mut raw::JSContext, v: raw::JS::HandleValue) -> *mut raw::JSString);
wrap!(raw: pub fn ToObjectSlow(cx: *mut raw::JSContext, v: raw::JS::HandleValue, reportScanStack: bool) -> *mut raw::JSObject);
wrap!(raw: pub fn ElementAdder_append(this: *mut raw::js::ElementAdder, cx: *mut raw::JSContext, v: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn AutoEnterPolicy_reportErrorIfExceptionIsNotPending(this: *mut raw::js::AutoEnterPolicy, cx: *mut raw::JSContext, id: raw::JS::HandleId));
wrap!(raw: pub fn AutoEnterPolicy_recordEnter(this: *mut raw::js::AutoEnterPolicy, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, id: raw::JS::HandleId, act: raw::js::AutoEnterPolicy_Action));
wrap!(raw: pub fn NukeNonCCWProxy(cx: *mut raw::JSContext, proxy: raw::JS::HandleObject));
wrap!(raw: pub fn GetFirstSubsumedSavedFrame(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, selfHosted: raw::JS::SavedFrameSelfHosted) -> *mut raw::JSObject);
wrap!(raw: pub fn CrossCompartmentWrapper_getOwnPropertyDescriptor(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_defineProperty(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_ownPropertyKeys(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_delete_(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_enumerate(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_getPrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, protop: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_setPrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, proto: raw::JS::HandleObject, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_getPrototypeIfOrdinary(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, isOrdinary: *mut bool, protop: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_setImmutablePrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, succeeded: *mut bool) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_preventExtensions(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_isExtensible(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, extensible: *mut bool) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_has(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, bp: *mut bool) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_get(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, receiver: raw::JS::HandleValue, id: raw::JS::HandleId, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_set(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, v: raw::JS::HandleValue, receiver: raw::JS::HandleValue, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_call(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, args: *const raw::JS::CallArgs) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_construct(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, args: *const raw::JS::CallArgs) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_hasOwn(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, bp: *mut bool) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_getOwnEnumerablePropertyKeys(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn CrossCompartmentWrapper_className(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject) -> *const ::std::os::raw::c_char);
wrap!(raw: pub fn CrossCompartmentWrapper_fun_toString(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, isToSource: bool) -> *mut raw::JSString);
wrap!(raw: pub fn CrossCompartmentWrapper_regexp_toShared(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject) -> *mut raw::js::RegExpShared);
wrap!(raw: pub fn CrossCompartmentWrapper_boxedValue_unbox(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_getOwnPropertyDescriptor(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_defineProperty(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_ownPropertyKeys(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_delete_(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_enumerate(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_getPrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, protop: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_setPrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, proto: raw::JS::HandleObject, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_getPrototypeIfOrdinary(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, isOrdinary: *mut bool, protop: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_setImmutablePrototype(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, succeeded: *mut bool) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_preventExtensions(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_isExtensible(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, extensible: *mut bool) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_has(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, bp: *mut bool) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_get(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, receiver: raw::JS::HandleValue, id: raw::JS::HandleId, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_set(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, v: raw::JS::HandleValue, receiver: raw::JS::HandleValue, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_call(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, args: *const raw::JS::CallArgs) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_construct(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, args: *const raw::JS::CallArgs) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_hasOwn(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, id: raw::JS::HandleId, bp: *mut bool) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_getOwnEnumerablePropertyKeys(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_getBuiltinClass(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject, cls: *mut raw::js::ESClass) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_isArray(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, obj: raw::JS::HandleObject, answer: *mut raw::JS::IsArrayAnswer) -> bool);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_className(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, wrapper: raw::JS::HandleObject) -> *const ::std::os::raw::c_char);
wrap!(raw: pub fn OpaqueCrossCompartmentWrapper_fun_toString(this: *mut ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, isToSource: bool) -> *mut raw::JSString);
wrap!(raw: pub fn TransparentObjectWrapper(cx: *mut raw::JSContext, existing: raw::JS::HandleObject, obj: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn UnwrapOneCheckedDynamic(obj: raw::JS::HandleObject, cx: *mut raw::JSContext, stopAtWindowProxy: bool) -> *mut raw::JSObject);
wrap!(raw: pub fn RemapDeadWrapper(cx: *mut raw::JSContext, wobj: raw::JS::HandleObject, newTarget: raw::JS::HandleObject));
wrap!(raw: pub fn RemapAllWrappersForObject(cx: *mut raw::JSContext, oldTarget: raw::JS::HandleObject, newTarget: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn SetWindowProxy(cx: *mut raw::JSContext, global: raw::JS::Handle<*mut raw::JSObject>, windowProxy: raw::JS::Handle<*mut raw::JSObject>));
wrap!(raw: pub fn IsArgumentsObject(obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn EnqueueJob(cx: *mut raw::JSContext, job: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn AssertSameCompartment1(cx: *mut raw::JSContext, v: raw::JS::HandleValue));
wrap!(raw: pub fn NewFunctionByIdWithReservedAndProto(cx: *mut raw::JSContext, native: raw::JSNative, proto: raw::JS::Handle<*mut raw::JSObject>, nargs: ::std::os::raw::c_uint, flags: ::std::os::raw::c_uint, id: raw::jsid) -> *mut raw::JSFunction);
wrap!(raw: pub fn GetObjectProto(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, proto: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn GetRealmOriginalEval(cx: *mut raw::JSContext, eval: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn GetPropertyKeys(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, flags: ::std::os::raw::c_uint, props: raw::JS::MutableHandleIdVector) -> bool);
wrap!(raw: pub fn AppendUnique(cx: *mut raw::JSContext, base: raw::JS::MutableHandleIdVector, others: raw::JS::HandleIdVector) -> bool);
wrap!(raw: pub fn DateIsValid(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, isValid: *mut bool) -> bool);
wrap!(raw: pub fn DateGetMsecSinceEpoch(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, msecSinceEpoch: *mut f64) -> bool);
wrap!(raw: pub fn PrepareScriptEnvironmentAndInvoke(cx: *mut raw::JSContext, global: raw::JS::HandleObject, closure: *mut raw::js::ScriptEnvironmentPreparer_Closure));
wrap!(raw: pub fn GetElementsWithAdder(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, receiver: raw::JS::HandleObject, begin: u32, end: u32, adder: *mut raw::js::ElementAdder) -> bool);
wrap!(raw: pub fn SetPropertyIgnoringNamedGetter(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, id: raw::JS::HandleId, v: raw::JS::HandleValue, receiver: raw::JS::HandleValue, ownDesc: raw::JS::Handle<raw::mozilla::Maybe>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn ExecuteInFrameScriptEnvironment(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, script: raw::JS::HandleScript, scope: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn ReportIsNotFunction(cx: *mut raw::JSContext, v: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn RemapRemoteWindowProxies(cx: *mut raw::JSContext, callback: *mut raw::js::CompartmentTransplantCallback, newTarget: raw::JS::MutableHandleObject));
wrap!(raw: pub fn AssertArgumentsAreSane(cx: *mut raw::JSContext, v: raw::JS::HandleValue));
wrap!(raw: pub fn ComputeThis(cx: *mut raw::JSContext, vp: *mut raw::JS::Value, thisObject: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn Builder_Object_defineProperty(this: *mut raw::JS::dbg::Builder_Object, cx: *mut raw::JSContext, name: *const ::std::os::raw::c_char, value: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn Builder_Object_defineProperty1(this: *mut raw::JS::dbg::Builder_Object, cx: *mut raw::JSContext, name: *const ::std::os::raw::c_char, value: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn CopyArrayBuffer(cx: *mut raw::JSContext, maybeArrayBuffer: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn DetachArrayBuffer(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn HasDefinedArrayBufferDetachKey(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isDefined: *mut bool) -> bool);
wrap!(raw: pub fn StealArrayBufferContents(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> *mut ::std::os::raw::c_void);
wrap!(raw: pub fn ArrayBufferCopyData(cx: *mut raw::JSContext, toBlock: raw::JS::Handle<*mut raw::JSObject>, toIndex: usize, fromBlock: raw::JS::Handle<*mut raw::JSObject>, fromIndex: usize, count: usize) -> bool);
wrap!(raw: pub fn ArrayBufferClone(cx: *mut raw::JSContext, srcBuffer: raw::JS::Handle<*mut raw::JSObject>, srcByteOffset: usize, srcLength: usize) -> *mut raw::JSObject);
wrap!(raw: pub fn ToBigInt(cx: *mut raw::JSContext, val: raw::JS::Handle<raw::JS::Value>) -> *mut raw::JS::BigInt);
wrap!(raw: pub fn BigIntToString(cx: *mut raw::JSContext, bi: raw::JS::Handle<*mut raw::JS::BigInt>, radix: u8) -> *mut raw::JSString);
wrap!(raw: pub fn MaybeFreezeCtorAndPrototype(cx: *mut raw::JSContext, ctor: raw::JS::HandleObject, maybeProto: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn GetRealmObjectPrototypeHandle(cx: *mut raw::JSContext) -> raw::JS::Handle<*mut raw::JSObject>);
wrap!(raw: pub fn GetFunctionRealm(cx: *mut raw::JSContext, objArg: raw::JS::HandleObject) -> *mut raw::JS::Realm);
wrap!(raw: pub fn CaptureCurrentStack(cx: *mut raw::JSContext, stackp: raw::JS::MutableHandleObject, capture: *mut raw::JS::StackCapture) -> bool);
wrap!(raw: pub fn BuildStackString(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, stack: raw::JS::HandleObject, stringp: raw::JS::MutableHandleString, indent: usize, stackFormat: raw::js::StackFormat) -> bool);
wrap!(raw: pub fn Evaluate(cx: *mut raw::JSContext, options: *const raw::JS::ReadOnlyCompileOptions, srcBuf: *mut raw::JS::SourceText<u16>, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Evaluate1(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, options: *const raw::JS::ReadOnlyCompileOptions, srcBuf: *mut raw::JS::SourceText<u16>, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Evaluate2(cx: *mut raw::JSContext, options: *const raw::JS::ReadOnlyCompileOptions, srcBuf: *mut raw::JS::SourceText<raw::mozilla::Utf8Unit>, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn EvaluateUtf8Path(cx: *mut raw::JSContext, options: *const raw::JS::ReadOnlyCompileOptions, filename: *const ::std::os::raw::c_char, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn CompileFunction(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, options: *const raw::JS::ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut raw::JS::SourceText<u16>) -> *mut raw::JSFunction);
wrap!(raw: pub fn CompileFunction1(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, options: *const raw::JS::ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, srcBuf: *mut raw::JS::SourceText<raw::mozilla::Utf8Unit>) -> *mut raw::JSFunction);
wrap!(raw: pub fn CompileFunctionUtf8(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, options: *const raw::JS::ReadOnlyCompileOptions, name: *const ::std::os::raw::c_char, nargs: ::std::os::raw::c_uint, argnames: *const *const ::std::os::raw::c_char, utf8: *const ::std::os::raw::c_char, length: usize) -> *mut raw::JSFunction);
wrap!(raw: pub fn ExposeScriptToDebugger(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>));
wrap!(raw: pub fn UpdateDebugMetadata(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>, options: *const raw::JS::InstantiateOptions, privateValue: raw::JS::HandleValue, elementAttributeName: raw::JS::HandleString, introScript: raw::JS::HandleScript, scriptOrModule: raw::JS::HandleScript) -> bool);
wrap!(raw: pub fn CompileOptions_setIntroductionInfoToCaller(this: *mut raw::JS::CompileOptions, cx: *mut raw::JSContext, introductionType: *const ::std::os::raw::c_char, introductionScript: raw::JS::MutableHandle<*mut raw::JSScript>) -> *mut raw::JS::CompileOptions);
wrap!(raw: pub fn OrdinaryToPrimitive(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, type_: raw::JSType, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn ToGetterId(cx: *mut raw::JSContext, id: raw::JS::Handle<raw::JS::PropertyKey>, getterId: raw::JS::MutableHandle<raw::JS::PropertyKey>) -> bool);
wrap!(raw: pub fn ToSetterId(cx: *mut raw::JSContext, id: raw::JS::Handle<raw::JS::PropertyKey>, setterId: raw::JS::MutableHandle<raw::JS::PropertyKey>) -> bool);
wrap!(raw: pub fn ObjectOpResult_reportError(this: *mut raw::JS::ObjectOpResult, cx: *mut raw::JSContext, obj: raw::JS::HandleObject, id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn ObjectOpResult_reportError1(this: *mut raw::JS::ObjectOpResult, cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn ObjectIsDate(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isDate: *mut bool) -> bool);
wrap!(raw: pub fn StrictlyEqual(cx: *mut raw::JSContext, v1: raw::JS::Handle<raw::JS::Value>, v2: raw::JS::Handle<raw::JS::Value>, equal: *mut bool) -> bool);
wrap!(raw: pub fn LooselyEqual(cx: *mut raw::JSContext, v1: raw::JS::Handle<raw::JS::Value>, v2: raw::JS::Handle<raw::JS::Value>, equal: *mut bool) -> bool);
wrap!(raw: pub fn SameValue(cx: *mut raw::JSContext, v1: raw::JS::Handle<raw::JS::Value>, v2: raw::JS::Handle<raw::JS::Value>, same: *mut bool) -> bool);
wrap!(raw: pub fn ForOfIterator_init(this: *mut raw::JS::ForOfIterator, iterable: raw::JS::Handle<raw::JS::Value>, nonIterableBehavior: raw::JS::ForOfIterator_NonIterableBehavior) -> bool);
wrap!(raw: pub fn ForOfIterator_next(this: *mut raw::JS::ForOfIterator, val: raw::JS::MutableHandle<raw::JS::Value>, done: *mut bool) -> bool);
wrap!(raw: pub fn ToJSONMaybeSafely(cx: *mut raw::JSContext, input: raw::JS::Handle<*mut raw::JSObject>, callback: raw::JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn ToJSON(cx: *mut raw::JSContext, value: raw::JS::Handle<raw::JS::Value>, replacer: raw::JS::Handle<*mut raw::JSObject>, space: raw::JS::Handle<raw::JS::Value>, callback: raw::JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn ParseJSONWithHandler(chars: *const raw::JS::Latin1Char, len: u32, handler: *mut raw::JS::JSONParseHandler) -> bool);
wrap!(raw: pub fn ParseJSONWithHandler1(chars: *const u16, len: u32, handler: *mut raw::JS::JSONParseHandler) -> bool);
wrap!(raw: pub fn AddSizeOfTab(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, mallocSizeOf: raw::mozilla::MallocSizeOf, opv: *mut raw::JS::ObjectPrivateVisitor, sizes: *mut raw::JS::TabSizes) -> bool);
wrap!(raw: pub fn FinishDynamicModuleImport(cx: *mut raw::JSContext, evaluationPromise: raw::JS::Handle<*mut raw::JSObject>, referencingPrivate: raw::JS::Handle<raw::JS::Value>, moduleRequest: raw::JS::Handle<*mut raw::JSObject>, promise: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn ModuleLink(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn ModuleEvaluate(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn ThrowOnModuleEvaluationFailure(cx: *mut raw::JSContext, evaluationPromise: raw::JS::Handle<*mut raw::JSObject>, errorBehaviour: raw::JS::ModuleErrorBehaviour) -> bool);
wrap!(raw: pub fn GetRequestedModulesCount(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>) -> u32);
wrap!(raw: pub fn GetRequestedModuleSpecifier(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>, index: u32) -> *mut raw::JSString);
wrap!(raw: pub fn GetRequestedModuleSourcePos(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>, index: u32, lineNumber: *mut u32, columnNumber: *mut raw::JS::ColumnNumberOneOrigin));
wrap!(raw: pub fn GetModuleScript(moduleRecord: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSScript);
wrap!(raw: pub fn CreateModuleRequest(cx: *mut raw::JSContext, specifierArg: raw::JS::Handle<*mut raw::JSString>) -> *mut raw::JSObject);
wrap!(raw: pub fn GetModuleRequestSpecifier(cx: *mut raw::JSContext, moduleRequestArg: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSString);
wrap!(raw: pub fn GetModuleObject(moduleScript: raw::JS::Handle<*mut raw::JSScript>) -> *mut raw::JSObject);
wrap!(raw: pub fn GetModuleNamespace(cx: *mut raw::JSContext, moduleRecord: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn GetModuleForNamespace(cx: *mut raw::JSContext, moduleNamespace: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn GetModuleEnvironment(cx: *mut raw::JSContext, moduleObj: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn GetBuiltinClass(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, cls: *mut raw::js::ESClass) -> bool);
wrap!(raw: pub fn NewPromiseObject(cx: *mut raw::JSContext, executor: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn IsPromiseObject(obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn GetPromiseState(promise: raw::JS::HandleObject) -> raw::JS::PromiseState);
wrap!(raw: pub fn GetPromiseID(promise: raw::JS::HandleObject) -> u64);
wrap!(raw: pub fn GetPromiseResult(promise: raw::JS::HandleObject) -> raw::JS::Value);
wrap!(raw: pub fn GetPromiseIsHandled(promise: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn SetSettledPromiseIsHandled(cx: *mut raw::JSContext, promise: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn SetAnyPromiseIsHandled(cx: *mut raw::JSContext, promise: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn GetPromiseAllocationSite(promise: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn GetPromiseResolutionSite(promise: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn DumpPromiseAllocationSite(cx: *mut raw::JSContext, promise: raw::JS::HandleObject));
wrap!(raw: pub fn DumpPromiseResolutionSite(cx: *mut raw::JSContext, promise: raw::JS::HandleObject));
wrap!(raw: pub fn CallOriginalPromiseResolve(cx: *mut raw::JSContext, resolutionValue: raw::JS::HandleValue) -> *mut raw::JSObject);
wrap!(raw: pub fn CallOriginalPromiseReject(cx: *mut raw::JSContext, rejectionValue: raw::JS::HandleValue) -> *mut raw::JSObject);
wrap!(raw: pub fn ResolvePromise(cx: *mut raw::JSContext, promiseObj: raw::JS::HandleObject, resolutionValue: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn RejectPromise(cx: *mut raw::JSContext, promiseObj: raw::JS::HandleObject, rejectionValue: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn CallOriginalPromiseThen(cx: *mut raw::JSContext, promise: raw::JS::HandleObject, onFulfilled: raw::JS::HandleObject, onRejected: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn AddPromiseReactions(cx: *mut raw::JSContext, promise: raw::JS::HandleObject, onFulfilled: raw::JS::HandleObject, onRejected: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn AddPromiseReactionsIgnoringUnhandledRejection(cx: *mut raw::JSContext, promise: raw::JS::HandleObject, onFulfilled: raw::JS::HandleObject, onRejected: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn GetPromiseUserInputEventHandlingState(promise: raw::JS::HandleObject) -> raw::JS::PromiseUserInputEventHandlingState);
wrap!(raw: pub fn SetPromiseUserInputEventHandlingState(promise: raw::JS::HandleObject, state: raw::JS::PromiseUserInputEventHandlingState) -> bool);
wrap!(raw: pub fn GetWaitForAllPromise(cx: *mut raw::JSContext, promises: raw::JS::HandleObjectVector) -> *mut raw::JSObject);
wrap!(raw: pub fn ToCompletePropertyDescriptor(cx: *mut raw::JSContext, descriptor: raw::JS::Handle<raw::JS::Value>, desc: raw::JS::MutableHandle<raw::JS::PropertyDescriptor>) -> bool);
wrap!(raw: pub fn FromPropertyDescriptor(cx: *mut raw::JSContext, desc: raw::JS::Handle<raw::mozilla::Maybe>, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn NewSymbol(cx: *mut raw::JSContext, description: raw::JS::Handle<*mut raw::JSString>) -> *mut raw::JS::Symbol);
wrap!(raw: pub fn GetSymbolFor(cx: *mut raw::JSContext, key: raw::JS::Handle<*mut raw::JSString>) -> *mut raw::JS::Symbol);
wrap!(raw: pub fn GetSymbolDescription(symbol: raw::JS::Handle<*mut raw::JS::Symbol>) -> *mut raw::JSString);
wrap!(raw: pub fn GetSymbolCode(symbol: raw::JS::Handle<*mut raw::JS::Symbol>) -> raw::JS::SymbolCode);
wrap!(raw: pub fn NewArrayObject(cx: *mut raw::JSContext, contents: *const raw::JS::HandleValueArray) -> *mut raw::JSObject);
wrap!(raw: pub fn IsArrayObject(cx: *mut raw::JSContext, value: raw::JS::Handle<raw::JS::Value>, isArray: *mut bool) -> bool);
wrap!(raw: pub fn IsArrayObject1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isArray: *mut bool) -> bool);
wrap!(raw: pub fn GetArrayLength(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, lengthp: *mut u32) -> bool);
wrap!(raw: pub fn SetArrayLength(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, length: u32) -> bool);
wrap!(raw: pub fn IsArray(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isArray: *mut bool) -> bool);
wrap!(raw: pub fn IsArray1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, answer: *mut raw::JS::IsArrayAnswer) -> bool);
wrap!(raw: pub fn SetRegExpInput(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, input: raw::JS::Handle<*mut raw::JSString>) -> bool);
wrap!(raw: pub fn ClearRegExpStatics(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn ExecuteRegExp(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, reobj: raw::JS::Handle<*mut raw::JSObject>, chars: *const u16, length: usize, indexp: *mut usize, test: bool, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn ExecuteRegExpNoStatics(cx: *mut raw::JSContext, reobj: raw::JS::Handle<*mut raw::JSObject>, chars: *const u16, length: usize, indexp: *mut usize, test: bool, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn ObjectIsRegExp(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isRegExp: *mut bool) -> bool);
wrap!(raw: pub fn GetRegExpFlags(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> raw::JS::RegExpFlags);
wrap!(raw: pub fn GetRegExpSource(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSString);
wrap!(raw: pub fn CheckRegExpSyntax(cx: *mut raw::JSContext, chars: *const u16, length: usize, flags: raw::JS::RegExpFlags, error: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn GetSavedFrameSource(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, sourcep: raw::JS::MutableHandle<*mut raw::JSString>, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameSourceId(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, sourceIdp: *mut u32, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameLine(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, linep: *mut u32, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameColumn(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, columnp: *mut raw::JS::TaggedColumnNumberOneOrigin, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameFunctionDisplayName(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, namep: raw::JS::MutableHandle<*mut raw::JSString>, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameAsyncCause(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, asyncCausep: raw::JS::MutableHandle<*mut raw::JSString>, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameAsyncParent(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, asyncParentp: raw::JS::MutableHandle<*mut raw::JSObject>, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn GetSavedFrameParent(cx: *mut raw::JSContext, principals: *mut raw::JSPrincipals, savedFrame: raw::JS::Handle<*mut raw::JSObject>, parentp: raw::JS::MutableHandle<*mut raw::JSObject>, selfHosted: raw::JS::SavedFrameSelfHosted) -> raw::JS::SavedFrameResult);
wrap!(raw: pub fn ConvertSavedFrameToPlainObject(cx: *mut raw::JSContext, savedFrame: raw::JS::HandleObject, selfHosted: raw::JS::SavedFrameSelfHosted) -> *mut raw::JSObject);
wrap!(raw: pub fn NewReadableDefaultStreamObject(cx: *mut raw::JSContext, underlyingSource: raw::JS::HandleObject, size: raw::JS::HandleFunction, highWaterMark: f64, proto: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn NewReadableExternalSourceStreamObject(cx: *mut raw::JSContext, underlyingSource: *mut raw::JS::ReadableStreamUnderlyingSource, nsISupportsObject_alreadyAddreffed: *mut ::std::os::raw::c_void, proto: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn ReadableStreamGetExternalUnderlyingSource(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, source: *mut *mut raw::JS::ReadableStreamUnderlyingSource) -> bool);
wrap!(raw: pub fn ReadableStreamReleaseExternalUnderlyingSource(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn ReadableStreamUpdateDataAvailableFromSource(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, availableData: u32) -> bool);
wrap!(raw: pub fn ReadableStreamGetMode(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, mode: *mut raw::JS::ReadableStreamMode) -> bool);
wrap!(raw: pub fn ReadableStreamGetStoredError(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> raw::JS::Value);
wrap!(raw: pub fn ReadableStreamIsReadable(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, result: *mut bool) -> bool);
wrap!(raw: pub fn ReadableStreamIsLocked(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, result: *mut bool) -> bool);
wrap!(raw: pub fn ReadableStreamIsDisturbed(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, result: *mut bool) -> bool);
wrap!(raw: pub fn ReadableStreamIsErrored(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, result: *mut bool) -> bool);
wrap!(raw: pub fn ReadableStreamCancel(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, reason: raw::JS::HandleValue) -> *mut raw::JSObject);
wrap!(raw: pub fn ReadableStreamGetReader(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, mode: raw::JS::ReadableStreamReaderMode) -> *mut raw::JSObject);
wrap!(raw: pub fn ReadableStreamGetController(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn ReadableStreamControllerGetUnderlyingSource(cx: *mut raw::JSContext, controller: raw::JS::HandleObject, source: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn CheckReadableStreamControllerCanCloseOrEnqueue(cx: *mut raw::JSContext, controller: raw::JS::HandleObject, action: *const ::std::os::raw::c_char) -> bool);
wrap!(raw: pub fn ReadableStreamControllerShouldCallPull(cx: *mut raw::JSContext, controller: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn ReadableStreamTee(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, branch1Stream: raw::JS::MutableHandleObject, branch2Stream: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn ReadableStreamClose(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn ReadableStreamReaderIsClosed(cx: *mut raw::JSContext, reader: raw::JS::HandleObject, result: *mut bool) -> bool);
wrap!(raw: pub fn ReadableStreamEnqueue(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, chunk: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn ReadableStreamError(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, error: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn ReadableStreamReaderCancel(cx: *mut raw::JSContext, reader: raw::JS::HandleObject, reason: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn ReadableStreamReaderReleaseLock(cx: *mut raw::JSContext, reader: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn ReadableStreamBYOBReaderRead(cx: *mut raw::JSContext, reader: raw::JS::HandleObject, view: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn ReadableStreamDefaultReaderRead(cx: *mut raw::JSContext, reader: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn NewWritableDefaultStreamObject(cx: *mut raw::JSContext, underlyingSink: raw::JS::HandleObject, size: raw::JS::HandleFunction, highWaterMark: f64, proto: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn WritableStreamGetState(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> raw::JS::WritableStreamState);
wrap!(raw: pub fn WritableStreamIsLocked(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn WritableStreamGetWriter(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn WritableStreamGetController(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn WritableStreamControllerGetUnderlyingSink(cx: *mut raw::JSContext, controller: raw::JS::HandleObject) -> raw::JS::Value);
wrap!(raw: pub fn WritableStreamError(cx: *mut raw::JSContext, stream: raw::JS::HandleObject, error: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn WritableStreamGetStoredError(cx: *mut raw::JSContext, stream: raw::JS::HandleObject) -> raw::JS::Value);
wrap!(raw: pub fn IsWasmModuleObject(obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn GetWasmModule(obj: raw::JS::HandleObject) -> raw::RefPtr<raw::JS::WasmModule>);
wrap!(raw: pub fn FinishIncrementalEncoding(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>, buffer: *mut raw::JS::TranscodeBuffer) -> bool);
wrap!(raw: pub fn FinishIncrementalEncoding1(cx: *mut raw::JSContext, module: raw::JS::Handle<*mut raw::JSObject>, buffer: *mut raw::JS::TranscodeBuffer) -> bool);
wrap!(raw: pub fn AbortIncrementalEncoding(script: raw::JS::Handle<*mut raw::JSScript>));
wrap!(raw: pub fn AbortIncrementalEncoding1(module: raw::JS::Handle<*mut raw::JSObject>));
wrap!(raw: pub fn TypedArray_fromArray(cx: *mut raw::JSContext, other: raw::JS::HandleObject) -> u8);
wrap!(raw: pub fn TypedArray_fromBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::HandleObject, byteOffset: usize, length: i64) -> u8);
wrap!(raw: pub fn Call(cx: *mut raw::JSContext, thisObj: raw::JS::Handle<*mut raw::JSObject>, fun: raw::JS::Handle<*mut raw::JSFunction>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Call1(cx: *mut raw::JSContext, thisObj: raw::JS::Handle<*mut raw::JSObject>, fun: raw::JS::Handle<raw::JS::Value>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Call2(cx: *mut raw::JSContext, thisObj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Call3(cx: *mut raw::JSContext, thisv: raw::JS::Handle<raw::JS::Value>, fun: raw::JS::Handle<raw::JS::Value>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Call4(cx: *mut raw::JSContext, thisv: raw::JS::Handle<raw::JS::Value>, funObj: raw::JS::Handle<*mut raw::JSObject>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn Construct(cx: *mut raw::JSContext, fun: raw::JS::Handle<raw::JS::Value>, newTarget: raw::JS::Handle<*mut raw::JSObject>, args: *const raw::JS::HandleValueArray, objp: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn Construct1(cx: *mut raw::JSContext, fun: raw::JS::Handle<raw::JS::Value>, args: *const raw::JS::HandleValueArray, objp: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn CreateError(cx: *mut raw::JSContext, type_: raw::JSExnType, stack: raw::JS::HandleObject, fileName: raw::JS::HandleString, lineNumber: u32, column: raw::JS::ColumnNumberOneOrigin, report: *mut raw::JSErrorReport, message: raw::JS::HandleString, cause: raw::JS::Handle<raw::mozilla::Maybe>, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn ExceptionStackOrNull(obj: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn MapSize(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> u32);
wrap!(raw: pub fn MapGet(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn MapHas(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, rval: *mut bool) -> bool);
wrap!(raw: pub fn MapSet(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, val: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn MapDelete(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, rval: *mut bool) -> bool);
wrap!(raw: pub fn MapClear(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn MapKeys(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn MapValues(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn MapEntries(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn MapForEach(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, callbackFn: raw::JS::HandleValue, thisVal: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn SetSize(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> u32);
wrap!(raw: pub fn SetHas(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, rval: *mut bool) -> bool);
wrap!(raw: pub fn SetDelete(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue, rval: *mut bool) -> bool);
wrap!(raw: pub fn SetAdd(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, key: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn SetClear(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn SetKeys(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn SetValues(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn SetEntries(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, rval: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn SetForEach(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, callbackFn: raw::JS::HandleValue, thisVal: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn GetWeakMapEntry(cx: *mut raw::JSContext, mapObj: raw::JS::HandleObject, key: raw::JS::HandleValue, val: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn SetWeakMapEntry(cx: *mut raw::JSContext, mapObj: raw::JS::HandleObject, key: raw::JS::HandleValue, val: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn ProtoKeyToId(cx: *mut raw::JSContext, key: raw::JSProtoKey, idp: raw::JS::MutableHandleId));
wrap!(raw: pub fn ToPrimitive(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, hint: raw::JSType, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn OrdinaryHasInstance(cx: *mut raw::JSContext, objArg: raw::JS::HandleObject, v: raw::JS::HandleValue, bp: *mut bool) -> bool);
wrap!(raw: pub fn IsMapObject(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, isMap: *mut bool) -> bool);
wrap!(raw: pub fn IsSetObject(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, isSet: *mut bool) -> bool);
wrap!(raw: pub fn GetSelfHostedFunction(cx: *mut raw::JSContext, selfHostedName: *const ::std::os::raw::c_char, id: raw::JS::HandleId, nargs: ::std::os::raw::c_uint) -> *mut raw::JSFunction);
wrap!(raw: pub fn NewFunctionFromSpec(cx: *mut raw::JSContext, fs: *const raw::JSFunctionSpec, id: raw::JS::HandleId) -> *mut raw::JSFunction);
wrap!(raw: pub fn AutoSetAsyncStackForNewCalls_AutoSetAsyncStackForNewCalls(this: *mut raw::JS::AutoSetAsyncStackForNewCalls, cx: *mut raw::JSContext, stack: raw::JS::HandleObject, asyncCause: *const ::std::os::raw::c_char, kind: raw::JS::AutoSetAsyncStackForNewCalls_AsyncCallKind) -> *mut ::std::os::raw::c_void);
wrap!(raw: pub fn PropertySpecNameEqualsId(name: raw::JSPropertySpec_Name, id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn ForceLexicalInitialization(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_ForOfIteratorInit(iterator: *mut raw::JS::ForOfIterator, iterable: raw::JS::HandleValue, nonIterableBehavior: raw::JS::ForOfIterator_NonIterableBehavior) -> bool);
wrap!(raw: pub fn JS_ForOfIteratorNext(iterator: *mut raw::JS::ForOfIterator, val: raw::JS::MutableHandleValue, done: *mut bool) -> bool);
wrap!(raw: pub fn InvokeGetOwnPropertyDescriptor(handler: *const ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, id: raw::JS::HandleId, desc: raw::JS::MutableHandle<raw::JS::PropertyDescriptor>, isNone: *mut bool) -> bool);
wrap!(raw: pub fn InvokeHasOwn(handler: *const ::std::os::raw::c_void, cx: *mut raw::JSContext, proxy: raw::JS::HandleObject, id: raw::JS::HandleId, bp: *mut bool) -> bool);
wrap!(raw: pub fn CallJitGetterOp(info: *const raw::JSJitInfo, cx: *mut raw::JSContext, thisObj: raw::JS::HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: ::std::os::raw::c_uint, vp: *mut raw::JS::Value) -> bool);
wrap!(raw: pub fn CallJitSetterOp(info: *const raw::JSJitInfo, cx: *mut raw::JSContext, thisObj: raw::JS::HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: ::std::os::raw::c_uint, vp: *mut raw::JS::Value) -> bool);
wrap!(raw: pub fn CallJitMethodOp(info: *const raw::JSJitInfo, cx: *mut raw::JSContext, thisObj: raw::JS::HandleObject, specializedThis: *mut ::std::os::raw::c_void, argc: u32, vp: *mut raw::JS::Value) -> bool);
wrap!(raw: pub fn WrapperNew(aCx: *mut raw::JSContext, aObj: raw::JS::HandleObject, aHandler: *const ::std::os::raw::c_void, aClass: *const raw::JSClass) -> *mut raw::JSObject);
wrap!(raw: pub fn NewWindowProxy(aCx: *mut raw::JSContext, aObj: raw::JS::HandleObject, aHandler: *const ::std::os::raw::c_void) -> *mut raw::JSObject);
wrap!(raw: pub fn RUST_JSID_IS_INT(id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn int_to_jsid(i: i32, id: raw::JS::MutableHandleId));
wrap!(raw: pub fn RUST_JSID_TO_INT(id: raw::JS::HandleId) -> i32);
wrap!(raw: pub fn RUST_JSID_IS_STRING(id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn RUST_JSID_TO_STRING(id: raw::JS::HandleId) -> *mut raw::JSString);
wrap!(raw: pub fn RUST_SYMBOL_TO_JSID(sym: *mut raw::JS::Symbol, id: raw::JS::MutableHandleId));
wrap!(raw: pub fn RUST_JSID_IS_VOID(id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn RUST_INTERNED_STRING_TO_JSID(cx: *mut raw::JSContext, str_: *mut raw::JSString, id: raw::JS::MutableHandleId));
wrap!(raw: pub fn AppendToIdVector(v: raw::JS::MutableHandleIdVector, id: raw::JS::HandleId) -> bool);
wrap!(raw: pub fn JS_GetPromiseResult(promise: raw::JS::HandleObject, dest: raw::JS::MutableHandleValue));
wrap!(raw: pub fn JS_GetScriptPrivate(script: *mut raw::JSScript, dest: raw::JS::MutableHandleValue));
wrap!(raw: pub fn JS_MaybeGetScriptPrivate(obj: *mut raw::JSObject, dest: raw::JS::MutableHandleValue));
wrap!(raw: pub fn JS_GetModulePrivate(module: *mut raw::JSObject, dest: raw::JS::MutableHandleValue));
wrap!(raw: pub fn JS_GetScriptedCallerPrivate(cx: *mut raw::JSContext, dest: raw::JS::MutableHandleValue));
wrap!(raw: pub fn JS_GetRegExpFlags(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, flags: *mut raw::JS::RegExpFlags));
wrap!(raw: pub fn EncodeStringToUTF8(cx: *mut raw::JSContext, str_: raw::JS::HandleString, cb: raw::jsglue::EncodedStringCallback));
wrap!(raw: pub fn SetDataPropertyDescriptor(desc: raw::JS::MutableHandle<raw::JS::PropertyDescriptor>, value: raw::JS::HandleValue, attrs: u32));
wrap!(raw: pub fn SetAccessorPropertyDescriptor(desc: raw::JS::MutableHandle<raw::JS::PropertyDescriptor>, getter: raw::JS::HandleObject, setter: raw::JS::HandleObject, attrs: u32));
wrap!(raw: pub fn JS_Utf8BufferIsCompilableUnit(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, utf8: *const ::std::os::raw::c_char, length: usize) -> bool);
wrap!(raw: pub fn JS_ExecuteScript(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ExecuteScript1(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>) -> bool);
wrap!(raw: pub fn JS_ExecuteScript2(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, script: raw::JS::Handle<*mut raw::JSScript>, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ExecuteScript3(cx: *mut raw::JSContext, envChain: raw::JS::HandleObjectVector, script: raw::JS::Handle<*mut raw::JSScript>) -> bool);
wrap!(raw: pub fn JS_EncodeStringToUTF8(cx: *mut raw::JSContext, str_: raw::JS::Handle<*mut raw::JSString>) -> raw::JS::UniqueChars);
wrap!(raw: pub fn JS_Stringify(cx: *mut raw::JSContext, value: raw::JS::MutableHandle<raw::JS::Value>, replacer: raw::JS::Handle<*mut raw::JSObject>, space: raw::JS::Handle<raw::JS::Value>, callback: raw::JSONWriteCallback, data: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JS_ParseJSON(cx: *mut raw::JSContext, chars: *const u16, len: u32, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ParseJSON1(cx: *mut raw::JSContext, str_: raw::JS::Handle<*mut raw::JSString>, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ParseJSON2(cx: *mut raw::JSContext, chars: *const raw::JS::Latin1Char, len: u32, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ParseJSONWithReviver(cx: *mut raw::JSContext, chars: *const u16, len: u32, reviver: raw::JS::Handle<raw::JS::Value>, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_ParseJSONWithReviver1(cx: *mut raw::JSContext, str_: raw::JS::Handle<*mut raw::JSString>, reviver: raw::JS::Handle<raw::JS::Value>, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_GetOwnPropertyDescriptorById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn JS_GetOwnPropertyDescriptor(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn JS_GetOwnUCPropertyDescriptor(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn JS_GetPropertyDescriptorById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>, holder: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_GetPropertyDescriptor(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>, holder: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_GetUCPropertyDescriptor(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>, holder: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JSPropertySpec_getValue(this: *const raw::JSPropertySpec, cx: *mut raw::JSContext, value: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_NewDependentString(cx: *mut raw::JSContext, str_: raw::JS::Handle<*mut raw::JSString>, start: usize, length: usize) -> *mut raw::JSString);
wrap!(raw: pub fn JS_ConcatStrings(cx: *mut raw::JSContext, left: raw::JS::Handle<*mut raw::JSString>, right: raw::JS::Handle<*mut raw::JSString>) -> *mut raw::JSString);
wrap!(raw: pub fn JS_ReadStructuredClone(cx: *mut raw::JSContext, data: *const raw::JSStructuredCloneData, version: u32, scope: raw::JS::StructuredCloneScope, vp: raw::JS::MutableHandleValue, cloneDataPolicy: *const raw::JS::CloneDataPolicy, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JS_WriteStructuredClone(cx: *mut raw::JSContext, v: raw::JS::HandleValue, data: *mut raw::JSStructuredCloneData, scope: raw::JS::StructuredCloneScope, cloneDataPolicy: *const raw::JS::CloneDataPolicy, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void, transferable: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn JS_StructuredClone(cx: *mut raw::JSContext, v: raw::JS::HandleValue, vp: raw::JS::MutableHandleValue, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JSAutoStructuredCloneBuffer_read(this: *mut raw::JSAutoStructuredCloneBuffer, cx: *mut raw::JSContext, vp: raw::JS::MutableHandleValue, cloneDataPolicy: *const raw::JS::CloneDataPolicy, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JSAutoStructuredCloneBuffer_write(this: *mut raw::JSAutoStructuredCloneBuffer, cx: *mut raw::JSContext, v: raw::JS::HandleValue, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JSAutoStructuredCloneBuffer_write1(this: *mut raw::JSAutoStructuredCloneBuffer, cx: *mut raw::JSContext, v: raw::JS::HandleValue, transferable: raw::JS::HandleValue, cloneDataPolicy: *const raw::JS::CloneDataPolicy, optionalCallbacks: *const raw::JSStructuredCloneCallbacks, closure: *mut ::std::os::raw::c_void) -> bool);
wrap!(raw: pub fn JS_ReadString(r: *mut raw::JSStructuredCloneReader, str_: raw::JS::MutableHandleString) -> bool);
wrap!(raw: pub fn JS_ReadTypedArray(r: *mut raw::JSStructuredCloneReader, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_WriteString(w: *mut raw::JSStructuredCloneWriter, str_: raw::JS::HandleString) -> bool);
wrap!(raw: pub fn JS_WriteTypedArray(w: *mut raw::JSStructuredCloneWriter, v: raw::JS::HandleValue) -> bool);
wrap!(raw: pub fn JS_ObjectNotWritten(w: *mut raw::JSStructuredCloneWriter, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_NewInt8ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewInt8ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint8ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint8ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewInt16ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewInt16ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint16ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint16ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewInt32ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewInt32ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint32ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint32ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat32ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat32ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat64ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat64ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint8ClampedArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewUint8ClampedArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewBigInt64ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewBigInt64ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewBigUint64ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewBigUint64ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat16ArrayFromArray(cx: *mut raw::JSContext, array: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewFloat16ArrayWithBuffer(cx: *mut raw::JSContext, arrayBuffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, length: i64) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_GetArrayBufferViewBuffer(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, isSharedMemory: *mut bool) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewDataView(cx: *mut raw::JSContext, buffer: raw::JS::Handle<*mut raw::JSObject>, byteOffset: usize, byteLength: usize) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_CallFunctionValue(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, fval: raw::JS::Handle<raw::JS::Value>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_CallFunction(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, fun: raw::JS::Handle<*mut raw::JSFunction>, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_CallFunctionName(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, args: *const raw::JS::HandleValueArray, rval: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_DefineDebuggerObject(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_GetPendingException(cx: *mut raw::JSContext, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_SetPendingException(cx: *mut raw::JSContext, v: raw::JS::HandleValue, behavior: raw::JS::ExceptionStackBehavior));
wrap!(raw: pub fn JS_ErrorFromException(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> *mut raw::JSErrorReport);
wrap!(raw: pub fn JS_FireOnNewGlobalObject(cx: *mut raw::JSContext, global: raw::JS::HandleObject));
wrap!(raw: pub fn JS_DefinePropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById2(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: raw::JS::Handle<raw::JS::Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById3(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, getter: raw::JSNative, setter: raw::JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById4(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, getter: raw::JS::Handle<*mut raw::JSObject>, setter: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById5(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById6(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: raw::JS::Handle<*mut raw::JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById7(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById8(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefinePropertyById9(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: raw::JS::Handle<raw::JS::Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, getter: raw::JSNative, setter: raw::JSNative, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty2(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, getter: raw::JS::Handle<*mut raw::JSObject>, setter: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty3(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty4(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: raw::JS::Handle<*mut raw::JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty5(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty6(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineProperty7(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, desc: raw::JS::Handle<raw::JS::PropertyDescriptor>) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty2(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: raw::JS::Handle<raw::JS::Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty3(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, getter: raw::JS::Handle<*mut raw::JSObject>, setter: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty4(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty5(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: raw::JS::Handle<*mut raw::JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty6(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty7(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineUCProperty8(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: raw::JS::Handle<raw::JS::Value>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, getter: raw::JS::Handle<*mut raw::JSObject>, setter: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement2(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: raw::JS::Handle<*mut raw::JSObject>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement3(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: raw::JS::Handle<*mut raw::JSString>, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement4(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: i32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement5(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: u32, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_DefineElement6(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, value: f64, attrs: ::std::os::raw::c_uint) -> bool);
wrap!(raw: pub fn JS_HasPropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_HasProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_HasUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, vp: *mut bool) -> bool);
wrap!(raw: pub fn JS_HasElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_HasOwnPropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_HasOwnProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_ForwardGetPropertyTo(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, receiver: raw::JS::Handle<raw::JS::Value>, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_ForwardGetElementTo(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, receiver: raw::JS::Handle<*mut raw::JSObject>, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_GetPropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_GetProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_GetUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_GetElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_ForwardSetPropertyTo(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, v: raw::JS::Handle<raw::JS::Value>, receiver: raw::JS::Handle<raw::JS::Value>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_SetPropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, v: raw::JS::Handle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_SetProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, v: raw::JS::Handle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_SetUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, v: raw::JS::Handle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_SetElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: raw::JS::Handle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_SetElement1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_SetElement2(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: raw::JS::Handle<*mut raw::JSString>) -> bool);
wrap!(raw: pub fn JS_SetElement3(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: i32) -> bool);
wrap!(raw: pub fn JS_SetElement4(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: u32) -> bool);
wrap!(raw: pub fn JS_SetElement5(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, v: f64) -> bool);
wrap!(raw: pub fn JS_DeletePropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DeleteProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DeleteUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DeleteElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_DeletePropertyById1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>) -> bool);
wrap!(raw: pub fn JS_DeleteProperty1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char) -> bool);
wrap!(raw: pub fn JS_DeleteElement1(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32) -> bool);
wrap!(raw: pub fn JS_DefineObject(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, clasp: *const raw::JSClass, attrs: ::std::os::raw::c_uint) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_DefineProperties(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, ps: *const raw::JSPropertySpec) -> bool);
wrap!(raw: pub fn JS_AlreadyHasOwnPropertyById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_AlreadyHasOwnProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_AlreadyHasOwnUCProperty(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_AlreadyHasOwnElement(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, index: u32, foundp: *mut bool) -> bool);
wrap!(raw: pub fn JS_DefineFunctions(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, fs: *const raw::JSFunctionSpec) -> bool);
wrap!(raw: pub fn JS_DefineFunction(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const ::std::os::raw::c_char, call: raw::JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut raw::JSFunction);
wrap!(raw: pub fn JS_DefineUCFunction(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, name: *const u16, namelen: usize, call: raw::JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut raw::JSFunction);
wrap!(raw: pub fn JS_DefineFunctionById(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, id: raw::JS::Handle<raw::jsid>, call: raw::JSNative, nargs: ::std::os::raw::c_uint, attrs: ::std::os::raw::c_uint) -> *mut raw::JSFunction);
wrap!(raw: pub fn JS_RefreshCrossCompartmentWrappers(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_ValueToObject(cx: *mut raw::JSContext, v: raw::JS::HandleValue, objp: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_ValueToFunction(cx: *mut raw::JSContext, v: raw::JS::HandleValue) -> *mut raw::JSFunction);
wrap!(raw: pub fn JS_ValueToConstructor(cx: *mut raw::JSContext, v: raw::JS::HandleValue) -> *mut raw::JSFunction);
wrap!(raw: pub fn JS_ValueToSource(cx: *mut raw::JSContext, v: raw::JS::Handle<raw::JS::Value>) -> *mut raw::JSString);
wrap!(raw: pub fn JS_TypeOfValue(cx: *mut raw::JSContext, v: raw::JS::Handle<raw::JS::Value>) -> raw::JSType);
wrap!(raw: pub fn JS_WrapObject(cx: *mut raw::JSContext, objp: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_WrapValue(cx: *mut raw::JSContext, vp: raw::JS::MutableHandleValue) -> bool);
wrap!(raw: pub fn JS_TransplantObject(cx: *mut raw::JSContext, origobj: raw::JS::HandleObject, target: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_ResolveStandardClass(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, id: raw::JS::HandleId, resolved: *mut bool) -> bool);
wrap!(raw: pub fn JS_EnumerateStandardClasses(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_NewEnumerateStandardClasses(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, properties: raw::JS::MutableHandleIdVector, enumerableOnly: bool) -> bool);
wrap!(raw: pub fn JS_NewEnumerateStandardClassesIncludingResolved(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, properties: raw::JS::MutableHandleIdVector, enumerableOnly: bool) -> bool);
wrap!(raw: pub fn JS_GetClassObject(cx: *mut raw::JSContext, key: raw::JSProtoKey, objp: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_GetClassPrototype(cx: *mut raw::JSContext, key: raw::JSProtoKey, objp: raw::JS::MutableHandle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_IdToProtoKey(cx: *mut raw::JSContext, id: raw::JS::HandleId) -> raw::JSProtoKey);
wrap!(raw: pub fn JS_InitReflectParse(cx: *mut raw::JSContext, global: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_DefineProfilingFunctions(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_ValueToId(cx: *mut raw::JSContext, v: raw::JS::HandleValue, idp: raw::JS::MutableHandleId) -> bool);
wrap!(raw: pub fn JS_StringToId(cx: *mut raw::JSContext, s: raw::JS::HandleString, idp: raw::JS::MutableHandleId) -> bool);
wrap!(raw: pub fn JS_IdToValue(cx: *mut raw::JSContext, id: raw::jsid, vp: raw::JS::MutableHandle<raw::JS::Value>) -> bool);
wrap!(raw: pub fn JS_InitClass(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, protoClass: *const raw::JSClass, protoProto: raw::JS::HandleObject, name: *const ::std::os::raw::c_char, constructor: raw::JSNative, nargs: ::std::os::raw::c_uint, ps: *const raw::JSPropertySpec, fs: *const raw::JSFunctionSpec, static_ps: *const raw::JSPropertySpec, static_fs: *const raw::JSFunctionSpec) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_LinkConstructorAndPrototype(cx: *mut raw::JSContext, ctor: raw::JS::Handle<*mut raw::JSObject>, proto: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_InstanceOf(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, clasp: *const raw::JSClass, args: *mut raw::JS::CallArgs) -> bool);
wrap!(raw: pub fn JS_HasInstance(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>, v: raw::JS::Handle<raw::JS::Value>, bp: *mut bool) -> bool);
wrap!(raw: pub fn JS_GetConstructor(cx: *mut raw::JSContext, proto: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewObjectWithGivenProto(cx: *mut raw::JSContext, clasp: *const raw::JSClass, proto: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_DeepFreezeObject(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_FreezeObject(cx: *mut raw::JSContext, obj: raw::JS::Handle<*mut raw::JSObject>) -> bool);
wrap!(raw: pub fn JS_GetPrototype(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, result: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_GetPrototypeIfOrdinary(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, isOrdinary: *mut bool, result: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_SetPrototype(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, proto: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_IsExtensible(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, extensible: *mut bool) -> bool);
wrap!(raw: pub fn JS_PreventExtensions(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, result: *mut raw::JS::ObjectOpResult) -> bool);
wrap!(raw: pub fn JS_SetImmutablePrototype(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, succeeded: *mut bool) -> bool);
wrap!(raw: pub fn JS_AssignObject(cx: *mut raw::JSContext, target: raw::JS::HandleObject, src: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_SetAllNonReservedSlotsToUndefined(obj: raw::JS::HandleObject));
wrap!(raw: pub fn JS_GetFunctionId(cx: *mut raw::JSContext, fun: raw::JS::Handle<*mut raw::JSFunction>, name: raw::JS::MutableHandle<*mut raw::JSString>) -> bool);
wrap!(raw: pub fn JS_GetFunctionDisplayId(cx: *mut raw::JSContext, fun: raw::JS::Handle<*mut raw::JSFunction>, name: raw::JS::MutableHandle<*mut raw::JSString>) -> bool);
wrap!(raw: pub fn JS_GetFunctionLength(cx: *mut raw::JSContext, fun: raw::JS::HandleFunction, length: *mut u16) -> bool);
wrap!(raw: pub fn JS_GetFunctionScript(cx: *mut raw::JSContext, fun: raw::JS::HandleFunction) -> *mut raw::JSScript);
wrap!(raw: pub fn JS_DecompileScript(cx: *mut raw::JSContext, script: raw::JS::Handle<*mut raw::JSScript>) -> *mut raw::JSString);
wrap!(raw: pub fn JS_DecompileFunction(cx: *mut raw::JSContext, fun: raw::JS::Handle<*mut raw::JSFunction>) -> *mut raw::JSString);
wrap!(raw: pub fn JS_IndexToId(cx: *mut raw::JSContext, index: u32, arg1: raw::JS::MutableHandleId) -> bool);
wrap!(raw: pub fn JS_CharsToId(cx: *mut raw::JSContext, chars: raw::JS::TwoByteChars, arg1: raw::JS::MutableHandleId) -> bool);
wrap!(raw: pub fn JS_IsIdentifier(cx: *mut raw::JSContext, str_: raw::JS::HandleString, isIdentifier: *mut bool) -> bool);
wrap!(raw: pub fn JS_FindCompilationScope(cx: *mut raw::JSContext, obj: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NewObjectWithoutMetadata(cx: *mut raw::JSContext, clasp: *const raw::JSClass, proto: raw::JS::Handle<*mut raw::JSObject>) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_NondeterministicGetWeakMapKeys(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, ret: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_NondeterministicGetWeakSetKeys(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, ret: raw::JS::MutableHandleObject) -> bool);
wrap!(raw: pub fn JS_CloneObject(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, proto: raw::JS::HandleObject) -> *mut raw::JSObject);
wrap!(raw: pub fn JS_InitializePropertiesFromCompatibleNativeObject(cx: *mut raw::JSContext, dst: raw::JS::HandleObject, src: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_CopyOwnPropertiesAndPrivateFields(cx: *mut raw::JSContext, target: raw::JS::HandleObject, obj: raw::JS::HandleObject) -> bool);
wrap!(raw: pub fn JS_WrapPropertyDescriptor(cx: *mut raw::JSContext, desc: raw::JS::MutableHandle<raw::JS::PropertyDescriptor>) -> bool);
wrap!(raw: pub fn JS_WrapPropertyDescriptor1(cx: *mut raw::JSContext, desc: raw::JS::MutableHandle<raw::mozilla::Maybe>) -> bool);
wrap!(raw: pub fn JS_DefineFunctionsWithHelp(cx: *mut raw::JSContext, obj: raw::JS::HandleObject, fs: *const raw::JSFunctionSpecWithHelp) -> bool);
