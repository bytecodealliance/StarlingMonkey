/* automatically generated by rust-bindgen 0.69.4 */

unsafe impl Sync for root::JSClass {}
unsafe impl Sync for root::JSFunctionSpec {}
unsafe impl Sync for root::JSNativeWrapper {}
unsafe impl Sync for root::JSPropertySpec {}
unsafe impl Sync for root::JSTypedMethodJitInfo {}

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!(
                (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
            );
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!(
                (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len(),
            );
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub type FILE = ::libc::FILE;
    pub const JS_DEBUG: u8 = 1;
    pub const JS_GC_ZEAL: u8 = 1;
    pub const JS_NUNBOX32: u8 = 1;
    pub const JS_BITS_PER_WORD: u8 = 32;
    pub const JSVAL_INT_BITS: u8 = 32;
    pub const JSVAL_TAG_SHIFT: u8 = 32;
    pub const JS_STRUCTURED_CLONE_VERSION: u8 = 8;
    pub const JS_SCERR_RECURSION: u8 = 0;
    pub const JS_SCERR_TRANSFERABLE: u8 = 1;
    pub const JS_SCERR_DUP_TRANSFERABLE: u8 = 2;
    pub const JS_SCERR_UNSUPPORTED_TYPE: u8 = 3;
    pub const JS_SCERR_SHMEM_TRANSFERABLE: u8 = 4;
    pub const JS_SCERR_TYPED_ARRAY_DETACHED: u8 = 5;
    pub const JS_SCERR_WASM_NO_TRANSFER: u8 = 6;
    pub const JS_SCERR_NOT_CLONABLE: u8 = 7;
    pub const JS_SCERR_NOT_CLONABLE_WITH_COOP_COEP: u8 = 8;
    pub const JSITER_PRIVATE: u8 = 4;
    pub const JSITER_OWNONLY: u8 = 8;
    pub const JSITER_HIDDEN: u8 = 16;
    pub const JSITER_SYMBOLS: u8 = 32;
    pub const JSITER_SYMBOLSONLY: u8 = 64;
    pub const JSITER_FORAWAITOF: u8 = 128;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type enable_if_t = u8;
        pub type integral_constant_value_type = u8;
        pub type integral_constant_type = u8;
        pub type false_type = u8;
        pub type remove_const_t = u8;
        pub type remove_cv_t = u8;
        pub type remove_reference_t = u8;
        pub type conditional_t = u8;
        pub type add_pointer_t = u8;
        pub type underlying_type_t = u8;
        pub type make_signed_t = u8;
        pub type make_unsigned_t = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum float_round_style {
            round_indeterminate = -1,
            round_toward_zero = 0,
            round_to_nearest = 1,
            round_toward_infinity = 2,
            round_toward_neg_infinity = 3,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum float_denorm_style {
            denorm_indeterminate = -1,
            denorm_absent = 0,
            denorm_present = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct numeric_limits {
            pub _address: u8,
        }
        pub type numeric_limits___base = u8;
        pub type numeric_limits_type = u8;
        pub mod ranges {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct input_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct forward_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[repr(align(1))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct random_access_iterator_tag {
            pub _bindgen_opaque_blob: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct reverse_iterator {
            pub _address: u8,
        }
        pub type reverse_iterator_iterator_type = u8;
        pub type reverse_iterator_iterator_category = u8;
        pub type reverse_iterator_pointer = u8;
        pub type reverse_iterator_iterator_concept = u8;
        pub type reverse_iterator_value_type = u8;
        pub type reverse_iterator_difference_type = u8;
        pub type reverse_iterator_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic___base = u8;
        pub type atomic_value_type = u8;
        pub type atomic_difference_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple {
            pub _address: u8,
        }
        pub type tuple__BaseT = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__IsThisTuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__EnableUTypesCtor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__EnableCtorFromUTypesTuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__CtorPredicateFromPair {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__EnableCtorFromPair {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__NothrowConstructibleFromPair {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct tuple__BothImplicitlyConvertible {
            pub _address: u8,
        }
        pub mod __variant_detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub type uint_fast8_t = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _IO_FILE {
        _unused: [u8; 0],
    }
    pub type va_list = root::__builtin_va_list;
    pub mod mozilla {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AssertionConditionType {
                pub _address: u8,
            }
            pub type AssertionConditionType_ValueT = u8;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum StorageType {
                AsBase = 0,
                AsMember = 1,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasPointerTypeHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasPointerType {
                pub _address: u8,
            }
            pub type PointerTypeImpl_Type = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct PointerType {
                pub _address: u8,
            }
            pub type PointerType_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            /** UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be
 transferred out of a UniquePtr through explicit action, but otherwise the
 resource is destroyed when the UniquePtr is destroyed.

 UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr
 in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr
 obviously *can't* copy ownership of its singly-owned resource.  So what
 happens if you try to copy one?  Bizarrely, ownership is implicitly
 *transferred*, preserving single ownership but breaking code that assumes a
 copy of an object is identical to the original.  (This is why auto_ptr is
 prohibited in STL containers.)

 UniquePtr solves this problem by being *movable* rather than copyable.
 Instead of passing a |UniquePtr u| directly to the constructor or assignment
 operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*
 ownership out of |u|, into the target of the construction/assignment.  After
 the transfer completes, |u| contains |nullptr| and may be safely destroyed.
 This preserves single ownership but also allows UniquePtr to be moved by
 algorithms that have been made move-safe.  (Note: if |u| is instead a
 temporary expression, don't use |Move()|: just pass the expression, because
 it's already move-ready.  For more information see Move.h.)

 UniquePtr is also better than std::auto_ptr in that the deletion operation is
 customizable.  An optional second template parameter specifies a class that
 (through its operator()(T*)) implements the desired deletion policy.  If no
 policy is specified, mozilla::DefaultDelete<T> is used -- which will either
 |delete| or |delete[]| the resource, depending whether the resource is an
 array.  Custom deletion policies ideally should be empty classes (no member
 fields, no member fields in base classes, no virtual methods/inheritance),
 because then UniquePtr can be just as efficient as a raw pointer.

 Use of UniquePtr proceeds like so:

   UniquePtr<int> g1; // initializes to nullptr
   g1.reset(new int); // switch resources using reset()
   g1 = nullptr; // clears g1, deletes the int

   UniquePtr<int> g2(new int); // owns that int
   int* p = g2.release(); // g2 leaks its int -- still requires deletion
   delete p; // now freed

   struct S { int x; S(int x) : x(x) {} };
   UniquePtr<S> g3, g4(new S(5));
   g3 = std::move(g4); // g3 owns the S, g4 cleared
   S* p = g3.get(); // g3 still owns |p|
   assert(g3->x == 5); // operator-> works (if .get() != nullptr)
   assert((*g3).x == 5); // also operator* (again, if not cleared)
   std::swap(g3, g4); // g4 now owns the S, g3 cleared
   g3.swap(g4);  // g3 now owns the S, g4 cleared
   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared
   g5.reset(); // deletes the S, g5 cleared

   struct FreePolicy { void operator()(void* p) { free(p); } };
   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));
   int* ptr = g6.get();
   g6 = nullptr; // calls free(ptr)

 Now, carefully note a few things you *can't* do:

   UniquePtr<int> b1;
   b1 = new int; // BAD: can only assign another UniquePtr
   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()

   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr
   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr

 (Note that changing a UniquePtr to store a direct |new| expression is
 permitted, but usually you should use MakeUnique, defined at the end of this
 header.)

 A few miscellaneous notes:

 UniquePtr, when not instantiated for an array type, can be move-constructed
 and move-assigned, not only from itself but from "derived" UniquePtr<U, E>
 instantiations where U converts to T and E converts to D.  If you want to use
 this, you're going to have to specify a deletion policy for both UniquePtr
 instantations, and T pretty much has to have a virtual destructor.  In other
 words, this doesn't work:

   struct Base { virtual ~Base() {} };
   struct Derived : Base {};

   UniquePtr<Base> b1;
   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert
   UniquePtr<Derived> d1(std::move(b));

   UniquePtr<Base> b2;
   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay

 UniquePtr is specialized for array types.  Specializing with an array type
 creates a smart-pointer version of that array -- not a pointer to such an
 array.

   UniquePtr<int[]> arr(new int[5]);
   arr[0] = 4;

 What else is different?  Deletion of course uses |delete[]|.  An operator[]
 is provided.  Functionality that doesn't make sense for arrays is removed.
 The constructors and mutating methods only accept array pointers (not T*, U*
 that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.

 It's perfectly okay for a function to return a UniquePtr. This transfers
 the UniquePtr's sole ownership of the data, to the fresh UniquePtr created
 in the calling function, that will then solely own that data. Such functions
 can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where
 |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.

 UniquePtr will commonly be a member of a class, with lifetime equivalent to
 that of that class.  If you want to expose the related resource, you could
 expose a raw pointer via |get()|, but ownership of a raw pointer is
 inherently unclear.  So it's better to expose a |const UniquePtr&| instead.
 This prohibits mutation but still allows use of |get()| when needed (but
 operator-> is preferred).  Of course, you can only use this smart pointer as
 long as the enclosing class instance remains live -- no different than if you
 exposed the |get()| raw pointer.

 To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|
 argument.  To specify an inout parameter (where the method may or may not
 take ownership of the resource, or reset it), or to specify an out parameter
 (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|
 argument.  To unconditionally transfer ownership of a UniquePtr
 into a method, use a |UniquePtr| argument.  To conditionally transfer
 ownership of a resource into a method, should the method want it, use a
 |UniquePtr&&| argument.*/
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct TempPtrToSetterT<T, UniquePtrT> {
                pub mDest: *mut UniquePtrT,
                pub mNewVal: *mut T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
                pub _phantom_1: ::std::marker::PhantomData<
                    ::std::cell::UnsafeCell<UniquePtrT>,
                >,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct LazyAssertedCastT<From> {
                pub mVal: From,
                pub _phantom_0: ::std::marker::PhantomData<
                    ::std::cell::UnsafeCell<From>,
                >,
            }
            pub type IntrinsicBase_ValueType = u8;
            pub type IntrinsicBase_OrderedOp = u8;
            pub type IntrinsicMemoryOps_Base = u8;
            pub type IntrinsicAddSub_Base = u8;
            pub type IntrinsicIncDec_Base = u8;
            pub type AtomicIntrinsics_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ToStorageTypeArgument {
                pub _address: u8,
            }
            pub type AtomicBase_Intrinsics = u8;
            pub type AtomicBase_ValueType = root::mozilla::detail::AtomicBase_Intrinsics;
            pub type AtomicBaseIncDec_Base = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AlignasHelper<T> {
                pub mT: T,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AlignedChecker {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AllowDeprecatedAbsFixed {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AllowDeprecatedAbs {
                pub _base: root::mozilla::detail::AllowDeprecatedAbsFixed,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AbsReturnType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct VectorTesting {
                _unused: [u8; 0],
            }
            pub type supports_os<T> = T;
            /** LinkedList supports refcounted elements using this adapter class. Clients
 using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 reference to T as long as T is in the list.*/
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct LinkedListElementTraits {
                pub _address: u8,
            }
            pub type LinkedListElementTraits_RawType<T> = *mut T;
            pub type LinkedListElementTraits_ConstRawType<T> = *const T;
            pub type LinkedListElementTraits_ClientType<T> = *mut T;
            pub type LinkedListElementTraits_ConstClientType<T> = *const T;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct MaybePoisoner {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsMaybeImpl {
                pub _base: root::std::false_type,
            }
            pub type IsMaybe = root::mozilla::detail::IsMaybeImpl;
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum PackingStrategy {
                Variant = 0,
                NullIsOk = 1,
                LowBitTagIsError = 2,
                PackedVariant = 3,
                ZeroIsEmptyError = 4,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct EmptyWrapper<V> {
                pub _base: V,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
            }
            pub type AlignedStorageOrEmpty = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ResultImplementationNullIsOkBase {
                pub mValue: root::mozilla::CompactPair,
            }
            pub type ResultImplementationNullIsOkBase_ErrorStorageType = root::mozilla::detail::UnusedZero;
            pub type UnsignedIntType = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant_VEbool<V, E> {
                pub v: V,
                pub e: E,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsPackableVariant_EVbool<V, E> {
                pub e: E,
                pub v: V,
                pub ok: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<V>>,
                pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
            }
            pub type IsPackableVariant_Impl = root::std::conditional_t;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnusedZero {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnusedZeroEnum {
                pub _address: u8,
            }
            pub type UnusedZeroEnum_StorageType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HasFreeLSB {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectResultImpl {
                pub _address: u8,
            }
            pub type SelectResultImpl_Type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IsResult {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrapToSignedHelper {
                pub _address: u8,
            }
            pub type WrapToSignedHelper_SignedType = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingAddHelper {
                pub _address: u8,
            }
            pub type WrappingAddHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingSubtractHelper {
                pub _address: u8,
            }
            pub type WrappingSubtractHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct WrappingMultiplyHelper {
                pub _address: u8,
            }
            pub type WrappingMultiplyHelper_UnsignedT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTableEntry {
                pub _address: u8,
            }
            pub type HashTableEntry_NonConstT = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct EntrySlot {
                pub mEntry: *mut root::mozilla::detail::EntrySlot_Entry,
                pub mKeyHash: *mut root::mozilla::HashNumber,
            }
            pub type EntrySlot_NonConstT = u8;
            pub type EntrySlot_Entry = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct HashTable {
                pub _address: u8,
            }
            /// SelectVariantTypeHelper is used in the implementation of SelectVariantType.
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectVariantTypeHelper {
                pub _address: u8,
            }
            /** SelectVariantType takes a type T and a list of variant types Variants and
 yields a type Type, selected from Variants, that can store a value of type T
 or a reference to type T. If no such type was found, Type is not defined.
 SelectVariantType also has a `count` member that contains the total number of
 selectable types (which will be used to check that a requested type is not
 ambiguously present twice.)*/
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SelectVariantType {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct VariantTag {
                pub _address: u8,
            }
            pub type VariantTag_Type = root::std::conditional_t;
            /** AsVariantTemporary stores a value of type T to allow construction of a
 Variant value via type inference. Because T is copied and there's no
 guarantee that the copy can be elided, AsVariantTemporary is best used with
 primitive or very small types.*/
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct AsVariantTemporary {
                pub mValue: root::std::remove_const_t,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FloatingPointTrait {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FuzzyEqualsEpsilon {
                pub _address: u8,
            }
            pub const kShortStringLimitForInlinePaths: usize = 16;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct MakeUnsignedChar {
                pub _address: u8,
            }
            pub type MakeUnsignedChar_Type = u8;
            extern "C" {
                #[link_name = "\u{1}_ZN7mozilla6detail23InvalidArrayIndex_CRASHEmm"]
                pub fn InvalidArrayIndex_CRASH(aIndex: usize, aLength: usize) -> !;
                #[link_name = "\u{1}_ZN7mozilla6detail16supports_os_testEz"]
                pub fn supports_os_test() -> root::std::false_type;
                #[link_name = "\u{1}_ZN7mozilla6detail11IsValidUtf8EPKvm"]
                pub fn IsValidUtf8(
                    aCodeUnits: *const ::std::os::raw::c_void,
                    aCount: usize,
                ) -> bool;
            }
        }
        /** CompactPair is the logical concatenation of an instance of A with an instance
 B. Space is conserved when possible.  Neither A nor B may be a final class.

 In general if space conservation is not critical is preferred to use
 std::pair.

 It's typically clearer to have individual A and B member fields.  Except if
 you want the space-conserving qualities of CompactPair, you're probably
 better off not using this!

 No guarantees are provided about the memory layout of A and B, the order of
 initialization or destruction of A and B, and so on.  (This is approximately
 required to optimize space usage.)  The first/second names are merely
 conceptual!*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompactPair {
            pub _address: u8,
        }
        pub type CompactPair_Base = u8;
        /** UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be
 transferred out of a UniquePtr through explicit action, but otherwise the
 resource is destroyed when the UniquePtr is destroyed.

 UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr
 in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr
 obviously *can't* copy ownership of its singly-owned resource.  So what
 happens if you try to copy one?  Bizarrely, ownership is implicitly
 *transferred*, preserving single ownership but breaking code that assumes a
 copy of an object is identical to the original.  (This is why auto_ptr is
 prohibited in STL containers.)

 UniquePtr solves this problem by being *movable* rather than copyable.
 Instead of passing a |UniquePtr u| directly to the constructor or assignment
 operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*
 ownership out of |u|, into the target of the construction/assignment.  After
 the transfer completes, |u| contains |nullptr| and may be safely destroyed.
 This preserves single ownership but also allows UniquePtr to be moved by
 algorithms that have been made move-safe.  (Note: if |u| is instead a
 temporary expression, don't use |Move()|: just pass the expression, because
 it's already move-ready.  For more information see Move.h.)

 UniquePtr is also better than std::auto_ptr in that the deletion operation is
 customizable.  An optional second template parameter specifies a class that
 (through its operator()(T*)) implements the desired deletion policy.  If no
 policy is specified, mozilla::DefaultDelete<T> is used -- which will either
 |delete| or |delete[]| the resource, depending whether the resource is an
 array.  Custom deletion policies ideally should be empty classes (no member
 fields, no member fields in base classes, no virtual methods/inheritance),
 because then UniquePtr can be just as efficient as a raw pointer.

 Use of UniquePtr proceeds like so:

   UniquePtr<int> g1; // initializes to nullptr
   g1.reset(new int); // switch resources using reset()
   g1 = nullptr; // clears g1, deletes the int

   UniquePtr<int> g2(new int); // owns that int
   int* p = g2.release(); // g2 leaks its int -- still requires deletion
   delete p; // now freed

   struct S { int x; S(int x) : x(x) {} };
   UniquePtr<S> g3, g4(new S(5));
   g3 = std::move(g4); // g3 owns the S, g4 cleared
   S* p = g3.get(); // g3 still owns |p|
   assert(g3->x == 5); // operator-> works (if .get() != nullptr)
   assert((*g3).x == 5); // also operator* (again, if not cleared)
   std::swap(g3, g4); // g4 now owns the S, g3 cleared
   g3.swap(g4);  // g3 now owns the S, g4 cleared
   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared
   g5.reset(); // deletes the S, g5 cleared

   struct FreePolicy { void operator()(void* p) { free(p); } };
   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));
   int* ptr = g6.get();
   g6 = nullptr; // calls free(ptr)

 Now, carefully note a few things you *can't* do:

   UniquePtr<int> b1;
   b1 = new int; // BAD: can only assign another UniquePtr
   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()

   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr
   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr

 (Note that changing a UniquePtr to store a direct |new| expression is
 permitted, but usually you should use MakeUnique, defined at the end of this
 header.)

 A few miscellaneous notes:

 UniquePtr, when not instantiated for an array type, can be move-constructed
 and move-assigned, not only from itself but from "derived" UniquePtr<U, E>
 instantiations where U converts to T and E converts to D.  If you want to use
 this, you're going to have to specify a deletion policy for both UniquePtr
 instantations, and T pretty much has to have a virtual destructor.  In other
 words, this doesn't work:

   struct Base { virtual ~Base() {} };
   struct Derived : Base {};

   UniquePtr<Base> b1;
   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert
   UniquePtr<Derived> d1(std::move(b));

   UniquePtr<Base> b2;
   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay

 UniquePtr is specialized for array types.  Specializing with an array type
 creates a smart-pointer version of that array -- not a pointer to such an
 array.

   UniquePtr<int[]> arr(new int[5]);
   arr[0] = 4;

 What else is different?  Deletion of course uses |delete[]|.  An operator[]
 is provided.  Functionality that doesn't make sense for arrays is removed.
 The constructors and mutating methods only accept array pointers (not T*, U*
 that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.

 It's perfectly okay for a function to return a UniquePtr. This transfers
 the UniquePtr's sole ownership of the data, to the fresh UniquePtr created
 in the calling function, that will then solely own that data. Such functions
 can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where
 |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.

 UniquePtr will commonly be a member of a class, with lifetime equivalent to
 that of that class.  If you want to expose the related resource, you could
 expose a raw pointer via |get()|, but ownership of a raw pointer is
 inherently unclear.  So it's better to expose a |const UniquePtr&| instead.
 This prohibits mutation but still allows use of |get()| when needed (but
 operator-> is preferred).  Of course, you can only use this smart pointer as
 long as the enclosing class instance remains live -- no different than if you
 exposed the |get()| raw pointer.

 To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|
 argument.  To specify an inout parameter (where the method may or may not
 take ownership of the resource, or reset it), or to specify an out parameter
 (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|
 argument.  To unconditionally transfer ownership of a UniquePtr
 into a method, use a |UniquePtr| argument.  To conditionally transfer
 ownership of a resource into a method, should the method want it, use a
 |UniquePtr&&| argument.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UniquePtr {
            pub _address: u8,
        }
        pub type UniquePtr_ElementType = u8;
        pub type UniquePtr_DeleterType = u8;
        pub type UniquePtr_Pointer = u8;
        /** A default deletion policy using plain old operator delete.

 Note that this type can be specialized, but authors should beware of the risk
 that the specialization may at some point cease to match (either because it
 gets moved to a different compilation unit or the signature changes). If the
 non-specialized (|delete|-based) version compiles for that type but does the
 wrong thing, bad things could happen.

 This is a non-issue for types which are always incomplete (i.e. opaque handle
 types), since |delete|-ing such a type will always trigger a compilation
 error.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DefaultDelete {
            pub _address: u8,
        }
        #[repr(u32)]
        /** An enum of memory ordering possibilities for atomics.

 Memory ordering is the observable state of distinct values in memory.
 (It's a separate concept from atomicity, which concerns whether an
 operation can ever be observed in an intermediate state.  Don't
 conflate the two!)  Given a sequence of operations in source code on
 memory, it is *not* always the case that, at all times and on all
 cores, those operations will appear to have occurred in that exact
 sequence.  First, the compiler might reorder that sequence, if it
 thinks another ordering will be more efficient.  Second, the CPU may
 not expose so consistent a view of memory.  CPUs will often perform
 their own instruction reordering, above and beyond that performed by
 the compiler.  And each core has its own memory caches, and accesses
 (reads and writes both) to "memory" may only resolve to out-of-date
 cache entries -- not to the "most recently" performed operation in
 some global sense.  Any access to a value that may be used by
 multiple threads, potentially across multiple cores, must therefore
 have a memory ordering imposed on it, for all code on all
 threads/cores to have a sufficiently coherent worldview.

 http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync and
 http://en.cppreference.com/w/cpp/atomic/memory_order go into more
 detail on all this, including examples of how each mode works.

 Note that for simplicity and practicality, not all of the modes in
 C++11 are supported.  The missing C++11 modes are either subsumed by
 the modes we provide below, or not relevant for the CPUs we support
 in Gecko.  These three modes are confusing enough as it is!*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryOrdering {
            Relaxed = 0,
            ReleaseAcquire = 1,
            SequentiallyConsistent = 2,
        }
        pub mod tl {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            /// Compute the number of bits in the given unsigned type.
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BitSize {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static Min_value: usize;
                #[link_name = "\u{1}value"]
                pub static Max_value: usize;
                #[link_name = "\u{1}value"]
                pub static FloorLog2_value: usize;
                #[link_name = "\u{1}value"]
                pub static CeilingLog2_value: usize;
                #[link_name = "\u{1}value"]
                pub static RoundUpPow2_value: usize;
                #[link_name = "\u{1}checkPrecondition"]
                pub static NBitMask_checkPrecondition: usize;
                #[link_name = "\u{1}value"]
                pub static NBitMask_value: usize;
                #[link_name = "\u{1}value"]
                pub static MulOverflowMask_value: usize;
            }
        }
        pub const dynamic_extent: usize = 4294967295;
        pub mod span_details {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_span_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_span {
                pub _base: root::mozilla::span_details::is_span_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_std_array_oracle {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_std_array {
                pub _base: root::mozilla::span_details::is_std_array_oracle,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct is_allowed_element_type_conversion {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SpanKnownBounds {
                pub _address: u8,
            }
            pub type span_iterator_element_type_ = [u8; 0usize];
            pub type span_iterator_iterator_category = root::std::random_access_iterator_tag;
            pub type span_iterator_value_type = u8;
            pub type span_iterator_difference_type = isize;
            pub type span_iterator_reference = *mut root::std::conditional_t;
            pub type span_iterator_pointer = u8;
            pub type extent_type_index_type = usize;
        }
        pub type Span_element_type<ElementType> = ElementType;
        pub type Span_value_type = u8;
        pub type Span_index_type = usize;
        pub type Span_pointer<ElementType> = *mut root::mozilla::Span_element_type<
            ElementType,
        >;
        pub type Span_reference<ElementType> = *mut root::mozilla::Span_element_type<
            ElementType,
        >;
        pub type Span_iterator = u8;
        pub type Span_const_iterator = u8;
        pub type Span_reverse_iterator = u8;
        pub type Span_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Span_storage_type<ElementType, ExtentType> {
            pub _base: ExtentType,
            pub data_: root::mozilla::Span_pointer<ElementType>,
            pub _phantom_0: ::std::marker::PhantomData<
                ::std::cell::UnsafeCell<ElementType>,
            >,
            pub _phantom_1: ::std::marker::PhantomData<
                ::std::cell::UnsafeCell<ExtentType>,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AlignmentFinder {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AlignmentFinder_Aligner<T> {
            pub mChar: ::std::os::raw::c_char,
            pub mT: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        pub struct AlignedStorage2 {
            pub u: root::mozilla::AlignedStorage2_U,
        }
        #[repr(C)]
        pub union AlignedStorage2_U {
            pub mBytes: *mut ::std::os::raw::c_char,
            pub mDummy: u64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NeverAllocPolicy {
            pub _address: u8,
        }
        pub type MallocSizeOf = ::std::option::Option<
            unsafe extern "C" fn(p: *const ::std::os::raw::c_void) -> usize,
        >;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NotNullTag {
            KnownNotNull = 0,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReentrancyGuard {
            pub mEntered: *mut bool,
        }
        pub type Vector_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_CapacityAndReserved {
            pub mCapacity: usize,
            pub mReserved: usize,
        }
        pub type Vector_ElementType<T> = T;
        pub const Vector_InlineLength: root::mozilla::Vector__bindgen_ty_1 = Vector__bindgen_ty_1::InlineLength;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Vector__bindgen_ty_1 {
            InlineLength = 0,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_Range<T> {
            pub mCur: *mut T,
            pub mEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Vector_ConstRange<T> {
            pub mCur: *const T,
            pub mEnd: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /** DebugOnly contains a value of type T, but only in debug builds.  In release
 builds, it does not contain a value.  This helper is intended to be used with
 MOZ_ASSERT()-style macros, allowing one to write:

   DebugOnly<bool> check = func();
   MOZ_ASSERT(check);

 more concisely than declaring |check| conditional on #ifdef DEBUG.

 DebugOnly instances can only be coerced to T in debug builds.  In release
 builds they don't have a value, so type coercion is not well defined.

 NOTE: DebugOnly instances still take up one byte of space, plus padding, even
 in optimized, non-DEBUG builds (see bug 1253094 comment 37 for more info).
 For this reason the class is MOZ_STACK_CLASS to prevent consumers using
 DebugOnly for struct/class members and unwittingly inflating the size of
 their objects in release builds.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct DebugOnly<T> {
            pub value: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Array_ElementType<T> = T;
        pub type Array_iterator<T> = *mut T;
        pub type Array_const_iterator<T> = *const T;
        pub type Array_reverse_iterator = u8;
        pub type Array_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct EnumTypeFitsWithin {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MinContiguousEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxContiguousEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxEnumValue {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContiguousEnumValues {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContiguousEnumSize {
            pub _address: u8,
        }
        pub type EnumeratedArray_ArrayType = u8;
        pub type EnumeratedArray_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        pub type EnumeratedArray_const_reverse_iterator = root::mozilla::EnumeratedArray_ArrayType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unused_t {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MovingNotNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OwningNonNull {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StaticLocalRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StaticRefPtr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RefPtrTraits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LinkedListElement {
            pub mNext: *mut root::mozilla::LinkedListElement,
            pub mPrev: *mut root::mozilla::LinkedListElement,
            pub mIsSentinel: bool,
        }
        /** LinkedList supports refcounted elements using this adapter class. Clients
 using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 reference to T as long as T is in the list.*/
        pub type LinkedListElement_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedListElement_RawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstRawType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ClientType = root::mozilla::LinkedListElement_Traits;
        pub type LinkedListElement_ConstClientType = root::mozilla::LinkedListElement_Traits;
        impl root::mozilla::LinkedListElement_NodeKind {
            pub const Sentinel: root::mozilla::LinkedListElement_NodeKind = LinkedListElement_NodeKind::Normal;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum LinkedListElement_NodeKind {
            Normal = 0,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LinkedList {
            pub sentinel: root::mozilla::LinkedListElement,
        }
        /** LinkedList supports refcounted elements using this adapter class. Clients
 using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 reference to T as long as T is in the list.*/
        pub type LinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type LinkedList_RawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstRawType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ConstClientType = root::mozilla::LinkedList_Traits;
        pub type LinkedList_ElementType = *mut root::mozilla::LinkedListElement;
        pub type LinkedList_ConstElementType = *const root::mozilla::LinkedListElement;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct LinkedList_Iterator<Type> {
            pub mCurrent: Type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Type>>,
        }
        pub type LinkedList_Iterator_iterator_category = root::std::forward_iterator_tag;
        pub type LinkedList_Iterator_value_type<T> = T;
        pub type LinkedList_Iterator_difference_type = ::std::os::raw::c_long;
        pub type LinkedList_Iterator_pointer<T> = *mut T;
        pub type LinkedList_Iterator_reference<T> = *mut T;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoCleanLinkedList {
            pub _base: root::mozilla::LinkedList,
        }
        /** LinkedList supports refcounted elements using this adapter class. Clients
 using LinkedList<RefPtr<T>> will get a data structure that holds a strong
 reference to T as long as T is in the list.*/
        pub type AutoCleanLinkedList_Traits = root::mozilla::detail::LinkedListElementTraits;
        pub type AutoCleanLinkedList_ClientType = root::mozilla::detail::LinkedListElementTraits;
        /** A version of CorruptionCanary that is suitable as a member of objects that
 are statically allocated.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CorruptionCanaryForStatics {
            pub mValue: usize,
        }
        pub const CorruptionCanaryForStatics_kCanarySet: usize = 252382987;
        /** This class is designed to cause crashes when various kinds of memory
 corruption are observed. For instance, let's say we have a class C where we
 suspect out-of-bounds writes to some members.  We can insert a member of type
 Poison near the members we suspect are being corrupted by out-of-bounds
 writes.  Or perhaps we have a class K we suspect is subject to use-after-free
 violations, in which case it doesn't particularly matter where in the class
 we add the member of type Poison.

 In either case, we then insert calls to Check() throughout the code.  Doing
 so enables us to narrow down the location where the corruption is occurring.
 A pleasant side-effect of these additional Check() calls is that crash
 signatures may become more regular, as crashes will ideally occur
 consolidated at the point of a Check(), rather than scattered about at
 various uses of the corrupted memory.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CorruptionCanary {
            pub _base: root::mozilla::CorruptionCanaryForStatics,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Nothing {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Maybe {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Maybe_SomeGuard {
            pub _address: u8,
        }
        pub type Maybe_ValueType<T> = T;
        /** Empty struct, indicating success for operations that have no return value.
 For example, if you declare another empty struct `struct OutOfMemory {};`,
 then `Result<Ok, OutOfMemory>` represents either success or OOM.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Ok {
            pub _address: u8,
        }
        /** A tag used to differentiate between GenericErrorResult created by the Err
 function (completely new error) and GenericErrorResult created by the
 Result::propagateErr function (propagated error). This can be used to track
 error propagation and eventually produce error stacks for logging/debugging
 purposes.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ErrorPropagationTag {
            pub _address: u8,
        }
        /** Result<V, E> represents the outcome of an operation that can either succeed
 or fail. It contains either a success value of type V or an error value of
 type E.

 All Result methods are const, so results are basically immutable.
 This is just like Variant<V, E> but with a slightly different API, and the
 following cases are optimized so Result can be stored more efficiently:

 - If both the success and error types do not use their least significant bit,
 are trivially copyable and destructible, Result<V, E> is guaranteed to be as
 large as the larger type. This is determined via the HasFreeLSB trait. By
 default, empty classes (in particular Ok) and aligned pointer types are
 assumed to have a free LSB, but you can specialize this trait for other
 types. If the success type is empty, the representation is guaranteed to be
 all zero bits on success. Do not change this representation! There is JIT
 code that depends on it. (Implementation note: The lowest bit is used as a
 tag bit: 0 to indicate the Result's bits are a success value, 1 to indicate
 the Result's bits (with the 1 masked out) encode an error value)

 - Else, if the error type can't have a all-zero bits representation and is
 not larger than a pointer, a CompactPair is used to represent this rather
 than a Variant. This has shown to be better optimizable, and the template
 code is much simpler than that of Variant, so it should also compile faster.
 Whether an error type can't be all-zero bits, is determined via the
 UnusedZero trait. MFBT doesn't declare any public type UnusedZero, but
 nsresult is declared UnusedZero in XPCOM.

 The purpose of Result is to reduce the screwups caused by using `false` or
 `nullptr` to indicate errors.
 What screwups? See <https://bugzilla.mozilla.org/show_bug.cgi?id=912928> for
 a partial list.

 Result<const V, E> or Result<V, const E> are not meaningful. The success or
 error values in a Result instance are non-modifiable in-place anyway. This
 guarantee must also be maintained when evolving Result. They can be
 unwrap()ped, but this loses const qualification. However, Result<const V, E>
 or Result<V, const E> may be misleading and prevent movability. Just use
 Result<V, E>. (Result<const V*, E> may make sense though, just Result<const
 V* const, E> is not possible.)*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Result {
            pub mImpl: root::mozilla::Result_Impl,
        }
        pub type Result_Impl = root::mozilla::detail::SelectResultImpl;
        pub type Result_ok_type<V> = V;
        pub type Result_err_type<E> = E;
        /** A type that auto-converts to an error Result. This is like a Result without
 a success type. It's the best return type for functions that always return
 an error--functions designed to build and populate error objects. It's also
 useful in error-handling macros; see MOZ_TRY for an example.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GenericErrorResult<E> {
            pub mErrorValue: E,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<E>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BitSet_Reference {
            pub mBitSet: *mut u8,
            pub mPos: usize,
        }
        pub type HashNumber = u32;
        pub const kHashNumberBits: u32 = 32;
        /// The golden ratio as a 32-bit fixed-point value.
        pub const kGoldenRatioU32: root::mozilla::HashNumber = 2654435769;
        /** A pseudorandom function mapping 32-bit integers to 32-bit integers.

 This is for when you're feeding private data (like pointer values or credit
 card numbers) to a non-crypto hash function (like HashBytes) and then using
 the hash code for something that untrusted parties could observe (like a JS
 Map). Plug in a HashCodeScrambler before that last step to avoid leaking the
 private data.

 By itself, this does not prevent hash-flooding DoS attacks, because an
 attacker can still generate many values with exactly equal hash codes by
 attacking the non-crypto hash function alone. Equal hash codes will, of
 course, still be equal however much you scramble them.

 The algorithm is SipHash-1-3. See <https://131002.net/siphash/>.*/
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashCodeScrambler {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashCodeScrambler_SipHasher {
            pub _bindgen_opaque_blob: [u64; 4usize],
        }
        /** Opaque<T> is a replacement for integral T in cases where only comparisons
 must be supported, and it's desirable to prevent accidental dependency on
 exact values.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Opaque<T> {
            pub mValue: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        /** Opaque<T> is a replacement for integral T in cases where only comparisons
 must be supported, and it's desirable to prevent accidental dependency on
 exact values.*/
        pub type Generation = root::mozilla::Opaque<u64>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMap {
            pub _address: u8,
        }
        pub type HashMap_TableEntry = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMap_MapHashPolicy {
            pub _address: u8,
        }
        pub type HashMap_MapHashPolicy_Base = u8;
        pub type HashMap_MapHashPolicy_KeyType = u8;
        pub type HashMap_Impl = u8;
        pub type HashMap_Lookup = u8;
        pub type HashMap_Entry = u8;
        pub type HashMap_Ptr = u8;
        pub type HashMap_AddPtr = u8;
        pub type HashMap_Iterator = u8;
        pub type HashMap_ModIterator = u8;
        pub type HashMap_Range = u8;
        pub type HashMap_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashSet {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashSet_SetHashPolicy {
            pub _address: u8,
        }
        pub type HashSet_SetHashPolicy_Base = u8;
        pub type HashSet_SetHashPolicy_KeyType = u8;
        pub type HashSet_Impl = u8;
        pub type HashSet_Lookup = u8;
        pub type HashSet_Entry = u8;
        pub type HashSet_Ptr = u8;
        pub type HashSet_AddPtr = u8;
        pub type HashSet_Iterator = u8;
        pub type HashSet_ModIterator = u8;
        pub type HashSet_Range = u8;
        pub type HashSet_Enum = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PointerHasher {
            pub _address: u8,
        }
        pub type PointerHasher_Lookup<Key> = Key;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DefaultHasher {
            pub _address: u8,
        }
        pub type DefaultHasher_Lookup<Key> = Key;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CStringHasher {
            pub _address: u8,
        }
        pub type CStringHasher_Key = *const ::std::os::raw::c_char;
        pub type CStringHasher_Lookup = *const ::std::os::raw::c_char;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FallibleHashMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HashMapEntry {
            pub _address: u8,
        }
        pub type HashMapEntry_KeyType = u8;
        pub type HashMapEntry_ValueType = u8;
        pub mod ipc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IPDLParamTraits {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct VariantType {
            pub _address: u8,
        }
        pub type VariantType_Type<T> = T;
        /** # mozilla::Variant

 A variant / tagged union / heterogenous disjoint union / sum-type template
 class. Similar in concept to (but not derived from) `boost::variant`.

 Sometimes, you may wish to use a C union with non-POD types. However, this is
 forbidden in C++ because it is not clear which type in the union should have
 its constructor and destructor run on creation and deletion
 respectively. This is the problem that `mozilla::Variant` solves.

 ## Usage

 A `mozilla::Variant` instance is constructed (via move or copy) from one of
 its variant types (ignoring const and references). It does *not* support
 construction from subclasses of variant types or types that coerce to one of
 the variant types.

     Variant<char, uint32_t> v1('a');
     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());
     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed
     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int

 Because specifying the full type of a Variant value is often verbose,
 there are two easier ways to construct values:

 A. AsVariant() can be used to construct a Variant value using type inference
 in contexts such as expressions or when returning values from functions.
 Because AsVariant() must copy or move the value into a temporary and this
 cannot necessarily be elided by the compiler, it's mostly appropriate only
 for use with primitive or very small types.

     Variant<char, uint32_t> Foo() { return AsVariant('x'); }
     // ...
     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').

 B. Brace-construction with VariantType or VariantIndex; this also allows
 in-place construction with any number of arguments.

     struct AB { AB(int, int){...} };
     static Variant<AB, bool> foo()
     {
       return {VariantIndex<0>{}, 1, 2};
     }
     // ...
     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).

 All access to the contained value goes through type-safe accessors.
 Either the stored type, or the type index may be provided.

     void
     Foo(Variant<A, B, C> v)
     {
       if (v.is<A>()) {
         A& ref = v.as<A>();
         ...
       } else (v.is<1>()) { // Instead of v.is<B>.
         ...
       } else {
         ...
       }
     }

 In some situation, a Variant may be constructed from templated types, in
 which case it is possible that the same type could be given multiple times by
 an external developer. Or seemingly-different types could be aliases.
 In this case, repeated types can only be accessed through their index, to
 prevent ambiguous access by type.

    // Bad!
    template <typename T>
    struct ResultOrError
    {
      Variant<T, int> m;
      ResultOrError() : m(int(0)) {} // Error '0' by default
      ResultOrError(const T& r) : m(r) {}
      bool IsResult() const { return m.is<T>(); }
      bool IsError() const { return m.is<int>(); }
    };
    // Now instantiante with the result being an int too:
    ResultOrError<int> myResult(123); // Fail!
    // In Variant<int, int>, which 'int' are we refering to, from inside
    // ResultOrError functions?

    // Good!
    template <typename T>
    struct ResultOrError
    {
      Variant<T, int> m;
      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default
      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}
      bool IsResult() const { return m.is<0>(); } // 0 -> T
      bool IsError() const { return m.is<1>(); } // 1 -> int
    };
    // Now instantiante with the result being an int too:
    ResultOrError<int> myResult(123); // It now works!

 Attempting to use the contained value as type `T1` when the `Variant`
 instance contains a value of type `T2` causes an assertion failure.

     A a;
     Variant<A, B, C> v(a);
     v.as<B>(); // <--- Assertion failure!

 Trying to use a `Variant<Ts...>` instance as some type `U` that is not a
 member of the set of `Ts...` is a compiler error.

     A a;
     Variant<A, B, C> v(a);
     v.as<SomeRandomType>(); // <--- Compiler error!

 Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it
 out of the containing `Variant` instance with the `extract<T>` method:

     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());
     auto ptr = v.extract<UniquePtr<A>>();

 Finally, you can exhaustively match on the contained variant and branch into
 different code paths depending on which type is contained. This is preferred
 to manually checking every variant type T with is<T>() because it provides
 compile-time checking that you handled every type, rather than runtime
 assertion failures.

     // Bad!
     char* foo(Variant<A, B, C, D>& v) {
       if (v.is<A>()) {
         return ...;
       } else if (v.is<B>()) {
         return ...;
       } else {
         return doSomething(v.as<C>()); // Forgot about case D!
       }
     }

     // Instead, a single function object (that can deal with all possible
     // options) may be provided:
     struct FooMatcher
     {
       // The return type of all matchers must be identical.
       char* operator()(A& a) { ... }
       char* operator()(B& b) { ... }
       char* operator()(C& c) { ... }
       char* operator()(D& d) { ... } // Compile-time error to forget D!
     }
     char* foo(Variant<A, B, C, D>& v) {
       return v.match(FooMatcher());
     }

     // In some situations, a single generic lambda may also be appropriate:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](auto&) {...});
     }

     // Alternatively, multiple function objects may be provided, each one
     // corresponding to an option, in the same order:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](A&) { ... },
                      [](B&) { ... },
                      [](C&) { ... },
                      [](D&) { ... });
     }

     // In rare cases, the index of the currently-active alternative is
     // needed, it may be obtained by adding a first parameter in the matcner
     // callback, which will receive the index in its most compact type (just
     // use `size_t` if the exact type is not important), e.g.:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](auto aIndex, auto& aAlternative) {...});
       // --OR--
       return v.match([](size_t aIndex, auto& aAlternative) {...});
     }

 ## Examples

 A tree is either an empty leaf, or a node with a value and two children:

     struct Leaf { };

     template<typename T>
     struct Node
     {
       T value;
       Tree<T>* left;
       Tree<T>* right;
     };

     template<typename T>
     using Tree = Variant<Leaf, Node<T>>;

 A copy-on-write string is either a non-owning reference to some existing
 string, or an owning reference to our copy:

     class CopyOnWriteString
     {
       Variant<const char*, UniquePtr<char[]>> string;

       ...
     };

 Because Variant must be aligned suitable to hold any value stored within it,
 and because |alignas| requirements don't affect platform ABI with respect to
 how parameters are laid out in memory, Variant can't be used as the type of a
 function parameter.  Pass Variant to functions by pointer or reference
 instead.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Variant {
            pub _address: u8,
        }
        pub type Variant_Tag = root::mozilla::detail::VariantTag;
        pub type Variant_Impl = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RangedPtr<T> {
            pub mPtr: *mut T,
            pub mRangeStart: *mut T,
            pub mRangeEnd: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Range<T> {
            pub mStart: root::mozilla::RangedPtr<T>,
            pub mEnd: root::mozilla::RangedPtr<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FloatingPoint {
            pub _address: u8,
        }
        pub type FloatingPoint_Base = root::mozilla::detail::FloatingPointTrait;
        /** An unsigned integral type suitable for accessing the bitwise representation
 of T.*/
        pub type FloatingPoint_Bits = root::mozilla::FloatingPoint_Base;
        pub type InfinityBits_Traits = root::mozilla::FloatingPoint;
        pub type SpecificNaNBits_Traits = root::mozilla::FloatingPoint;
        /** EnumSet<T, U> is a set of values defined by an enumeration. It is implemented
 using a bit mask with the size of U for each value. It works both for enum
 and enum class types. EnumSet also works with U being a BitSet.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct EnumSet<Serialized> {
            pub mBitField: Serialized,
            pub mVersion: u64,
            pub _phantom_0: ::std::marker::PhantomData<
                ::std::cell::UnsafeCell<Serialized>,
            >,
        }
        pub type EnumSet_valueType<T> = T;
        pub type EnumSet_serializedType<Serialized> = Serialized;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct EnumSet_ConstIterator<Serialized> {
            pub mSet: *const root::mozilla::EnumSet<Serialized>,
            pub mPos: usize,
            pub mVersion: u64,
            pub _phantom_0: ::std::marker::PhantomData<
                ::std::cell::UnsafeCell<Serialized>,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList_Segment {
            pub mData: *mut ::std::os::raw::c_char,
            pub mSize: usize,
            pub mCapacity: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferList_IterImpl {
            pub mSegment: usize,
            pub mData: *mut ::std::os::raw::c_char,
            pub mDataEnd: *mut ::std::os::raw::c_char,
            pub mAbsoluteOffset: usize,
        }
        /** A code unit within a UTF-8 encoded string.  (A code unit is the smallest
 unit within the Unicode encoding of a string.  For UTF-8 this is an 8-bit
 number; for UTF-16 it would be a 16-bit number.)

 This is *not* the same as a single code point: in UTF-8, non-ASCII code
 points are constituted by multiple code units.*/
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union Utf8Unit {
            pub mValue: ::std::os::raw::c_char,
        }
        pub type TimeStampValue = u64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TimeStampTests {
            _unused: [u8; 0],
        }
        /// Platform-specific implementation details of BaseTimeDuration.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseTimeDurationPlatformUtils {
            pub _address: u8,
        }
        impl BaseTimeDurationPlatformUtils {
            #[inline]
            pub unsafe fn ToSeconds(aTicks: i64) -> f64 {
                BaseTimeDurationPlatformUtils_ToSeconds(aTicks)
            }
            #[inline]
            pub unsafe fn ToSecondsSigDigits(aTicks: i64) -> f64 {
                BaseTimeDurationPlatformUtils_ToSecondsSigDigits(aTicks)
            }
            #[inline]
            pub unsafe fn TicksFromMilliseconds(aMilliseconds: f64) -> i64 {
                BaseTimeDurationPlatformUtils_TicksFromMilliseconds(aMilliseconds)
            }
            #[inline]
            pub unsafe fn ResolutionInTicks() -> i64 {
                BaseTimeDurationPlatformUtils_ResolutionInTicks()
            }
        }
        /** Instances of this class represent the length of an interval of time.
 Negative durations are allowed, meaning the end is before the start.

 Internally the duration is stored as a int64_t in units of
 PR_TicksPerSecond() when building with NSPR interval timers, or a
 system-dependent unit when building with system clocks.  The
 system-dependent unit must be constant, otherwise the semantics of
 this class would be broken.

 The ValueCalculator template parameter determines how arithmetic
 operations are performed on the integer count of ticks (mValue).*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseTimeDuration {
            pub mValue: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseTimeDuration__SomethingVeryRandomHere {
            _unused: [u8; 0],
        }
        /** Perform arithmetic operations on the value of a BaseTimeDuration without
 doing strict checks on the range of values.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeDurationValueCalculator {
            pub _address: u8,
        }
        /** Specialization of BaseTimeDuration that uses TimeDurationValueCalculator for
 arithmetic on the mValue member.

 Use this class for time durations that are *not* expected to hold values of
 Forever (or the negative equivalent) or when such time duration are *not*
 expected to be used in arithmetic operations.*/
        pub type TimeDuration = root::mozilla::BaseTimeDuration;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeStamp {
            /** When built with PRIntervalTime, a value of 0 means this instance
 is "null". Otherwise, the low 32 bits represent a PRIntervalTime,
 and the high 32 bits represent a counter of the number of
 rollovers of PRIntervalTime that we've seen. This counter starts
 at 1 to avoid a real time colliding with the "null" value.

 PR_INTERVAL_MAX is set at 100,000 ticks per second. So the minimum
 time to wrap around is about 2^64/100000 seconds, i.e. about
 5,849,424 years.

 When using a system clock, a value is system dependent.*/
            pub mValue: root::mozilla::TimeStampValue,
        }
        impl TimeStamp {
            #[inline]
            pub unsafe fn ProcessCreation() -> root::mozilla::TimeStamp {
                TimeStamp_ProcessCreation()
            }
            #[inline]
            pub unsafe fn FirstTimeStamp() -> root::mozilla::TimeStamp {
                TimeStamp_FirstTimeStamp()
            }
            #[inline]
            pub unsafe fn RecordProcessRestart() {
                TimeStamp_RecordProcessRestart()
            }
            #[inline]
            pub unsafe fn Startup() {
                TimeStamp_Startup()
            }
            #[inline]
            pub unsafe fn Shutdown() {
                TimeStamp_Shutdown()
            }
        }
        extern "C" {
            #[must_use]
            /** Hash some number of bytes.

 This hash walks word-by-word, rather than byte-by-byte, so you won't get the
 same result out of HashBytes as you would out of HashString.*/
            #[link_name = "\u{1}_ZN7mozilla9HashBytesEPKvm"]
            pub fn HashBytes(
                bytes: *const ::std::os::raw::c_void,
                aLength: usize,
            ) -> root::mozilla::HashNumber;
            #[link_name = "\u{1}index"]
            pub static VariantIndex_index: usize;
            #[must_use]
            /** Returns true if |aValue| can be losslessly represented as an IEEE-754 single
 precision number, false otherwise.  All NaN values are considered
 representable (even though the bit patterns of double precision NaNs can't
 all be exactly represented in single precision).*/
            #[link_name = "\u{1}_ZN7mozilla22IsFloat32RepresentableEd"]
            pub fn IsFloat32Representable(aValue: f64) -> bool;
            #[link_name = "\u{1}_ZN7mozilla29BaseTimeDurationPlatformUtils9ToSecondsEx"]
            pub fn BaseTimeDurationPlatformUtils_ToSeconds(aTicks: i64) -> f64;
            #[link_name = "\u{1}_ZN7mozilla29BaseTimeDurationPlatformUtils18ToSecondsSigDigitsEx"]
            pub fn BaseTimeDurationPlatformUtils_ToSecondsSigDigits(aTicks: i64) -> f64;
            #[link_name = "\u{1}_ZN7mozilla29BaseTimeDurationPlatformUtils21TicksFromMillisecondsEd"]
            pub fn BaseTimeDurationPlatformUtils_TicksFromMilliseconds(
                aMilliseconds: f64,
            ) -> i64;
            #[link_name = "\u{1}_ZN7mozilla29BaseTimeDurationPlatformUtils17ResolutionInTicksEv"]
            pub fn BaseTimeDurationPlatformUtils_ResolutionInTicks() -> i64;
            /** Return a timestamp representing the time when the current process was
 created which will be comparable with other timestamps taken with this
 class.

 @returns A timestamp representing the time when the process was created*/
            #[link_name = "\u{1}_ZN7mozilla9TimeStamp15ProcessCreationEv"]
            pub fn TimeStamp_ProcessCreation() -> root::mozilla::TimeStamp;
            /** Return the very first timestamp that was taken. This can be used instead
 of TimeStamp::ProcessCreation() by code that might not allow running the
 complex logic required to compute the real process creation. This will
 necessarily have been recorded sometimes after TimeStamp::ProcessCreation()
 or at best should be equal to it.

 @returns The first tiemstamp that was taken by this process*/
            #[link_name = "\u{1}_ZN7mozilla9TimeStamp14FirstTimeStampEv"]
            pub fn TimeStamp_FirstTimeStamp() -> root::mozilla::TimeStamp;
            /** Records a process restart. After this call ProcessCreation() will return
 the time when the browser was restarted instead of the actual time when
 the process was created.*/
            #[link_name = "\u{1}_ZN7mozilla9TimeStamp20RecordProcessRestartEv"]
            pub fn TimeStamp_RecordProcessRestart();
            #[link_name = "\u{1}_ZN7mozilla9TimeStamp7StartupEv"]
            pub fn TimeStamp_Startup();
            #[link_name = "\u{1}_ZN7mozilla9TimeStamp8ShutdownEv"]
            pub fn TimeStamp_Shutdown();
        }
    }
    pub mod js {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ThreadType {
            THREAD_TYPE_NONE = 0,
            THREAD_TYPE_MAIN = 1,
            THREAD_TYPE_WASM_COMPILE_TIER1 = 2,
            THREAD_TYPE_WASM_COMPILE_TIER2 = 3,
            THREAD_TYPE_ION = 4,
            THREAD_TYPE_COMPRESS = 5,
            THREAD_TYPE_GCPARALLEL = 6,
            THREAD_TYPE_PROMISE_TASK = 7,
            THREAD_TYPE_ION_FREE = 8,
            THREAD_TYPE_WASM_GENERATOR_TIER2 = 9,
            THREAD_TYPE_WORKER = 10,
            THREAD_TYPE_DELAZIFY = 11,
            THREAD_TYPE_DELAZIFY_FREE = 12,
            THREAD_TYPE_MAX = 13,
        }
        pub mod oom {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct FailureSimulator {
                pub kind_: root::js::oom::FailureSimulator_Kind,
                pub targetThread_: u32,
                pub maxChecks_: u64,
                pub counter_: u64,
                pub failAlways_: bool,
                pub inUnsafeRegion_: bool,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FailureSimulator_Kind {
                Nothing = 0,
                OOM = 1,
                StackOOM = 2,
                Interrupt = 3,
            }
            impl FailureSimulator {
                #[inline]
                pub unsafe fn simulateFailureAfter(
                    &mut self,
                    kind: root::js::oom::FailureSimulator_Kind,
                    checks: u64,
                    thread: u32,
                    always: bool,
                ) {
                    FailureSimulator_simulateFailureAfter(
                        self,
                        kind,
                        checks,
                        thread,
                        always,
                    )
                }
                #[inline]
                pub unsafe fn reset(&mut self) {
                    FailureSimulator_reset(self)
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2js3oomL21FirstThreadTypeToTestE"]
                pub static FirstThreadTypeToTest: root::js::ThreadType;
                #[link_name = "\u{1}_ZN2js3oomL20LastThreadTypeToTestE"]
                pub static LastThreadTypeToTest: root::js::ThreadType;
                #[link_name = "\u{1}_ZN2js3oom14InitThreadTypeEv"]
                pub fn InitThreadType() -> bool;
                #[link_name = "\u{1}_ZN2js3oom13SetThreadTypeENS_10ThreadTypeE"]
                pub fn SetThreadType(arg1: root::js::ThreadType);
                #[link_name = "\u{1}_ZN2js3oom13GetThreadTypeEv"]
                pub fn GetThreadType() -> u32;
                #[link_name = "\u{1}_ZN2js3oom16FailureSimulator20simulateFailureAfterENS1_4KindEyjb"]
                pub fn FailureSimulator_simulateFailureAfter(
                    this: *mut root::js::oom::FailureSimulator,
                    kind: root::js::oom::FailureSimulator_Kind,
                    checks: u64,
                    thread: u32,
                    always: bool,
                );
                #[link_name = "\u{1}_ZN2js3oom16FailureSimulator5resetEv"]
                pub fn FailureSimulator_reset(
                    this: *mut root::js::oom::FailureSimulator,
                );
                #[link_name = "\u{1}_ZN2js3oom9simulatorE"]
                pub static mut simulator: root::js::oom::FailureSimulator;
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoEnterOOMUnsafeRegion {
            pub oomEnabled_: bool,
        }
        pub type AutoEnterOOMUnsafeRegion_AnnotateOOMAllocationSizeCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: usize),
        >;
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct TypeIsGCThing {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UniqueSelector {
                pub _address: u8,
            }
            /** UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be
 transferred out of a UniquePtr through explicit action, but otherwise the
 resource is destroyed when the UniquePtr is destroyed.

 UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr
 in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr
 obviously *can't* copy ownership of its singly-owned resource.  So what
 happens if you try to copy one?  Bizarrely, ownership is implicitly
 *transferred*, preserving single ownership but breaking code that assumes a
 copy of an object is identical to the original.  (This is why auto_ptr is
 prohibited in STL containers.)

 UniquePtr solves this problem by being *movable* rather than copyable.
 Instead of passing a |UniquePtr u| directly to the constructor or assignment
 operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*
 ownership out of |u|, into the target of the construction/assignment.  After
 the transfer completes, |u| contains |nullptr| and may be safely destroyed.
 This preserves single ownership but also allows UniquePtr to be moved by
 algorithms that have been made move-safe.  (Note: if |u| is instead a
 temporary expression, don't use |Move()|: just pass the expression, because
 it's already move-ready.  For more information see Move.h.)

 UniquePtr is also better than std::auto_ptr in that the deletion operation is
 customizable.  An optional second template parameter specifies a class that
 (through its operator()(T*)) implements the desired deletion policy.  If no
 policy is specified, mozilla::DefaultDelete<T> is used -- which will either
 |delete| or |delete[]| the resource, depending whether the resource is an
 array.  Custom deletion policies ideally should be empty classes (no member
 fields, no member fields in base classes, no virtual methods/inheritance),
 because then UniquePtr can be just as efficient as a raw pointer.

 Use of UniquePtr proceeds like so:

   UniquePtr<int> g1; // initializes to nullptr
   g1.reset(new int); // switch resources using reset()
   g1 = nullptr; // clears g1, deletes the int

   UniquePtr<int> g2(new int); // owns that int
   int* p = g2.release(); // g2 leaks its int -- still requires deletion
   delete p; // now freed

   struct S { int x; S(int x) : x(x) {} };
   UniquePtr<S> g3, g4(new S(5));
   g3 = std::move(g4); // g3 owns the S, g4 cleared
   S* p = g3.get(); // g3 still owns |p|
   assert(g3->x == 5); // operator-> works (if .get() != nullptr)
   assert((*g3).x == 5); // also operator* (again, if not cleared)
   std::swap(g3, g4); // g4 now owns the S, g3 cleared
   g3.swap(g4);  // g3 now owns the S, g4 cleared
   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared
   g5.reset(); // deletes the S, g5 cleared

   struct FreePolicy { void operator()(void* p) { free(p); } };
   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));
   int* ptr = g6.get();
   g6 = nullptr; // calls free(ptr)

 Now, carefully note a few things you *can't* do:

   UniquePtr<int> b1;
   b1 = new int; // BAD: can only assign another UniquePtr
   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()

   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr
   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr

 (Note that changing a UniquePtr to store a direct |new| expression is
 permitted, but usually you should use MakeUnique, defined at the end of this
 header.)

 A few miscellaneous notes:

 UniquePtr, when not instantiated for an array type, can be move-constructed
 and move-assigned, not only from itself but from "derived" UniquePtr<U, E>
 instantiations where U converts to T and E converts to D.  If you want to use
 this, you're going to have to specify a deletion policy for both UniquePtr
 instantations, and T pretty much has to have a virtual destructor.  In other
 words, this doesn't work:

   struct Base { virtual ~Base() {} };
   struct Derived : Base {};

   UniquePtr<Base> b1;
   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert
   UniquePtr<Derived> d1(std::move(b));

   UniquePtr<Base> b2;
   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay

 UniquePtr is specialized for array types.  Specializing with an array type
 creates a smart-pointer version of that array -- not a pointer to such an
 array.

   UniquePtr<int[]> arr(new int[5]);
   arr[0] = 4;

 What else is different?  Deletion of course uses |delete[]|.  An operator[]
 is provided.  Functionality that doesn't make sense for arrays is removed.
 The constructors and mutating methods only accept array pointers (not T*, U*
 that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.

 It's perfectly okay for a function to return a UniquePtr. This transfers
 the UniquePtr's sole ownership of the data, to the fresh UniquePtr created
 in the calling function, that will then solely own that data. Such functions
 can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where
 |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.

 UniquePtr will commonly be a member of a class, with lifetime equivalent to
 that of that class.  If you want to expose the related resource, you could
 expose a raw pointer via |get()|, but ownership of a raw pointer is
 inherently unclear.  So it's better to expose a |const UniquePtr&| instead.
 This prohibits mutation but still allows use of |get()| when needed (but
 operator-> is preferred).  Of course, you can only use this smart pointer as
 long as the enclosing class instance remains live -- no different than if you
 exposed the |get()| raw pointer.

 To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|
 argument.  To specify an inout parameter (where the method may or may not
 take ownership of the resource, or reset it), or to specify an out parameter
 (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|
 argument.  To unconditionally transfer ownership of a UniquePtr
 into a method, use a |UniquePtr| argument.  To conditionally transfer
 ownership of a resource into a method, should the method want it, use a
 |UniquePtr&&| argument.*/
            pub type UniqueSelector_SingleObject = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct PtrBarrierMethodsBase {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyReservedSlots {
                pub slots: [root::JS::Value; 1usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyValueArray {
                pub expandoSlot: root::JS::Value,
                pub privateSlot: root::JS::Value,
                pub reservedSlots: root::js::detail::ProxyReservedSlots,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ProxyDataLayout {
                pub reservedSlots: *mut root::js::detail::ProxyReservedSlots,
                pub handler: *const root::js::BaseProxyHandler,
            }
            pub const ProxyDataOffset: u32 = 8;
            pub const TypedArrayLengthSlot: usize = 1;
            pub const TypedArrayDataSlot: usize = 3;
            extern "C" {
                #[link_name = "\u{1}_ZN2js6detail15SetValueInProxyEPN2JS5ValueERKS2_"]
                pub fn SetValueInProxy(
                    slot: *mut root::JS::Value,
                    value: *const root::JS::Value,
                );
                #[link_name = "\u{1}_ZN2js6detail12IsWindowSlowEP8JSObject"]
                pub fn IsWindowSlow(obj: *mut root::JSObject) -> bool;
                #[link_name = "\u{1}_ZN2js6detail25ToWindowProxyIfWindowSlowEP8JSObject"]
                pub fn ToWindowProxyIfWindowSlow(
                    obj: *mut root::JSObject,
                ) -> *mut root::JSObject;
            }
        }
        pub type Vector = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseScript {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BaseShape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GetterSetter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropMap {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExpShared {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Shape {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Scope {
            _unused: [u8; 0],
        }
        pub mod jit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct JitCode {
                _unused: [u8; 0],
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InlinableNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum TrampolineNative {
                __bindgen_cannot_repr_c_on_empty_enum = 0,
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct FrontendContext {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AllocFunction {
            Malloc = 0,
            Calloc = 1,
            Realloc = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllocPolicyBase {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SystemAllocPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TempAllocPolicy {
            pub context_bits_: usize,
        }
        pub const TempAllocPolicy_JsContextTag: usize = 1;
        impl TempAllocPolicy {
            #[inline]
            pub unsafe fn reportAllocOverflow(&self) {
                TempAllocPolicy_reportAllocOverflow(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MallocAllocPolicy {
            pub _address: u8,
        }
        pub type HashNumber = root::mozilla::HashNumber;
        pub const kHashNumberBits: u32 = 32;
        pub type DefaultHasher = root::mozilla::DefaultHasher;
        pub type PointerHasher = root::mozilla::PointerHasher;
        pub type HashSet = u8;
        pub type HashMap = u8;
        pub mod gc {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Cell {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Arena {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredChunk {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StoreBuffer {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct TenuredCell {
                _unused: [u8; 0],
            }
            pub const ArenaShift: usize = 12;
            pub const ArenaSize: usize = 4096;
            pub const ArenaMask: usize = 4095;
            pub const PageShift: usize = 12;
            pub const PageSize: usize = 4096;
            pub const ArenasPerPage: usize = 1;
            pub const ChunkShift: usize = 20;
            pub const ChunkSize: usize = 1048576;
            pub const ChunkMask: usize = 1048575;
            pub const CellAlignShift: usize = 3;
            pub const CellAlignBytes: usize = 8;
            pub const CellAlignMask: usize = 7;
            pub const CellBytesPerMarkBit: usize = 8;
            pub const MarkBitsPerCell: usize = 2;
            pub const MinCellSize: usize = 16;
            pub const ArenaBitmapBits: usize = 512;
            pub const ArenaBitmapBytes: usize = 64;
            pub const ArenaBitmapWords: usize = 16;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ChunkKind {
                Invalid = 0,
                TenuredHeap = 1,
                NurseryToSpace = 2,
                NurseryFromSpace = 3,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct ChunkBase {
                pub storeBuffer: *mut root::js::gc::StoreBuffer,
                pub runtime: *mut root::JSRuntime,
                pub kind: root::js::gc::ChunkKind,
                pub nurseryChunkIndex: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct TenuredChunkInfo {
                pub next: *mut root::js::gc::TenuredChunk,
                pub prev: *mut root::js::gc::TenuredChunk,
                pub numArenasFree: u32,
                pub numArenasFreeCommitted: u32,
            }
            pub const BitsPerPageWithHeaders: usize = 33282;
            pub const ChunkBitsAvailable: usize = 8388384;
            pub const PagesPerChunk: usize = 252;
            pub const ArenasPerChunk: usize = 252;
            pub const FreeCommittedBits: usize = 252;
            pub const DecommitBits: usize = 252;
            pub const BitsPerArenaWithHeaders: usize = 33282;
            pub const CalculatedChunkSizeRequired: usize = 1048412;
            pub const CalculatedChunkPadSize: usize = 164;
            /** Atomic<T> implementation for integral types.

 In addition to atomic store and load operations, compound assignment and
 increment/decrement operators are implemented which perform the
 corresponding read-modify-write operation atomically.  Finally, an atomic
 swap method is provided.*/
            pub type MarkBitmapWord = u32;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ColorBit {
                BlackBit = 0,
                GrayOrBlackBit = 1,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MarkColor {
                Gray = 1,
                Black = 2,
            }
            #[repr(C)]
            #[repr(align(64))]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct MarkBitmap {
                pub bitmap: [root::js::gc::MarkBitmapWord; 4032usize],
            }
            pub const MarkBitmap_WordCount: usize = 4032;
            /** An object like std::bitset but which provides access to the underlying
 storage.

 The limited API is due to expedience only; feel free to flesh out any
 std::bitset-like members.*/
            pub type ChunkPageBitmap = [u32; 8usize];
            /** An object like std::bitset but which provides access to the underlying
 storage.

 The limited API is due to expedience only; feel free to flesh out any
 std::bitset-like members.*/
            pub type ChunkArenaBitmap = [u32; 8usize];
            #[repr(C)]
            #[repr(align(64))]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct TenuredChunkBase {
                pub _base: root::js::gc::ChunkBase,
                pub info: root::js::gc::TenuredChunkInfo,
                pub __bindgen_padding_0: [u64; 4usize],
                pub markBits: root::js::gc::MarkBitmap,
                pub freeCommittedArenas: root::js::gc::ChunkArenaBitmap,
                pub decommittedPages: root::js::gc::ChunkPageBitmap,
            }
            impl TenuredChunkBase {
                #[inline]
                pub unsafe fn initAsDecommitted(&mut self) {
                    TenuredChunkBase_initAsDecommitted(self)
                }
            }
            pub const ArenaCellIndexBytes: usize = 8;
            pub const MaxArenaCellIndex: usize = 512;
            pub const MarkBitmapWordBits: usize = 32;
            pub const FirstArenaAdjustmentBits: usize = 2048;
            pub const FirstArenaAdjustmentWords: usize = 64;
            pub const ChunkStoreBufferOffset: usize = 0;
            pub const ChunkMarkBitmapOffset: usize = 64;
            pub const ArenaZoneOffset: usize = 8;
            pub const ArenaHeaderSize: usize = 24;
            pub const CellFlagBitsReservedForGC: usize = 3;
            pub const JSClassAlignBytes: usize = 8;
            pub mod detail {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}_ZN2js2gc6detailL16GetCellChunkBaseEPKNS0_4CellE"]
                    pub fn GetCellChunkBase(
                        cell: *const root::js::gc::Cell,
                    ) -> *mut root::js::gc::ChunkBase;
                    #[link_name = "\u{1}_ZN2js2gc6detailL16GetCellChunkBaseEPKNS0_11TenuredCellE"]
                    pub fn GetCellChunkBase1(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> *mut root::js::gc::TenuredChunkBase;
                    #[link_name = "\u{1}_ZN2js2gc6detailL21GetTenuredGCThingZoneEPKv"]
                    pub fn GetTenuredGCThingZone(
                        ptr: *const ::std::os::raw::c_void,
                    ) -> *mut root::JS::Zone;
                    #[link_name = "\u{1}_ZN2js2gc6detailL24TenuredCellIsMarkedBlackEPKNS0_11TenuredCellE"]
                    pub fn TenuredCellIsMarkedBlack(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detailL24NonBlackCellIsMarkedGrayEPKNS0_11TenuredCellE"]
                    pub fn NonBlackCellIsMarkedGray(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detailL23TenuredCellIsMarkedGrayEPKNS0_11TenuredCellE"]
                    pub fn TenuredCellIsMarkedGray(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detailL16CellIsMarkedGrayEPKNS0_4CellE"]
                    pub fn CellIsMarkedGray(cell: *const root::js::gc::Cell) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detail16CanCheckGrayBitsEPKNS0_11TenuredCellE"]
                    pub fn CanCheckGrayBits(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detail23CellIsMarkedGrayIfKnownEPKNS0_11TenuredCellE"]
                    pub fn CellIsMarkedGrayIfKnown(
                        cell: *const root::js::gc::TenuredCell,
                    ) -> bool;
                    #[link_name = "\u{1}_ZN2js2gc6detail19AssertCellIsNotGrayEPKNS0_4CellE"]
                    pub fn AssertCellIsNotGray(cell: *const root::js::gc::Cell);
                    #[link_name = "\u{1}_ZN2js2gc6detail19ObjectIsMarkedBlackEPK8JSObject"]
                    pub fn ObjectIsMarkedBlack(obj: *const root::JSObject) -> bool;
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GCRuntime {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct SharedMemoryUse {
                pub count: usize,
                pub nbytes: usize,
                pub use_: root::js::MemoryUse,
            }
            pub type SharedMemoryMap = u8;
            extern "C" {
                #[link_name = "\u{1}_ZN2js2gc16TenuredChunkBase17initAsDecommittedEv"]
                pub fn TenuredChunkBase_initAsDecommitted(
                    this: *mut root::js::gc::TenuredChunkBase,
                );
                #[link_name = "\u{1}_ZN2js2gc20AssertGCThingHasTypeEPNS0_4CellEN2JS9TraceKindE"]
                pub fn AssertGCThingHasType(
                    cell: *mut root::js::gc::Cell,
                    kind: root::JS::TraceKind,
                );
                #[link_name = "\u{1}_ZN2js2gc29PerformIncrementalReadBarrierEN2JS9GCCellPtrE"]
                pub fn PerformIncrementalReadBarrier(thing: root::JS::GCCellPtr);
                #[link_name = "\u{1}_ZN2js2gcL23ExposeGCThingToActiveJSEN2JS9GCCellPtrE"]
                pub fn ExposeGCThingToActiveJS(thing: root::JS::GCCellPtr);
                #[link_name = "\u{1}_ZN2js2gcL22IncrementalReadBarrierEN2JS9GCCellPtrE"]
                pub fn IncrementalReadBarrier(thing: root::JS::GCCellPtr);
                #[link_name = "\u{1}_ZN2js2gcL25EdgeNeedsSweepUnbarrieredEPP8JSObject"]
                pub fn EdgeNeedsSweepUnbarriered(objp: *mut *mut root::JSObject) -> bool;
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6BigIntEPKc"]
                pub fn TraceExternalEdge(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::BigInt,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPPN2JS6SymbolEPKc"]
                pub fn TraceExternalEdge1(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JS::Symbol,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP6JSAtomPKc"]
                pub fn TraceExternalEdge2(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSAtom,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP10JSFunctionPKc"]
                pub fn TraceExternalEdge3(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSFunction,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP14JSLinearStringPKc"]
                pub fn TraceExternalEdge4(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSLinearString,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSObjectPKc"]
                pub fn TraceExternalEdge5(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSObject,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSScriptPKc"]
                pub fn TraceExternalEdge6(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSScript,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPP8JSStringPKc"]
                pub fn TraceExternalEdge7(
                    trc: *mut root::JSTracer,
                    thingp: *mut *mut root::JSString,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS5ValueEPKc"]
                pub fn TraceExternalEdge8(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::Value,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc17TraceExternalEdgeEP8JSTracerPN2JS11PropertyKeyEPKc"]
                pub fn TraceExternalEdge9(
                    trc: *mut root::JSTracer,
                    thingp: *mut root::JS::PropertyKey,
                    name: *const ::std::os::raw::c_char,
                );
                #[link_name = "\u{1}_ZN2js2gc10TraceRealmEP8JSTracerPN2JS5RealmEPKc"]
                pub fn TraceRealm(
                    trc: *mut root::JSTracer,
                    realm: *mut root::JS::Realm,
                    name: *const ::std::os::raw::c_char,
                );
                /** Create an object providing access to the garbage collector's internal notion
 of the current state of memory (both GC heap memory and GCthing-controlled
 malloc memory.*/
                #[link_name = "\u{1}_ZN2js2gc19NewMemoryInfoObjectEP9JSContext"]
                pub fn NewMemoryInfoObject(
                    cx: *mut root::JSContext,
                ) -> *mut root::JSObject;
                #[link_name = "\u{1}_ZN2js2gc12GetGCContextEP9JSContext"]
                pub fn GetGCContext(
                    cx: *mut root::JSContext,
                ) -> *mut root::JS::GCContext;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NurseryDecommitTask {
            _unused: [u8; 0],
        }
        pub const TypicalCacheLineSize: usize = 64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GenericTracerImpl {
            pub _base: root::JSTracer,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AbstractGeneratorObject {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SavedFrame {
            _unused: [u8; 0],
        }
        pub mod wasm {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AnyRef {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfilingStackFrame {
            pub label_: u32,
            pub dynamicString_: u32,
            pub spOrScript: u32,
            pub realmID_: u64,
            pub pcOffsetIfJS_: u32,
            pub flagsAndCategoryPair_: u32,
        }
        impl root::js::ProfilingStackFrame_Flags {
            pub const FLAGS_BITCOUNT: root::js::ProfilingStackFrame_Flags = ProfilingStackFrame_Flags::STRING_TEMPLATE_METHOD;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingStackFrame_Flags {
            IS_LABEL_FRAME = 1,
            IS_SP_MARKER_FRAME = 2,
            IS_JS_FRAME = 4,
            JS_OSR = 8,
            STRING_TEMPLATE_METHOD = 16,
            STRING_TEMPLATE_GETTER = 32,
            STRING_TEMPLATE_SETTER = 64,
            RELEVANT_FOR_JS = 128,
            LABEL_DETERMINED_BY_CATEGORY_PAIR = 256,
            NONSENSITIVE = 512,
            IS_BLINTERP_FRAME = 1024,
            FLAGS_MASK = 65535,
        }
        pub const ProfilingStackFrame_NullPCOffset: i32 = -1;
        impl ProfilingStackFrame {
            #[inline]
            pub unsafe fn script(&self) -> *mut root::JSScript {
                ProfilingStackFrame_script(self)
            }
            #[inline]
            pub unsafe fn function(&self) -> *mut root::JSFunction {
                ProfilingStackFrame_function(self)
            }
            #[inline]
            pub unsafe fn pc(&self) -> *mut root::jsbytecode {
                ProfilingStackFrame_pc(self)
            }
            #[inline]
            pub unsafe fn setPC(&mut self, pc: *mut root::jsbytecode) {
                ProfilingStackFrame_setPC(self, pc)
            }
            #[inline]
            pub unsafe fn trace(&mut self, trc: *mut root::JSTracer) {
                ProfilingStackFrame_trace(self, trc)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoGeckoProfilerEntry {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerEntryMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GeckoProfilerBaselineOSRMarker {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GeckoProfilerThread {
            pub profilingStack_: *mut root::ProfilingStack,
            pub profilingStackIfEnabled_: *mut root::ProfilingStack,
        }
        impl GeckoProfilerThread {
            #[inline]
            pub unsafe fn setProfilingStack(
                &mut self,
                profilingStack: *mut root::ProfilingStack,
                enabled: bool,
            ) {
                GeckoProfilerThread_setProfilingStack(self, profilingStack, enabled)
            }
            #[inline]
            pub unsafe fn trace(&mut self, trc: *mut root::JSTracer) {
                GeckoProfilerThread_trace(self, trc)
            }
            #[inline]
            pub unsafe fn enter(
                &mut self,
                cx: *mut root::JSContext,
                script: *mut root::JSScript,
            ) -> bool {
                GeckoProfilerThread_enter(self, cx, script)
            }
            #[inline]
            pub unsafe fn exit(
                &mut self,
                cx: *mut root::JSContext,
                script: *mut root::JSScript,
            ) {
                GeckoProfilerThread_exit(self, cx, script)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                GeckoProfilerThread_GeckoProfilerThread(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackFormat {
            SpiderMonkey = 0,
            V8 = 1,
            Default = 2,
        }
        pub type UniquePtr = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Nursery {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BarrierMethods {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableWrappedPtrOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HeapOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IsHeapConstructibleType {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StableCellHasher {
            pub _address: u8,
        }
        pub type StableCellHasher_Key<T> = T;
        pub type StableCellHasher_Lookup<T> = T;
        #[repr(C)]
        pub struct VirtualTraceable__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct VirtualTraceable {
            pub vtable_: *const VirtualTraceable__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StackRootedBase {
            pub stack: *mut *mut root::js::StackRootedBase,
            pub prev: *mut root::js::StackRootedBase,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct PersistentRootedBase {
            pub _base: root::mozilla::LinkedListElement,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct StackRootedTraceableBase {
            pub _base: root::js::StackRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct PersistentRootedTraceableBase {
            pub _base: root::js::PersistentRootedBase,
            pub _base_1: root::js::VirtualTraceable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedRootedGCThingBase<Base> {
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedRootedTraceableBase<Base> {
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedTraceableTraits {
            pub _address: u8,
        }
        pub type RootedTraceableTraits_StackBase = root::js::TypedRootedTraceableBase<
            root::js::StackRootedTraceableBase,
        >;
        pub type RootedTraceableTraits_PersistentBase = root::js::TypedRootedTraceableBase<
            root::js::PersistentRootedTraceableBase,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootedGCThingTraits {
            pub _address: u8,
        }
        pub type RootedGCThingTraits_StackBase = root::js::TypedRootedGCThingBase<
            root::js::StackRootedBase,
        >;
        pub type RootedGCThingTraits_PersistentBase = root::js::TypedRootedGCThingBase<
            root::js::PersistentRootedBase,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GenericPrinter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct JSONPrinter {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableValueOperations {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PropertyResult {
            _unused: [u8; 0],
        }
        pub type LookupPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                objp: root::JS::MutableHandleObject,
                propp: *mut root::js::PropertyResult,
            ) -> bool,
        >;
        pub type DefinePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type HasPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                foundp: *mut bool,
            ) -> bool,
        >;
        pub type GetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool,
        >;
        pub type SetPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        pub type GetOwnPropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            ) -> bool,
        >;
        pub type DeletePropertyOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool,
        >;
        #[repr(C)]
        pub struct ElementAdder {
            pub resObj_: root::JS::RootedObject,
            pub vp_: *mut root::JS::Value,
            pub index_: u32,
            pub length_: u32,
            pub getBehavior_: root::js::ElementAdder_GetBehavior,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ElementAdder_GetBehavior {
            CheckHasElemPreserveHoles = 0,
            GetElement = 1,
        }
        impl ElementAdder {
            #[inline]
            pub unsafe fn append(
                &mut self,
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> bool {
                ElementAdder_append(self, cx, v)
            }
            #[inline]
            pub unsafe fn appendHole(&mut self) {
                ElementAdder_appendHole(self)
            }
        }
        pub type GetElementsOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool,
        >;
        /// Callback for the creation of constructor and prototype objects.
        pub type ClassObjectCreationOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
            ) -> *mut root::JSObject,
        >;
        /** Callback for custom post-processing after class initialization via
 ClassSpec.*/
        pub type FinishClassInitOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                proto: root::JS::HandleObject,
            ) -> bool,
        >;
        pub const JSCLASS_CACHED_PROTO_WIDTH: usize = 7;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassSpec {
            pub createConstructor: root::js::ClassObjectCreationOp,
            pub createPrototype: root::js::ClassObjectCreationOp,
            pub constructorFunctions: *const root::JSFunctionSpec,
            pub constructorProperties: *const root::JSPropertySpec,
            pub prototypeFunctions: *const root::JSFunctionSpec,
            pub prototypeProperties: *const root::JSPropertySpec,
            pub finishInit: root::js::FinishClassInitOp,
            pub flags: usize,
        }
        pub const ClassSpec_ProtoKeyWidth: usize = 7;
        pub const ClassSpec_ProtoKeyMask: usize = 127;
        pub const ClassSpec_DontDefineConstructor: usize = 128;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassExtension {
            /** Optional hook called when an object is moved by generational or
 compacting GC.

 There may exist weak pointers to an object that are not traced through
 when the normal trace APIs are used, for example objects in the wrapper
 cache. This hook allows these pointers to be updated.

 Note that this hook can be called before JS_NewObject() returns if a GC
 is triggered during construction of the object. This can happen for
 global objects for example.

 The function should return the difference between nursery bytes used and
 tenured bytes used, which may be nonzero e.g. if some nursery-allocated
 data beyond the actual GC thing is moved into malloced memory.

 This is used to compute the nursery promotion rate.*/
            pub objectMovedOp: root::JSObjectMovedOp,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectOps {
            pub lookupProperty: root::js::LookupPropertyOp,
            pub defineProperty: root::js::DefinePropertyOp,
            pub hasProperty: root::js::HasPropertyOp,
            pub getProperty: root::js::GetPropertyOp,
            pub setProperty: root::js::SetPropertyOp,
            pub getOwnPropertyDescriptor: root::js::GetOwnPropertyOp,
            pub deleteProperty: root::js::DeletePropertyOp,
            pub getElements: root::js::GetElementsOp,
            pub funToString: root::JSFunToStringOp,
        }
        #[repr(i32)]
        /** Enumeration describing possible values of the [[Class]] internal property
 value of objects.*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ESClass {
            Object = 0,
            Array = 1,
            Number = 2,
            String = 3,
            Boolean = 4,
            RegExp = 5,
            ArrayBuffer = 6,
            SharedArrayBuffer = 7,
            Date = 8,
            Set = 9,
            Map = 10,
            Promise = 11,
            MapIterator = 12,
            SetIterator = 13,
            Arguments = 14,
            Error = 15,
            BigInt = 16,
            Function = 17,
            /// None of the above.
            Other = 18,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RefCounted {
            pub mRefCnt: root::MozRefCountType,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AtomicRefCounted {
            pub mRefCnt: u32,
        }
        /** This hash policy avoids flattening ropes (which perturbs the site being
 measured and requires a JSContext) at the expense of doing a FULL ROPE COPY
 on every hash and match! Beware.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct InefficientNonFlatteningStringHashPolicy {
            pub _address: u8,
        }
        pub type InefficientNonFlatteningStringHashPolicy_Lookup = *mut root::JSString;
        impl InefficientNonFlatteningStringHashPolicy {
            #[inline]
            pub unsafe fn hash(
                l: *const root::js::InefficientNonFlatteningStringHashPolicy_Lookup,
            ) -> root::js::HashNumber {
                InefficientNonFlatteningStringHashPolicy_hash(l)
            }
            #[inline]
            pub unsafe fn match_(
                k: *const *const root::JSString,
                l: *const root::js::InefficientNonFlatteningStringHashPolicy_Lookup,
            ) -> bool {
                InefficientNonFlatteningStringHashPolicy_match(k, l)
            }
        }
        #[repr(C)]
        pub struct BaseProxyHandler__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BaseProxyHandler {
            pub vtable_: *const BaseProxyHandler__bindgen_vtable,
            pub mFamily: *const ::std::os::raw::c_void,
            pub mHasPrototype: bool,
            pub mHasSecurityPolicy: bool,
        }
        pub type BaseProxyHandler_Action = u32;
        pub const BaseProxyHandler_NONE: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::NONE;
        pub const BaseProxyHandler_GET: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::GET;
        pub const BaseProxyHandler_SET: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::SET;
        pub const BaseProxyHandler_CALL: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::CALL;
        pub const BaseProxyHandler_ENUMERATE: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::ENUMERATE;
        pub const BaseProxyHandler_GET_PROPERTY_DESCRIPTOR: root::js::BaseProxyHandler__bindgen_ty_1 = BaseProxyHandler__bindgen_ty_1::GET_PROPERTY_DESCRIPTOR;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum BaseProxyHandler__bindgen_ty_1 {
            NONE = 0,
            GET = 1,
            SET = 2,
            CALL = 4,
            ENUMERATE = 8,
            GET_PROPERTY_DESCRIPTOR = 16,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NurseryAllocableProxyHandler {
            pub _base: root::js::BaseProxyHandler,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProxyOptions {
            pub lazyProto_: bool,
            pub clasp_: *const root::JSClass,
        }
        #[repr(C)]
        pub struct AutoEnterPolicy__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoEnterPolicy {
            pub vtable_: *const AutoEnterPolicy__bindgen_vtable,
            pub allow: bool,
            pub rv: bool,
            pub context: *mut root::JSContext,
            pub enteredProxy: root::mozilla::Maybe,
            pub enteredId: root::mozilla::Maybe,
            pub enteredAction: root::js::AutoEnterPolicy_Action,
            pub prev: *mut root::js::AutoEnterPolicy,
        }
        pub type AutoEnterPolicy_Action = root::js::BaseProxyHandler_Action;
        impl AutoEnterPolicy {
            #[inline]
            pub unsafe fn reportErrorIfExceptionIsNotPending(
                &mut self,
                cx: *mut root::JSContext,
                id: root::JS::HandleId,
            ) {
                AutoEnterPolicy_reportErrorIfExceptionIsNotPending(self, cx, id)
            }
            #[inline]
            pub unsafe fn recordEnter(
                &mut self,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                act: root::js::AutoEnterPolicy_Action,
            ) {
                AutoEnterPolicy_recordEnter(self, cx, proxy, id, act)
            }
            #[inline]
            pub unsafe fn recordLeave(&mut self) {
                AutoEnterPolicy_recordLeave(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoWaivePolicy {
            pub _base: root::js::AutoEnterPolicy,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SharedArrayRawBuffer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SharedArrayRawBufferRefs {
            pub refs_: [u32; 5usize],
        }
        impl SharedArrayRawBufferRefs {
            #[inline]
            #[must_use]
            pub unsafe fn acquire(
                &mut self,
                cx: *mut root::JSContext,
                rawbuf: *mut root::js::SharedArrayRawBuffer,
            ) -> bool {
                SharedArrayRawBufferRefs_acquire(self, cx, rawbuf)
            }
            #[inline]
            #[must_use]
            pub unsafe fn acquireAll(
                &mut self,
                cx: *mut root::JSContext,
                that: *const root::js::SharedArrayRawBufferRefs,
            ) -> bool {
                SharedArrayRawBufferRefs_acquireAll(self, cx, that)
            }
            #[inline]
            pub unsafe fn takeOwnership(
                &mut self,
                arg1: *mut root::js::SharedArrayRawBufferRefs,
            ) {
                SharedArrayRawBufferRefs_takeOwnership(self, arg1)
            }
            #[inline]
            pub unsafe fn releaseAll(&mut self) {
                SharedArrayRawBufferRefs_releaseAll(self)
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SharedArrayRawBufferRefs_SharedArrayRawBufferRefs_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferIterator {
            pub _address: u8,
        }
        pub mod frontend {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationStencil {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationGCOutput {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CompilationInput {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct PreallocatedCompilationGCOutput {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        pub struct WrapperOptions {
            pub _base: root::js::ProxyOptions,
            pub proto_: root::mozilla::Maybe,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ForwardingProxyHandler {
            pub _base: root::js::BaseProxyHandler,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Wrapper {
            pub _base: root::js::ForwardingProxyHandler,
            pub mFlags: ::std::os::raw::c_uint,
        }
        impl root::js::Wrapper_Flags {
            pub const LAST_USED_FLAG: root::js::Wrapper_Flags = Wrapper_Flags::CROSS_COMPARTMENT;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Wrapper_Flags {
            CROSS_COMPARTMENT = 1,
        }
        impl Wrapper {
            #[inline]
            pub unsafe fn New(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                handler: *const root::js::Wrapper,
                options: *const root::js::WrapperOptions,
            ) -> *mut root::JSObject {
                Wrapper_New(cx, obj, handler, options)
            }
            #[inline]
            pub unsafe fn Renew(
                existing: *mut root::JSObject,
                obj: *mut root::JSObject,
                handler: *const root::js::Wrapper,
            ) -> *mut root::JSObject {
                Wrapper_Renew(existing, obj, handler)
            }
            #[inline]
            pub unsafe fn wrappedObject(
                wrapper: *mut root::JSObject,
            ) -> *mut root::JSObject {
                Wrapper_wrappedObject(wrapper)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CrossCompartmentWrapper {
            pub _base: root::js::Wrapper,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OpaqueCrossCompartmentWrapper {
            pub _base: root::js::CrossCompartmentWrapper,
        }
        #[repr(C)]
        pub struct SecurityWrapper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SecurityWrapper<Base> {
            pub vtable_: *const SecurityWrapper__bindgen_vtable,
            pub _base: Base,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Base>>,
        }
        pub type SecurityWrapper_Permissive<Base> = Base;
        pub type SecurityWrapper_Restrictive<Base> = root::js::SecurityWrapper<Base>;
        pub type CrossCompartmentSecurityWrapper = root::js::SecurityWrapper<
            root::js::CrossCompartmentWrapper,
        >;
        pub type EnableIfABOVType = root::std::enable_if_t;
        pub mod gcstats {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Statistics {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Debugger {
            _unused: [u8; 0],
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorArgumentsType {
            ArgumentsAreUnicode = 0,
            ArgumentsAreASCII = 1,
            ArgumentsAreLatin1 = 2,
            ArgumentsAreUTF8 = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptSource {
            _unused: [u8; 0],
        }
        pub type PreserveWrapperCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::HandleObject,
            ) -> bool,
        >;
        pub type HasReleasedWrapperCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: root::JS::HandleObject) -> bool,
        >;
        #[repr(C)]
        pub struct WeakMapTracer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WeakMapTracer {
            pub vtable_: *const WeakMapTracer__bindgen_vtable,
            pub runtime: *mut root::JSRuntime,
        }
        pub type IterateGCThingCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: root::JS::GCCellPtr,
                arg3: *const root::JS::AutoRequireNoGC,
            ),
        >;
        pub type DOMInstanceClassHasProtoAtDepth = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const root::JSClass,
                arg2: u32,
                arg3: u32,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSDOMCallbacks {
            pub instanceClassMatchesProto: root::js::DOMInstanceClassHasProtoAtDepth,
        }
        pub type DOMCallbacks = root::js::JSDOMCallbacks;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesToWindow {
            NukeWindowReferences = 0,
            DontNukeWindowReferences = 1,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NukeReferencesFromTarget {
            NukeAllReferences = 0,
            NukeIncomingReferences = 1,
        }
        #[repr(C)]
        pub struct CompartmentFilter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompartmentFilter {
            pub vtable_: *const CompartmentFilter__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllCompartments {
            pub _base: root::js::CompartmentFilter,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SingleCompartment {
            pub _base: root::js::CompartmentFilter,
            pub ours: *mut root::JS::Compartment,
        }
        pub const JS_FUNCTION_INTERPRETED_BITS: ::std::os::raw::c_uint = 96;
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer__bindgen_vtable(::std::os::raw::c_void);
        /** PrepareScriptEnvironmentAndInvoke asserts the embedder has registered a
 ScriptEnvironmentPreparer and then it calls the preparer's 'invoke' method
 with the given |closure|, with the assumption that the preparer will set up
 any state necessary to run script in |global|, invoke |closure| with a valid
 JSContext*, report any exceptions thrown from the closure, and return.

 PrepareScriptEnvironmentAndInvoke will report any exceptions that are thrown
 by the closure.  Consumers who want to propagate back whether the closure
 succeeded should do so via members of the closure itself.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptEnvironmentPreparer {
            pub vtable_: *const ScriptEnvironmentPreparer__bindgen_vtable,
        }
        #[repr(C)]
        pub struct ScriptEnvironmentPreparer_Closure__bindgen_vtable(
            ::std::os::raw::c_void,
        );
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptEnvironmentPreparer_Closure {
            pub vtable_: *const ScriptEnvironmentPreparer_Closure__bindgen_vtable,
        }
        #[repr(C)]
        pub struct AllocationMetadataBuilder__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllocationMetadataBuilder {
            pub vtable_: *const AllocationMetadataBuilder__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertNoContentJS {
            pub context_: *mut root::JSContext,
            pub prevAllowContentJS_: bool,
        }
        impl AutoAssertNoContentJS {
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoAssertNoContentJS_AutoAssertNoContentJS(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoAssertNoContentJS_AutoAssertNoContentJS_destructor(self)
            }
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryUse {
            __bindgen_cannot_repr_c_on_empty_enum = 0,
        }
        #[repr(C)]
        pub struct CompartmentTransplantCallback__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompartmentTransplantCallback {
            pub vtable_: *const CompartmentTransplantCallback__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}_ZN2js24AutoEnterOOMUnsafeRegion23annotateOOMSizeCallbackE"]
            pub static mut AutoEnterOOMUnsafeRegion_annotateOOMSizeCallback: u32;
            #[link_name = "\u{1}_ZN2js24AutoEnterOOMUnsafeRegion6owner_E"]
            pub static mut AutoEnterOOMUnsafeRegion_owner_: u32;
            #[link_name = "\u{1}_ZN2js11MallocArenaE"]
            pub static mut MallocArena: root::arena_id_t;
            #[link_name = "\u{1}_ZN2js24ArrayBufferContentsArenaE"]
            pub static mut ArrayBufferContentsArena: root::arena_id_t;
            #[link_name = "\u{1}_ZN2js17StringBufferArenaE"]
            pub static mut StringBufferArena: root::arena_id_t;
            #[link_name = "\u{1}_ZN2js19InitMallocAllocatorEv"]
            pub fn InitMallocAllocator();
            #[link_name = "\u{1}_ZN2js23ShutDownMallocAllocatorEv"]
            pub fn ShutDownMallocAllocator();
            #[link_name = "\u{1}_ZN2js34AssertJSStringBufferInCorrectArenaEPKv"]
            pub fn AssertJSStringBufferInCorrectArena(
                ptr: *const ::std::os::raw::c_void,
            );
            #[link_name = "\u{1}_ZN2js29CurrentThreadCanAccessRuntimeEPK9JSRuntime"]
            pub fn CurrentThreadCanAccessRuntime(rt: *const root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2js25CurrentThreadIsMainThreadEv"]
            pub fn CurrentThreadIsMainThread() -> bool;
            #[link_name = "\u{1}_ZN2js27CurrentThreadIsPerformingGCEv"]
            pub fn CurrentThreadIsPerformingGC() -> bool;
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEP9JSContext"]
            pub fn ReportOutOfMemory(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2js17ReportOutOfMemoryEPNS_15FrontendContextE"]
            pub fn ReportOutOfMemory1(fc: *mut root::js::FrontendContext);
            #[link_name = "\u{1}_ZN2js22ReportLargeOutOfMemoryEP9JSContext"]
            pub fn ReportLargeOutOfMemory(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZNK2js15TempAllocPolicy19reportAllocOverflowEv"]
            pub fn TempAllocPolicy_reportAllocOverflow(
                this: *const root::js::TempAllocPolicy,
            );
            #[link_name = "\u{1}_ZN2js26CurrentThreadCanAccessZoneEPN2JS4ZoneE"]
            pub fn CurrentThreadCanAccessZone(zone: *mut root::JS::Zone) -> bool;
            #[link_name = "\u{1}_ZN2js32UnsafeTraceManuallyBarrieredEdgeEP8JSTracerPP8JSObjectPKc"]
            pub fn UnsafeTraceManuallyBarrieredEdge(
                trc: *mut root::JSTracer,
                thingp: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2js23RuntimeIsBeingDestroyedEv"]
            pub fn RuntimeIsBeingDestroyed() -> bool;
            #[link_name = "\u{1}_ZNK2js19ProfilingStackFrame6scriptEv"]
            pub fn ProfilingStackFrame_script(
                this: *const root::js::ProfilingStackFrame,
            ) -> *mut root::JSScript;
            #[link_name = "\u{1}_ZNK2js19ProfilingStackFrame8functionEv"]
            pub fn ProfilingStackFrame_function(
                this: *const root::js::ProfilingStackFrame,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZNK2js19ProfilingStackFrame2pcEv"]
            pub fn ProfilingStackFrame_pc(
                this: *const root::js::ProfilingStackFrame,
            ) -> *mut root::jsbytecode;
            #[link_name = "\u{1}_ZN2js19ProfilingStackFrame5setPCEPh"]
            pub fn ProfilingStackFrame_setPC(
                this: *mut root::js::ProfilingStackFrame,
                pc: *mut root::jsbytecode,
            );
            #[link_name = "\u{1}_ZN2js19ProfilingStackFrame5traceEP8JSTracer"]
            pub fn ProfilingStackFrame_trace(
                this: *mut root::js::ProfilingStackFrame,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2js24SetContextProfilingStackEP9JSContextP14ProfilingStack"]
            pub fn SetContextProfilingStack(
                cx: *mut root::JSContext,
                profilingStack: *mut root::ProfilingStack,
            );
            #[link_name = "\u{1}_ZN2js27EnableContextProfilingStackEP9JSContextb"]
            pub fn EnableContextProfilingStack(cx: *mut root::JSContext, enabled: bool);
            #[link_name = "\u{1}_ZN2js35RegisterContextProfilingEventMarkerEP9JSContextPFvPKcS3_E"]
            pub fn RegisterContextProfilingEventMarker(
                cx: *mut root::JSContext,
                fn_: ::std::option::Option<
                    unsafe extern "C" fn(
                        arg1: *const ::std::os::raw::c_char,
                        arg2: *const ::std::os::raw::c_char,
                    ),
                >,
            );
            #[link_name = "\u{1}_ZN2js19GeckoProfilerThread17setProfilingStackEP14ProfilingStackb"]
            pub fn GeckoProfilerThread_setProfilingStack(
                this: *mut root::js::GeckoProfilerThread,
                profilingStack: *mut root::ProfilingStack,
                enabled: bool,
            );
            #[link_name = "\u{1}_ZN2js19GeckoProfilerThread5traceEP8JSTracer"]
            pub fn GeckoProfilerThread_trace(
                this: *mut root::js::GeckoProfilerThread,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2js19GeckoProfilerThread5enterEP9JSContextP8JSScript"]
            pub fn GeckoProfilerThread_enter(
                this: *mut root::js::GeckoProfilerThread,
                cx: *mut root::JSContext,
                script: *mut root::JSScript,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js19GeckoProfilerThread4exitEP9JSContextP8JSScript"]
            pub fn GeckoProfilerThread_exit(
                this: *mut root::js::GeckoProfilerThread,
                cx: *mut root::JSContext,
                script: *mut root::JSScript,
            );
            #[link_name = "\u{1}_ZN2js19GeckoProfilerThreadC1Ev"]
            pub fn GeckoProfilerThread_GeckoProfilerThread(
                this: *mut root::js::GeckoProfilerThread,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2js14SetStackFormatEP9JSContextNS_11StackFormatE"]
            pub fn SetStackFormat(
                cx: *mut root::JSContext,
                format: root::js::StackFormat,
            );
            #[link_name = "\u{1}_ZN2js14GetStackFormatEP9JSContext"]
            pub fn GetStackFormat(cx: *mut root::JSContext) -> root::js::StackFormat;
            #[link_name = "\u{1}_ZN2jsL19PoisonedObjectValueEm"]
            pub fn PoisonedObjectValue(poison: usize) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2js26ReportBadValueTypeAndCrashERKN2JS5ValueE"]
            pub fn ReportBadValueTypeAndCrash(val: *const root::JS::Value) -> !;
            #[link_name = "\u{1}_ZN2js13ToBooleanSlowEN2JS6HandleINS0_5ValueEEE"]
            pub fn ToBooleanSlow(v: root::JS::HandleValue) -> bool;
            #[link_name = "\u{1}_ZN2js12ToNumberSlowEP9JSContextN2JS6HandleINS2_5ValueEEEPd"]
            pub fn ToNumberSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                dp: *mut f64,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js10ToInt8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPa"]
            pub fn ToInt8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i8,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js11ToUint8SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPh"]
            pub fn ToUint8Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u8,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js11ToInt16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPs"]
            pub fn ToInt16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i16,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js11ToInt32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPi"]
            pub fn ToInt32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i32,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12ToUint32SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPj"]
            pub fn ToUint32Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u32,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12ToUint16SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPt"]
            pub fn ToUint16Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u16,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js11ToInt64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPx"]
            pub fn ToInt64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut i64,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12ToUint64SlowEP9JSContextN2JS6HandleINS2_5ValueEEEPy"]
            pub fn ToUint64Slow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                out: *mut u64,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12ToStringSlowEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ToStringSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZN2js12ToObjectSlowEP9JSContextN2JS6HandleINS2_5ValueEEEb"]
            pub fn ToObjectSlow(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
                reportScanStack: bool,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js16FunctionClassPtrE"]
            pub static FunctionClassPtr: *const root::JSClass;
            #[link_name = "\u{1}_ZN2js24FunctionExtendedClassPtrE"]
            pub static FunctionExtendedClassPtr: *const root::JSClass;
            #[link_name = "\u{1}_ZN2js12ElementAdder6appendEP9JSContextN2JS6HandleINS3_5ValueEEE"]
            pub fn ElementAdder_append(
                this: *mut root::js::ElementAdder,
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12ElementAdder10appendHoleEv"]
            pub fn ElementAdder_appendHole(this: *mut root::js::ElementAdder);
            #[link_name = "\u{1}_ZN2js5UnboxEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleINS2_5ValueEEE"]
            pub fn Unbox(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js16HasObjectMovedOpEP8JSObject"]
            pub fn HasObjectMovedOp(obj: *mut root::JSObject) -> bool;
            /** In memory reporting, we have concept of "sundries", line items which are too
 small to be worth reporting individually.  Under some circumstances, a memory
 reporter gets tossed into the sundries bucket if it's smaller than
 MemoryReportingSundriesThreshold() bytes.

 We need to define this value here, rather than in the code which actually
 generates the memory reports, because NotableStringInfo uses this value.*/
            #[link_name = "\u{1}_ZN2js32MemoryReportingSundriesThresholdEv"]
            pub fn MemoryReportingSundriesThreshold() -> usize;
            #[link_name = "\u{1}_ZN2js40InefficientNonFlatteningStringHashPolicy4hashERKP8JSString"]
            pub fn InefficientNonFlatteningStringHashPolicy_hash(
                l: *const root::js::InefficientNonFlatteningStringHashPolicy_Lookup,
            ) -> root::js::HashNumber;
            #[link_name = "\u{1}_ZN2js40InefficientNonFlatteningStringHashPolicy5matchERKPK8JSStringRKPS1_"]
            pub fn InefficientNonFlatteningStringHashPolicy_match(
                k: *const *const root::JSString,
                l: *const root::js::InefficientNonFlatteningStringHashPolicy_Lookup,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler5enterEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEjbPb"]
            pub fn BaseProxyHandler_enter(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                act: root::js::BaseProxyHandler_Action,
                mayThrow: bool,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler12getPrototypeEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleIS6_EE"]
            pub fn BaseProxyHandler_getPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler12setPrototypeEP9JSContextN2JS6HandleIP8JSObjectEES7_RNS3_14ObjectOpResultE"]
            pub fn BaseProxyHandler_setPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler21setImmutablePrototypeEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn BaseProxyHandler_setImmutablePrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler3hasEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn BaseProxyHandler_has(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler3getEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_5ValueEEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIS8_EE"]
            pub fn BaseProxyHandler_get(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler3setEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_5ValueEEESB_RNS3_14ObjectOpResultE"]
            pub fn BaseProxyHandler_set(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler4callEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn BaseProxyHandler_call(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler9constructEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn BaseProxyHandler_construct(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler9enumerateEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn BaseProxyHandler_enumerate(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler6hasOwnEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn BaseProxyHandler_hasOwn(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler28getOwnEnumerablePropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn BaseProxyHandler_getOwnEnumerablePropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler10nativeCallEP9JSContextPFbN2JS6HandleINS3_5ValueEEEEPFbS2_RKNS3_8CallArgsEESB_"]
            pub fn BaseProxyHandler_nativeCall(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                test: root::JS::IsAcceptableThis,
                impl_: root::JS::NativeImpl,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler15getBuiltinClassEP9JSContextN2JS6HandleIP8JSObjectEEPNS_7ESClassE"]
            pub fn BaseProxyHandler_getBuiltinClass(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                cls: *mut root::js::ESClass,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler7isArrayEP9JSContextN2JS6HandleIP8JSObjectEEPNS3_13IsArrayAnswerE"]
            pub fn BaseProxyHandler_isArray(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler9classNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn BaseProxyHandler_className(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler12fun_toStringEP9JSContextN2JS6HandleIP8JSObjectEEb"]
            pub fn BaseProxyHandler_fun_toString(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isToSource: bool,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler15regexp_toSharedEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn BaseProxyHandler_regexp_toShared(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *mut root::js::RegExpShared;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler16boxedValue_unboxEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_5ValueEEE"]
            pub fn BaseProxyHandler_boxedValue_unbox(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler5traceEP8JSTracerP8JSObject"]
            pub fn BaseProxyHandler_trace(
                this: *mut ::std::os::raw::c_void,
                trc: *mut root::JSTracer,
                proxy: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler8finalizeEPN2JS9GCContextEP8JSObject"]
            pub fn BaseProxyHandler_finalize(
                this: *mut ::std::os::raw::c_void,
                gcx: *mut root::JS::GCContext,
                proxy: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler11objectMovedEP8JSObjectS2_"]
            pub fn BaseProxyHandler_objectMoved(
                this: *mut ::std::os::raw::c_void,
                proxy: *mut root::JSObject,
                old: *mut root::JSObject,
            ) -> usize;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler10isCallableEP8JSObject"]
            pub fn BaseProxyHandler_isCallable(
                this: *mut ::std::os::raw::c_void,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler13isConstructorEP8JSObject"]
            pub fn BaseProxyHandler_isConstructor(
                this: *mut ::std::os::raw::c_void,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js16BaseProxyHandler11getElementsEP9JSContextN2JS6HandleIP8JSObjectEEjjPNS_12ElementAdderE"]
            pub fn BaseProxyHandler_getElements(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js10ProxyClassE"]
            pub static ProxyClass: root::JSClass;
            #[link_name = "\u{1}_ZN2js14NewProxyObjectEP9JSContextPKNS_16BaseProxyHandlerEN2JS6HandleINS5_5ValueEEEP8JSObjectRKNS_12ProxyOptionsE"]
            pub fn NewProxyObject(
                cx: *mut root::JSContext,
                handler: *const root::js::BaseProxyHandler,
                priv_: root::JS::HandleValue,
                proto: *mut root::JSObject,
                options: *const root::js::ProxyOptions,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js16RenewProxyObjectEP9JSContextP8JSObjectPNS_16BaseProxyHandlerERKN2JS5ValueE"]
            pub fn RenewProxyObject(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                handler: *mut root::js::BaseProxyHandler,
                priv_: *const root::JS::Value,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js15AutoEnterPolicy34reportErrorIfExceptionIsNotPendingEP9JSContextN2JS6HandleINS3_11PropertyKeyEEE"]
            pub fn AutoEnterPolicy_reportErrorIfExceptionIsNotPending(
                this: *mut root::js::AutoEnterPolicy,
                cx: *mut root::JSContext,
                id: root::JS::HandleId,
            );
            #[link_name = "\u{1}_ZN2js15AutoEnterPolicy11recordEnterEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEj"]
            pub fn AutoEnterPolicy_recordEnter(
                this: *mut root::js::AutoEnterPolicy,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                act: root::js::AutoEnterPolicy_Action,
            );
            #[link_name = "\u{1}_ZN2js15AutoEnterPolicy11recordLeaveEv"]
            pub fn AutoEnterPolicy_recordLeave(this: *mut root::js::AutoEnterPolicy);
            #[link_name = "\u{1}_ZN2js19assertEnteredPolicyEP9JSContextP8JSObjectN2JS11PropertyKeyEj"]
            pub fn assertEnteredPolicy(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                id: root::jsid,
                act: root::js::BaseProxyHandler_Action,
            );
            #[link_name = "\u{1}_ZN2js13ProxyClassOpsE"]
            pub static ProxyClassOps: root::JSClassOps;
            #[link_name = "\u{1}_ZN2js19ProxyClassExtensionE"]
            pub static ProxyClassExtension: root::js::ClassExtension;
            #[link_name = "\u{1}_ZN2js14ProxyObjectOpsE"]
            pub static ProxyObjectOps: root::js::ObjectOps;
            #[link_name = "\u{1}_ZN2js15NukeNonCCWProxyEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn NukeNonCCWProxy(
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            );
            #[link_name = "\u{1}_ZN2js34NukeRemovedCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeRemovedCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
            /** Get the first SavedFrame object in this SavedFrame stack whose principals are
 subsumed by the given |principals|. If there is no such frame, return
 nullptr.

 Do NOT pass a non-SavedFrame object here.*/
            #[link_name = "\u{1}_ZN2js26GetFirstSubsumedSavedFrameEP9JSContextP12JSPrincipalsN2JS6HandleIP8JSObjectEENS4_20SavedFrameSelfHostedE"]
            pub fn GetFirstSubsumedSavedFrame(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
            #[must_use]
            #[link_name = "\u{1}_ZN2js24SharedArrayRawBufferRefs7acquireEP9JSContextPNS_20SharedArrayRawBufferE"]
            pub fn SharedArrayRawBufferRefs_acquire(
                this: *mut root::js::SharedArrayRawBufferRefs,
                cx: *mut root::JSContext,
                rawbuf: *mut root::js::SharedArrayRawBuffer,
            ) -> bool;
            #[must_use]
            #[link_name = "\u{1}_ZN2js24SharedArrayRawBufferRefs10acquireAllEP9JSContextRKS0_"]
            pub fn SharedArrayRawBufferRefs_acquireAll(
                this: *mut root::js::SharedArrayRawBufferRefs,
                cx: *mut root::JSContext,
                that: *const root::js::SharedArrayRawBufferRefs,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js24SharedArrayRawBufferRefs13takeOwnershipEOS0_"]
            pub fn SharedArrayRawBufferRefs_takeOwnership(
                this: *mut root::js::SharedArrayRawBufferRefs,
                arg1: *mut root::js::SharedArrayRawBufferRefs,
            );
            #[link_name = "\u{1}_ZN2js24SharedArrayRawBufferRefs10releaseAllEv"]
            pub fn SharedArrayRawBufferRefs_releaseAll(
                this: *mut root::js::SharedArrayRawBufferRefs,
            );
            #[link_name = "\u{1}_ZN2js24SharedArrayRawBufferRefsD1Ev"]
            pub fn SharedArrayRawBufferRefs_SharedArrayRawBufferRefs_destructor(
                this: *mut root::js::SharedArrayRawBufferRefs,
            );
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler24getOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIN7mozilla5MaybeINS3_18PropertyDescriptorEEEEE"]
            pub fn ForwardingProxyHandler_getOwnPropertyDescriptor(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler14definePropertyEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_18PropertyDescriptorEEERNS3_14ObjectOpResultE"]
            pub fn ForwardingProxyHandler_defineProperty(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler15ownPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn ForwardingProxyHandler_ownPropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler7delete_EP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEERNS3_14ObjectOpResultE"]
            pub fn ForwardingProxyHandler_delete_(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler9enumerateEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn ForwardingProxyHandler_enumerate(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler12getPrototypeEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleIS6_EE"]
            pub fn ForwardingProxyHandler_getPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler12setPrototypeEP9JSContextN2JS6HandleIP8JSObjectEES7_RNS3_14ObjectOpResultE"]
            pub fn ForwardingProxyHandler_setPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler22getPrototypeIfOrdinaryEP9JSContextN2JS6HandleIP8JSObjectEEPbNS3_13MutableHandleIS6_EE"]
            pub fn ForwardingProxyHandler_getPrototypeIfOrdinary(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isOrdinary: *mut bool,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler21setImmutablePrototypeEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn ForwardingProxyHandler_setImmutablePrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler17preventExtensionsEP9JSContextN2JS6HandleIP8JSObjectEERNS3_14ObjectOpResultE"]
            pub fn ForwardingProxyHandler_preventExtensions(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler12isExtensibleEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn ForwardingProxyHandler_isExtensible(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                extensible: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler3hasEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn ForwardingProxyHandler_has(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler3getEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_5ValueEEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIS8_EE"]
            pub fn ForwardingProxyHandler_get(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler3setEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_5ValueEEESB_RNS3_14ObjectOpResultE"]
            pub fn ForwardingProxyHandler_set(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler4callEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn ForwardingProxyHandler_call(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler9constructEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn ForwardingProxyHandler_construct(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler6hasOwnEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn ForwardingProxyHandler_hasOwn(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler28getOwnEnumerablePropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn ForwardingProxyHandler_getOwnEnumerablePropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler10nativeCallEP9JSContextPFbN2JS6HandleINS3_5ValueEEEEPFbS2_RKNS3_8CallArgsEESB_"]
            pub fn ForwardingProxyHandler_nativeCall(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                test: root::JS::IsAcceptableThis,
                impl_: root::JS::NativeImpl,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler15getBuiltinClassEP9JSContextN2JS6HandleIP8JSObjectEEPNS_7ESClassE"]
            pub fn ForwardingProxyHandler_getBuiltinClass(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                cls: *mut root::js::ESClass,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler7isArrayEP9JSContextN2JS6HandleIP8JSObjectEEPNS3_13IsArrayAnswerE"]
            pub fn ForwardingProxyHandler_isArray(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler9classNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn ForwardingProxyHandler_className(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler12fun_toStringEP9JSContextN2JS6HandleIP8JSObjectEEb"]
            pub fn ForwardingProxyHandler_fun_toString(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isToSource: bool,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler15regexp_toSharedEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn ForwardingProxyHandler_regexp_toShared(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *mut root::js::RegExpShared;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler16boxedValue_unboxEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_5ValueEEE"]
            pub fn ForwardingProxyHandler_boxedValue_unbox(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler10isCallableEP8JSObject"]
            pub fn ForwardingProxyHandler_isCallable(
                this: *mut ::std::os::raw::c_void,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js22ForwardingProxyHandler13isConstructorEP8JSObject"]
            pub fn ForwardingProxyHandler_isConstructor(
                this: *mut ::std::os::raw::c_void,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js7Wrapper6familyE"]
            pub static Wrapper_family: ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZN2js7Wrapper9singletonE"]
            pub static Wrapper_singleton: root::js::Wrapper;
            #[link_name = "\u{1}_ZN2js7Wrapper22singletonWithPrototypeE"]
            pub static Wrapper_singletonWithPrototype: root::js::Wrapper;
            #[link_name = "\u{1}_ZN2js7Wrapper12defaultProtoE"]
            pub static Wrapper_defaultProto: *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js7Wrapper3NewEP9JSContextP8JSObjectPKS0_RKNS_14WrapperOptionsE"]
            pub fn Wrapper_New(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                handler: *const root::js::Wrapper,
                options: *const root::js::WrapperOptions,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js7Wrapper5RenewEP8JSObjectS2_PKS0_"]
            pub fn Wrapper_Renew(
                existing: *mut root::JSObject,
                obj: *mut root::JSObject,
                handler: *const root::js::Wrapper,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js7Wrapper13wrappedObjectEP8JSObject"]
            pub fn Wrapper_wrappedObject(
                wrapper: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZNK2js7Wrapper20finalizeInBackgroundERKN2JS5ValueE"]
            pub fn Wrapper_finalizeInBackground(
                this: *mut ::std::os::raw::c_void,
                priv_: *const root::JS::Value,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper9singletonE"]
            pub static CrossCompartmentWrapper_singleton: root::js::CrossCompartmentWrapper;
            #[link_name = "\u{1}_ZN2js23CrossCompartmentWrapper22singletonWithPrototypeE"]
            pub static CrossCompartmentWrapper_singletonWithPrototype: root::js::CrossCompartmentWrapper;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper24getOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIN7mozilla5MaybeINS3_18PropertyDescriptorEEEEE"]
            pub fn CrossCompartmentWrapper_getOwnPropertyDescriptor(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper14definePropertyEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_18PropertyDescriptorEEERNS3_14ObjectOpResultE"]
            pub fn CrossCompartmentWrapper_defineProperty(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper15ownPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn CrossCompartmentWrapper_ownPropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper7delete_EP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEERNS3_14ObjectOpResultE"]
            pub fn CrossCompartmentWrapper_delete_(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper9enumerateEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn CrossCompartmentWrapper_enumerate(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper12getPrototypeEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleIS6_EE"]
            pub fn CrossCompartmentWrapper_getPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper12setPrototypeEP9JSContextN2JS6HandleIP8JSObjectEES7_RNS3_14ObjectOpResultE"]
            pub fn CrossCompartmentWrapper_setPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper22getPrototypeIfOrdinaryEP9JSContextN2JS6HandleIP8JSObjectEEPbNS3_13MutableHandleIS6_EE"]
            pub fn CrossCompartmentWrapper_getPrototypeIfOrdinary(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isOrdinary: *mut bool,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper21setImmutablePrototypeEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn CrossCompartmentWrapper_setImmutablePrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper17preventExtensionsEP9JSContextN2JS6HandleIP8JSObjectEERNS3_14ObjectOpResultE"]
            pub fn CrossCompartmentWrapper_preventExtensions(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper12isExtensibleEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn CrossCompartmentWrapper_isExtensible(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                extensible: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper3hasEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn CrossCompartmentWrapper_has(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper3getEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_5ValueEEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIS8_EE"]
            pub fn CrossCompartmentWrapper_get(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper3setEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_5ValueEEESB_RNS3_14ObjectOpResultE"]
            pub fn CrossCompartmentWrapper_set(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper4callEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn CrossCompartmentWrapper_call(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper9constructEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn CrossCompartmentWrapper_construct(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper6hasOwnEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn CrossCompartmentWrapper_hasOwn(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper28getOwnEnumerablePropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn CrossCompartmentWrapper_getOwnEnumerablePropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper10nativeCallEP9JSContextPFbN2JS6HandleINS3_5ValueEEEEPFbS2_RKNS3_8CallArgsEESB_"]
            pub fn CrossCompartmentWrapper_nativeCall(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                test: root::JS::IsAcceptableThis,
                impl_: root::JS::NativeImpl,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper9classNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn CrossCompartmentWrapper_className(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper12fun_toStringEP9JSContextN2JS6HandleIP8JSObjectEEb"]
            pub fn CrossCompartmentWrapper_fun_toString(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                isToSource: bool,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper15regexp_toSharedEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn CrossCompartmentWrapper_regexp_toShared(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
            ) -> *mut root::js::RegExpShared;
            #[link_name = "\u{1}_ZNK2js23CrossCompartmentWrapper16boxedValue_unboxEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_5ValueEEE"]
            pub fn CrossCompartmentWrapper_boxedValue_unbox(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js29OpaqueCrossCompartmentWrapper9singletonE"]
            pub static OpaqueCrossCompartmentWrapper_singleton: root::js::OpaqueCrossCompartmentWrapper;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper24getOwnPropertyDescriptorEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIN7mozilla5MaybeINS3_18PropertyDescriptorEEEEE"]
            pub fn OpaqueCrossCompartmentWrapper_getOwnPropertyDescriptor(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper14definePropertyEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_18PropertyDescriptorEEERNS3_14ObjectOpResultE"]
            pub fn OpaqueCrossCompartmentWrapper_defineProperty(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper15ownPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn OpaqueCrossCompartmentWrapper_ownPropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper7delete_EP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEERNS3_14ObjectOpResultE"]
            pub fn OpaqueCrossCompartmentWrapper_delete_(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper9enumerateEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn OpaqueCrossCompartmentWrapper_enumerate(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper12getPrototypeEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleIS6_EE"]
            pub fn OpaqueCrossCompartmentWrapper_getPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper12setPrototypeEP9JSContextN2JS6HandleIP8JSObjectEES7_RNS3_14ObjectOpResultE"]
            pub fn OpaqueCrossCompartmentWrapper_setPrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                proto: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper22getPrototypeIfOrdinaryEP9JSContextN2JS6HandleIP8JSObjectEEPbNS3_13MutableHandleIS6_EE"]
            pub fn OpaqueCrossCompartmentWrapper_getPrototypeIfOrdinary(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                isOrdinary: *mut bool,
                protop: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper21setImmutablePrototypeEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn OpaqueCrossCompartmentWrapper_setImmutablePrototype(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                succeeded: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper17preventExtensionsEP9JSContextN2JS6HandleIP8JSObjectEERNS3_14ObjectOpResultE"]
            pub fn OpaqueCrossCompartmentWrapper_preventExtensions(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper12isExtensibleEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn OpaqueCrossCompartmentWrapper_isExtensible(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                extensible: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper3hasEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn OpaqueCrossCompartmentWrapper_has(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper3getEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_5ValueEEENS4_INS3_11PropertyKeyEEENS3_13MutableHandleIS8_EE"]
            pub fn OpaqueCrossCompartmentWrapper_get(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                receiver: root::JS::HandleValue,
                id: root::JS::HandleId,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper3setEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEENS4_INS3_5ValueEEESB_RNS3_14ObjectOpResultE"]
            pub fn OpaqueCrossCompartmentWrapper_set(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper4callEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn OpaqueCrossCompartmentWrapper_call(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper9constructEP9JSContextN2JS6HandleIP8JSObjectEERKNS3_8CallArgsE"]
            pub fn OpaqueCrossCompartmentWrapper_construct(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                args: *const root::JS::CallArgs,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper6hasOwnEP9JSContextN2JS6HandleIP8JSObjectEENS4_INS3_11PropertyKeyEEEPb"]
            pub fn OpaqueCrossCompartmentWrapper_hasOwn(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper28getOwnEnumerablePropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEENS3_13MutableHandleINS3_13StackGCVectorINS3_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn OpaqueCrossCompartmentWrapper_getOwnEnumerablePropertyKeys(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper15getBuiltinClassEP9JSContextN2JS6HandleIP8JSObjectEEPNS_7ESClassE"]
            pub fn OpaqueCrossCompartmentWrapper_getBuiltinClass(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
                cls: *mut root::js::ESClass,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper7isArrayEP9JSContextN2JS6HandleIP8JSObjectEEPNS3_13IsArrayAnswerE"]
            pub fn OpaqueCrossCompartmentWrapper_isArray(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper9classNameEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn OpaqueCrossCompartmentWrapper_className(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                wrapper: root::JS::HandleObject,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZNK2js29OpaqueCrossCompartmentWrapper12fun_toStringEP9JSContextN2JS6HandleIP8JSObjectEEb"]
            pub fn OpaqueCrossCompartmentWrapper_fun_toString(
                this: *mut ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                isToSource: bool,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZN2js24TransparentObjectWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn TransparentObjectWrapper(
                cx: *mut root::JSContext,
                existing: root::JS::HandleObject,
                obj: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js15UncheckedUnwrapEP8JSObjectbPj"]
            pub fn UncheckedUnwrap(
                obj: *mut root::JSObject,
                stopAtWindowProxy: bool,
                flagsp: *mut ::std::os::raw::c_uint,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js19CheckedUnwrapStaticEP8JSObject"]
            pub fn CheckedUnwrapStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js22UnwrapOneCheckedStaticEP8JSObject"]
            pub fn UnwrapOneCheckedStatic(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js20CheckedUnwrapDynamicEP8JSObjectP9JSContextb"]
            pub fn CheckedUnwrapDynamic(
                obj: *mut root::JSObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js23UnwrapOneCheckedDynamicEN2JS6HandleIP8JSObjectEEP9JSContextb"]
            pub fn UnwrapOneCheckedDynamic(
                obj: root::JS::HandleObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js28UncheckedUnwrapWithoutExposeEP8JSObject"]
            pub fn UncheckedUnwrapWithoutExpose(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js18ReportAccessDeniedEP9JSContext"]
            pub fn ReportAccessDenied(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2js27NukeCrossCompartmentWrapperEP9JSContextP8JSObject"]
            pub fn NukeCrossCompartmentWrapper(
                cx: *mut root::JSContext,
                wrapper: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2js35NukeCrossCompartmentWrapperIfExistsEP9JSContextPN2JS11CompartmentEP8JSObject"]
            pub fn NukeCrossCompartmentWrapperIfExists(
                cx: *mut root::JSContext,
                source: *mut root::JS::Compartment,
                target: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2js12RemapWrapperEP9JSContextP8JSObjectS3_"]
            pub fn RemapWrapper(
                cx: *mut root::JSContext,
                wobj: *mut root::JSObject,
                newTarget: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2js16RemapDeadWrapperEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapDeadWrapper(
                cx: *mut root::JSContext,
                wobj: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            );
            #[link_name = "\u{1}_ZN2js25RemapAllWrappersForObjectEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn RemapAllWrappersForObject(
                cx: *mut root::JSContext,
                oldTarget: root::JS::HandleObject,
                newTarget: root::JS::HandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js17RecomputeWrappersEP9JSContextRKNS_17CompartmentFilterES4_"]
            pub fn RecomputeWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                targetFilter: *const root::js::CompartmentFilter,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js21UnwrapArrayBufferViewEP8JSObject"]
            pub fn UnwrapArrayBufferView(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js20UnwrapReadableStreamEP8JSObject"]
            pub fn UnwrapReadableStream(obj: *mut root::JSObject) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js31GetArrayBufferViewLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferViewLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            #[link_name = "\u{1}_ZN2js15UnwrapInt8ArrayEP8JSObject"]
            pub fn UnwrapInt8Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js16UnwrapUint8ArrayEP8JSObject"]
            pub fn UnwrapUint8Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js16UnwrapInt16ArrayEP8JSObject"]
            pub fn UnwrapInt16Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js17UnwrapUint16ArrayEP8JSObject"]
            pub fn UnwrapUint16Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js16UnwrapInt32ArrayEP8JSObject"]
            pub fn UnwrapInt32Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js17UnwrapUint32ArrayEP8JSObject"]
            pub fn UnwrapUint32Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js18UnwrapFloat32ArrayEP8JSObject"]
            pub fn UnwrapFloat32Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js18UnwrapFloat64ArrayEP8JSObject"]
            pub fn UnwrapFloat64Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js23UnwrapUint8ClampedArrayEP8JSObject"]
            pub fn UnwrapUint8ClampedArray(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js19UnwrapBigInt64ArrayEP8JSObject"]
            pub fn UnwrapBigInt64Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js20UnwrapBigUint64ArrayEP8JSObject"]
            pub fn UnwrapBigUint64Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js18UnwrapFloat16ArrayEP8JSObject"]
            pub fn UnwrapFloat16Array(
                maybeWrapped: *mut root::JSObject,
            ) -> *mut root::JSObject;
            /** A JSErrorCallback suitable for passing to |JS_ReportErrorNumberASCII| and
 similar functions in concert with one of the |JSErrNum| error numbers.

 This function is a function only of |errorNumber|: |userRef| and ambient
 state have no effect on its behavior.*/
            #[link_name = "\u{1}_ZN2js15GetErrorMessageEPvj"]
            pub fn GetErrorMessage(
                userRef: *mut ::std::os::raw::c_void,
                errorNumber: ::std::os::raw::c_uint,
            ) -> *const root::JSErrorFormatString;
            /** Tell the JS engine which Class is used for WindowProxy objects. Used by the
 functions below.*/
            #[link_name = "\u{1}_ZN2js19SetWindowProxyClassEP9JSContextPK7JSClass"]
            pub fn SetWindowProxyClass(
                cx: *mut root::JSContext,
                clasp: *const root::JSClass,
            );
            /** Associates a WindowProxy with a Window (global object). `windowProxy` must
 have the Class set by SetWindowProxyClass.*/
            #[link_name = "\u{1}_ZN2js14SetWindowProxyEP9JSContextN2JS6HandleIP8JSObjectEES6_"]
            pub fn SetWindowProxy(
                cx: *mut root::JSContext,
                global: root::JS::Handle<*mut root::JSObject>,
                windowProxy: root::JS::Handle<*mut root::JSObject>,
            );
            /// Returns true iff `obj` has the WindowProxy Class (see SetWindowProxyClass).
            #[link_name = "\u{1}_ZN2js13IsWindowProxyEP8JSObject"]
            pub fn IsWindowProxy(obj: *mut root::JSObject) -> bool;
            /** If `obj` is a WindowProxy, get its associated Window (the compartment's
 global), else return `obj`. This function is infallible and never returns
 nullptr.*/
            #[link_name = "\u{1}_ZN2js21ToWindowIfWindowProxyEP8JSObject"]
            pub fn ToWindowIfWindowProxy(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js15TraceValueArrayEP8JSTracermPN2JS5ValueE"]
            pub fn TraceValueArray(
                trc: *mut root::JSTracer,
                length: usize,
                elements: *mut root::JS::Value,
            );
            #[link_name = "\u{1}_ZN2js16AssertHeapIsIdleEv"]
            pub fn AssertHeapIsIdle();
            /** Hint that we expect a crash. Currently, the only thing that cares is the
 breakpad injector, which (if loaded) will suppress minidump generation.*/
            #[link_name = "\u{1}_ZN2js20NoteIntentionalCrashEv"]
            pub fn NoteIntentionalCrash();
            /** Get the script private value associated with an object, if any.

 The private value is set with SetScriptPrivate() or SetModulePrivate() and is
 internally stored on the relevant ScriptSourceObject.

 This is used by the cycle collector to trace through
 ScriptSourceObjects. This allows private values to contain an nsISupports
 pointer and hence support references to cycle collected C++ objects.*/
            #[link_name = "\u{1}_ZN2js21MaybeGetScriptPrivateEP8JSObject"]
            pub fn MaybeGetScriptPrivate(object: *mut root::JSObject) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2js17IsArgumentsObjectEN2JS6HandleIP8JSObjectEE"]
            pub fn IsArgumentsObject(obj: root::JS::HandleObject) -> bool;
            #[link_name = "\u{1}_ZN2js15AddRawValueRootEP9JSContextPN2JS5ValueEPKc"]
            pub fn AddRawValueRoot(
                cx: *mut root::JSContext,
                vp: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js18RemoveRawValueRootEP9JSContextPN2JS5ValueE"]
            pub fn RemoveRawValueRoot(
                cx: *mut root::JSContext,
                vp: *mut root::JS::Value,
            );
            /** Use the runtime's internal handling of job queues for Promise jobs.

 Most embeddings, notably web browsers, will have their own task scheduling
 systems and need to integrate handling of Promise jobs into that, so they
 will want to manage job queues themselves. For basic embeddings such as the
 JS shell that don't have an event loop of their own, it's easier to have
 SpiderMonkey handle job queues internally.

 Note that the embedding still has to trigger processing of job queues at
 right time(s), such as after evaluation of a script has run to completion.*/
            #[link_name = "\u{1}_ZN2js20UseInternalJobQueuesEP9JSContext"]
            pub fn UseInternalJobQueues(cx: *mut root::JSContext) -> bool;
            /** Given internal job queues are used, return currently queued jobs as an
 array of job objects.*/
            #[link_name = "\u{1}_ZN2js25GetJobsInInternalJobQueueEP9JSContext"]
            pub fn GetJobsInInternalJobQueue(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            /** Enqueue |job| on the internal job queue.

 This is useful in tests for creating situations where a call occurs with no
 other JavaScript on the stack.*/
            #[link_name = "\u{1}_ZN2js10EnqueueJobEP9JSContextN2JS6HandleIP8JSObjectEE"]
            pub fn EnqueueJob(
                cx: *mut root::JSContext,
                job: root::JS::HandleObject,
            ) -> bool;
            /** Instruct the runtime to stop draining the internal job queue.

 Useful if the embedding is in the process of quitting in reaction to a
 builtin being called, or if it wants to resume executing jobs later on.*/
            #[link_name = "\u{1}_ZN2js20StopDrainingJobQueueEP9JSContext"]
            pub fn StopDrainingJobQueue(cx: *mut root::JSContext);
            /** Instruct the runtime to restart draining the internal job queue after
 stopping it with StopDrainingJobQueue.*/
            #[link_name = "\u{1}_ZN2js23RestartDrainingJobQueueEP9JSContext"]
            pub fn RestartDrainingJobQueue(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2js7RunJobsEP9JSContext"]
            pub fn RunJobs(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2js14HasJobsPendingEP9JSContext"]
            pub fn HasJobsPending(cx: *mut root::JSContext) -> bool;
            /** Reset the seed for Math.random().

 Enables embedders to reset the seed at controlled points, e.g. after
 resuming execution from an instance snapshot of SpiderMonkey's VM.*/
            #[link_name = "\u{1}_ZN2js19ResetMathRandomSeedEP9JSContext"]
            pub fn ResetMathRandomSeed(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2js12GetRealmZoneEPN2JS5RealmE"]
            pub fn GetRealmZone(realm: *mut root::JS::Realm) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2js13IsSystemRealmEPN2JS5RealmE"]
            pub fn IsSystemRealm(realm: *mut root::JS::Realm) -> bool;
            #[link_name = "\u{1}_ZN2js19IsSystemCompartmentEPN2JS11CompartmentE"]
            pub fn IsSystemCompartment(comp: *mut root::JS::Compartment) -> bool;
            #[link_name = "\u{1}_ZN2js12IsSystemZoneEPN2JS4ZoneE"]
            pub fn IsSystemZone(zone: *mut root::JS::Zone) -> bool;
            #[link_name = "\u{1}_ZN2js13TraceWeakMapsEPNS_13WeakMapTracerE"]
            pub fn TraceWeakMaps(trc: *mut root::js::WeakMapTracer);
            #[link_name = "\u{1}_ZN2js18AreGCGrayBitsValidEP9JSRuntime"]
            pub fn AreGCGrayBitsValid(rt: *mut root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2js21ZoneGlobalsAreAllGrayEPN2JS4ZoneE"]
            pub fn ZoneGlobalsAreAllGray(zone: *mut root::JS::Zone) -> bool;
            #[link_name = "\u{1}_ZN2js37IsCompartmentZoneSweepingOrCompactingEPN2JS11CompartmentE"]
            pub fn IsCompartmentZoneSweepingOrCompacting(
                comp: *mut root::JS::Compartment,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js23TraceGrayWrapperTargetsEP8JSTracerPN2JS4ZoneE"]
            pub fn TraceGrayWrapperTargets(
                trc: *mut root::JSTracer,
                zone: *mut root::JS::Zone,
            );
            /// Invoke cellCallback on every gray JSObject in the given zone.
            #[link_name = "\u{1}_ZN2js18IterateGrayObjectsEPN2JS4ZoneEPFvPvNS0_9GCCellPtrERKNS0_15AutoRequireNoGCEES3_"]
            pub fn IterateGrayObjects(
                zone: *mut root::JS::Zone,
                cellCallback: root::js::IterateGCThingCallback,
                data: *mut ::std::os::raw::c_void,
            );
            #[link_name = "\u{1}_ZN2js21CheckGrayMarkingStateEP9JSRuntime"]
            pub fn CheckGrayMarkingState(rt: *mut root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2js17GetAnyRealmInZoneEPN2JS4ZoneE"]
            pub fn GetAnyRealmInZone(zone: *mut root::JS::Zone) -> *mut root::JS::Realm;
            #[link_name = "\u{1}_ZN2js27GetFirstGlobalInCompartmentEPN2JS11CompartmentE"]
            pub fn GetFirstGlobalInCompartment(
                comp: *mut root::JS::Compartment,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js24CompartmentHasLiveGlobalEPN2JS11CompartmentE"]
            pub fn CompartmentHasLiveGlobal(comp: *mut root::JS::Compartment) -> bool;
            #[link_name = "\u{1}_ZN2js21IsSharableCompartmentEPN2JS11CompartmentE"]
            pub fn IsSharableCompartment(comp: *mut root::JS::Compartment) -> bool;
            #[link_name = "\u{1}_ZN2js14ObjectClassPtrE"]
            pub static ObjectClassPtr: *const root::JSClass;
            #[link_name = "\u{1}_ZN2js15ProtoKeyToClassE10JSProtoKey"]
            pub fn ProtoKeyToClass(key: root::JSProtoKey) -> *const root::JSClass;
            #[link_name = "\u{1}_ZN2js30ShouldIgnorePropertyDefinitionEP9JSContext10JSProtoKeyN2JS11PropertyKeyE"]
            pub fn ShouldIgnorePropertyDefinition(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                id: root::jsid,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js16IsFunctionObjectEP8JSObject"]
            pub fn IsFunctionObject(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2js34UninlinedIsCrossCompartmentWrapperEPK8JSObject"]
            pub fn UninlinedIsCrossCompartmentWrapper(
                obj: *const root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2jsL20GetNonCCWObjectRealmEP8JSObject"]
            pub fn GetNonCCWObjectRealm(
                obj: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextP8JSObject"]
            pub fn AssertSameCompartment(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn AssertSameCompartment1(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            );
            #[link_name = "\u{1}_ZN2js21AssertSameCompartmentEP8JSObjectS1_"]
            pub fn AssertSameCompartment2(
                objA: *mut root::JSObject,
                objB: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2js23NotifyAnimationActivityEP8JSObject"]
            pub fn NotifyAnimationActivity(obj: *mut root::JSObject);
            #[link_name = "\u{1}_ZN2js26DefineFunctionWithReservedEP9JSContextP8JSObjectPKcPFbS1_jPN2JS5ValueEEjj"]
            pub fn DefineFunctionWithReserved(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                attrs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZN2js23NewFunctionWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjPKc"]
            pub fn NewFunctionWithReserved(
                cx: *mut root::JSContext,
                call: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                name: *const ::std::os::raw::c_char,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZN2js27NewFunctionByIdWithReservedEP9JSContextPFbS1_jPN2JS5ValueEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReserved(
                cx: *mut root::JSContext,
                native: root::JSNative,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZN2js35NewFunctionByIdWithReservedAndProtoEP9JSContextPFbS1_jPN2JS5ValueEENS2_6HandleIP8JSObjectEEjjNS2_11PropertyKeyE"]
            pub fn NewFunctionByIdWithReservedAndProto(
                cx: *mut root::JSContext,
                native: root::JSNative,
                proto: root::JS::Handle<*mut root::JSObject>,
                nargs: ::std::os::raw::c_uint,
                flags: ::std::os::raw::c_uint,
                id: root::jsid,
            ) -> *mut root::JSFunction;
            /** Get or set function's reserved slot value.
 `fun` should be a function created with `*WithReserved` API above.
 Such functions have 2 reserved slots, and `which` can be either 0 or 1.*/
            #[link_name = "\u{1}_ZN2js25GetFunctionNativeReservedEP8JSObjectm"]
            pub fn GetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
            ) -> *const root::JS::Value;
            #[link_name = "\u{1}_ZN2js25SetFunctionNativeReservedEP8JSObjectmRKN2JS5ValueE"]
            pub fn SetFunctionNativeReserved(
                fun: *mut root::JSObject,
                which: usize,
                val: *const root::JS::Value,
            );
            #[link_name = "\u{1}_ZN2js25FunctionHasNativeReservedEP8JSObject"]
            pub fn FunctionHasNativeReserved(fun: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2js14GetObjectProtoEP9JSContextN2JS6HandleIP8JSObjectEENS2_13MutableHandleIS5_EE"]
            pub fn GetObjectProto(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                proto: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js18GetStaticPrototypeEP8JSObject"]
            pub fn GetStaticPrototype(obj: *mut root::JSObject) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js20GetRealmOriginalEvalEP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
            pub fn GetRealmOriginalEval(
                cx: *mut root::JSContext,
                eval: root::JS::MutableHandleObject,
            ) -> bool;
            /** Add some or all property keys of obj to the id vector *props.

 The flags parameter controls which property keys are added. Pass a
 combination of the following bits:

     JSITER_OWNONLY - Don't also search the prototype chain; only consider
       obj's own properties.

     JSITER_HIDDEN - Include nonenumerable properties.

     JSITER_SYMBOLS - Include property keys that are symbols. The default
       behavior is to filter out symbols.

     JSITER_SYMBOLSONLY - Exclude non-symbol property keys.

 This is the closest C++ API we have to `Reflect.ownKeys(obj)`, or
 equivalently, the ES6 [[OwnPropertyKeys]] internal method. Pass
 `JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS` as flags to get
 results that match the output of Reflect.ownKeys.*/
            #[link_name = "\u{1}_ZN2js15GetPropertyKeysEP9JSContextN2JS6HandleIP8JSObjectEEjNS2_13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEE"]
            pub fn GetPropertyKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                flags: ::std::os::raw::c_uint,
                props: root::JS::MutableHandleIdVector,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12AppendUniqueEP9JSContextN2JS13MutableHandleINS2_13StackGCVectorINS2_11PropertyKeyENS_15TempAllocPolicyEEEEENS2_6HandleIS7_EE"]
            pub fn AppendUnique(
                cx: *mut root::JSContext,
                base: root::JS::MutableHandleIdVector,
                others: root::JS::HandleIdVector,
            ) -> bool;
            /** Determine whether the given string is an array index in the sense of
 <https://tc39.github.io/ecma262/#array-index>.

 If it isn't, returns false.

 If it is, returns true and outputs the index in *indexp.*/
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPK14JSLinearStringPj"]
            pub fn StringIsArrayIndex(
                str_: *const root::JSLinearString,
                indexp: *mut u32,
            ) -> bool;
            /** Overload of StringIsArrayIndex taking a (char16_t*,length) pair. Behaves
 the same as the JSLinearString version.*/
            #[link_name = "\u{1}_ZN2js18StringIsArrayIndexEPKDsjPj"]
            pub fn StringIsArrayIndex1(
                str_: *const u16,
                length: u32,
                indexp: *mut u32,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js27SetPreserveWrapperCallbacksEP9JSContextPFbS1_N2JS6HandleIP8JSObjectEEEPFbS6_E"]
            pub fn SetPreserveWrapperCallbacks(
                cx: *mut root::JSContext,
                preserveWrapper: root::js::PreserveWrapperCallback,
                hasReleasedWrapper: root::js::HasReleasedWrapperCallback,
            );
            #[link_name = "\u{1}_ZN2js28IsObjectInContextCompartmentEP8JSObjectPK9JSContext"]
            pub fn IsObjectInContextCompartment(
                obj: *mut root::JSObject,
                cx: *const root::JSContext,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js15SetDOMCallbacksEP9JSContextPKNS_14JSDOMCallbacksE"]
            pub fn SetDOMCallbacks(
                cx: *mut root::JSContext,
                callbacks: *const root::js::DOMCallbacks,
            );
            #[link_name = "\u{1}_ZN2js15GetDOMCallbacksEP9JSContext"]
            pub fn GetDOMCallbacks(
                cx: *mut root::JSContext,
            ) -> *const root::js::DOMCallbacks;
            #[link_name = "\u{1}_ZN2js19GetTestingFunctionsEP9JSContext"]
            pub fn GetTestingFunctions(cx: *mut root::JSContext) -> *mut root::JSObject;
            /** Get an error type name from a JSExnType constant.
 Returns nullptr for invalid arguments and JSEXN_INTERNALERR*/
            #[link_name = "\u{1}_ZN2js16GetErrorTypeNameEP9JSContexts"]
            pub fn GetErrorTypeName(
                cx: *mut root::JSContext,
                exnType: i16,
            ) -> *mut root::JSLinearString;
            #[link_name = "\u{1}_ZN2js28NukeCrossCompartmentWrappersEP9JSContextRKNS_17CompartmentFilterEPN2JS5RealmENS_22NukeReferencesToWindowENS_24NukeReferencesFromTargetE"]
            pub fn NukeCrossCompartmentWrappers(
                cx: *mut root::JSContext,
                sourceFilter: *const root::js::CompartmentFilter,
                target: *mut root::JS::Realm,
                nukeReferencesToWindow: root::js::NukeReferencesToWindow,
                nukeReferencesFromTarget: root::js::NukeReferencesFromTarget,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js15AllowNewWrapperEPN2JS11CompartmentEP8JSObject"]
            pub fn AllowNewWrapper(
                target: *mut root::JS::Compartment,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js16NukedObjectRealmEP8JSObject"]
            pub fn NukedObjectRealm(obj: *mut root::JSObject) -> bool;
            /// Detect whether the internal date value is NaN.
            #[link_name = "\u{1}_ZN2js11DateIsValidEP9JSContextN2JS6HandleIP8JSObjectEEPb"]
            pub fn DateIsValid(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isValid: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js21DateGetMsecSinceEpochEP9JSContextN2JS6HandleIP8JSObjectEEPd"]
            pub fn DateGetMsecSinceEpoch(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                msecSinceEpoch: *mut f64,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js11GetSCOffsetEP23JSStructuredCloneWriter"]
            pub fn GetSCOffset(writer: *mut root::JSStructuredCloneWriter) -> u64;
            #[link_name = "\u{1}_ZN2jsL9IdToValueEN2JS11PropertyKeyE"]
            pub fn IdToValue(id: root::jsid) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2js33PrepareScriptEnvironmentAndInvokeEP9JSContextN2JS6HandleIP8JSObjectEERNS_25ScriptEnvironmentPreparer7ClosureE"]
            pub fn PrepareScriptEnvironmentAndInvoke(
                cx: *mut root::JSContext,
                global: root::JS::HandleObject,
                closure: *mut root::js::ScriptEnvironmentPreparer_Closure,
            );
            #[link_name = "\u{1}_ZN2js28SetScriptEnvironmentPreparerEP9JSContextPNS_25ScriptEnvironmentPreparerE"]
            pub fn SetScriptEnvironmentPreparer(
                cx: *mut root::JSContext,
                preparer: *mut root::js::ScriptEnvironmentPreparer,
            );
            /** Specify a callback to invoke when creating each JS object in the current
 compartment, which may return a metadata object to associate with the
 object.*/
            #[link_name = "\u{1}_ZN2js28SetAllocationMetadataBuilderEP9JSContextPKNS_25AllocationMetadataBuilderE"]
            pub fn SetAllocationMetadataBuilder(
                cx: *mut root::JSContext,
                callback: *const root::js::AllocationMetadataBuilder,
            );
            /// Get the metadata associated with an object.
            #[link_name = "\u{1}_ZN2js21GetAllocationMetadataEP8JSObject"]
            pub fn GetAllocationMetadata(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2js20GetElementsWithAdderEP9JSContextN2JS6HandleIP8JSObjectEES6_jjPNS_12ElementAdderE"]
            pub fn GetElementsWithAdder(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                receiver: root::JS::HandleObject,
                begin: u32,
                end: u32,
                adder: *mut root::js::ElementAdder,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js15ForwardToNativeEP9JSContextPFbS1_jPN2JS5ValueEERKNS2_8CallArgsE"]
            pub fn ForwardToNative(
                cx: *mut root::JSContext,
                native: root::JSNative,
                args: *const root::JS::CallArgs,
            ) -> bool;
            /** Helper function for HTMLDocument and HTMLFormElement.

 These are the only two interfaces that have [OverrideBuiltins], a named
 getter, and no named setter. They're implemented as proxies with a custom
 getOwnPropertyDescriptor() method. Unfortunately, overriding
 getOwnPropertyDescriptor() automatically affects the behavior of set(),
 which normally is just common sense but is *not* desired for these two
 interfaces.

 The fix is for these two interfaces to override set() to ignore the
 getOwnPropertyDescriptor() override.

 SetPropertyIgnoringNamedGetter is exposed to make it easier to override
 set() in this way.  It carries out all the steps of BaseProxyHandler::set()
 except the initial getOwnPropertyDescriptor() call.  The caller must supply
 that descriptor as the 'ownDesc' parameter.

 Implemented in proxy/BaseProxyHandler.cpp.*/
            #[link_name = "\u{1}_ZN2js30SetPropertyIgnoringNamedGetterEP9JSContextN2JS6HandleIP8JSObjectEENS3_INS2_11PropertyKeyEEENS3_INS2_5ValueEEESA_NS3_IN7mozilla5MaybeINS2_18PropertyDescriptorEEEEERNS2_14ObjectOpResultE"]
            pub fn SetPropertyIgnoringNamedGetter(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
                v: root::JS::HandleValue,
                receiver: root::JS::HandleValue,
                ownDesc: root::JS::Handle<root::mozilla::Maybe>,
                result: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js31ExecuteInFrameScriptEnvironmentEP9JSContextN2JS6HandleIP8JSObjectEENS3_IP8JSScriptEENS2_13MutableHandleIS5_EE"]
            pub fn ExecuteInFrameScriptEnvironment(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                script: root::JS::HandleScript,
                scope: root::JS::MutableHandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js12IsSavedFrameEP8JSObject"]
            pub fn IsSavedFrame(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2js19ReportIsNotFunctionEP9JSContextN2JS6HandleINS2_5ValueEEE"]
            pub fn ReportIsNotFunction(
                cx: *mut root::JSContext,
                v: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2js21AutoAssertNoContentJSC1EP9JSContext"]
            pub fn AutoAssertNoContentJS_AutoAssertNoContentJS(
                this: *mut root::js::AutoAssertNoContentJS,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2js21AutoAssertNoContentJSD1Ev"]
            pub fn AutoAssertNoContentJS_AutoAssertNoContentJS_destructor(
                this: *mut root::js::AutoAssertNoContentJS,
            );
            /** This function reports memory used by a zone in bytes, this includes:
  * The size of this JS GC zone.
  * Malloc memory referred to from this zone.
  * JIT memory for this zone.

 Note that malloc memory referred to from this zone can include
 SharedArrayBuffers which may also be referred to from other zones. Adding the
 memory usage of multiple zones may lead to an over-estimate.*/
            #[link_name = "\u{1}_ZN2js21GetMemoryUsageForZoneEPN2JS4ZoneE"]
            pub fn GetMemoryUsageForZone(zone: *mut root::JS::Zone) -> u64;
            #[link_name = "\u{1}_ZN2js27GetSharedMemoryUsageForZoneEPN2JS4ZoneE"]
            pub fn GetSharedMemoryUsageForZone(
                zone: *mut root::JS::Zone,
            ) -> *const root::js::gc::SharedMemoryMap;
            /** This function only reports GC heap memory,
 and not malloc allocated memory associated with GC things.
 It reports the total of all memory for the whole Runtime.*/
            #[link_name = "\u{1}_ZN2js14GetGCHeapUsageEP9JSContext"]
            pub fn GetGCHeapUsage(cx: *mut root::JSContext) -> u64;
            #[link_name = "\u{1}_ZN2js24RemapRemoteWindowProxiesEP9JSContextPNS_29CompartmentTransplantCallbackEN2JS13MutableHandleIP8JSObjectEE"]
            pub fn RemapRemoteWindowProxies(
                cx: *mut root::JSContext,
                callback: *mut root::js::CompartmentTransplantCallback,
                newTarget: root::JS::MutableHandleObject,
            );
            #[link_name = "\u{1}_ZN2js26GetObjectZoneFromAnyThreadEPK8JSObject"]
            pub fn GetObjectZoneFromAnyThread(
                obj: *const root::JSObject,
            ) -> *mut root::JS::Zone;
        }
    }
    pub type jsbytecode = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtom {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSContext {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSFunction {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSObject {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSRuntime {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSScript {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSString {
        _unused: [u8; 0],
    }
    pub mod JS {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type Heap<T> = crate::jsgc::Heap<T>;
        pub type Rooted<T> = crate::jsgc::Rooted<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct GCContext {
            _unused: [u8; 0],
        }
        pub type Latin1Char = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Symbol {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BigInt {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Compartment {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Realm {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Runtime {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Zone {
            _unused: [u8; 0],
        }
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        pub type HandleFunction = root::JS::Handle<*mut root::JSFunction>;
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        pub type HandleId = root::JS::Handle<root::JS::PropertyKey>;
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        pub type HandleObject = root::JS::Handle<*mut root::JSObject>;
        pub type HandleScript = root::JS::Handle<*mut root::JSScript>;
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        pub type HandleString = root::JS::Handle<*mut root::JSString>;
        pub type HandleSymbol = root::JS::Handle<*mut root::JS::Symbol>;
        pub type HandleBigInt = root::JS::Handle<*mut root::JS::BigInt>;
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        pub type HandleValue = root::JS::Handle<root::JS::Value>;
        pub type HandleValueVector = u8;
        pub type HandleIdVector = u8;
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        pub type MutableHandleFunction = root::JS::MutableHandle<*mut root::JSFunction>;
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        pub type MutableHandleId = root::JS::MutableHandle<root::JS::PropertyKey>;
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        pub type MutableHandleObject = root::JS::MutableHandle<*mut root::JSObject>;
        pub type MutableHandleScript = root::JS::MutableHandle<*mut root::JSScript>;
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        pub type MutableHandleString = root::JS::MutableHandle<*mut root::JSString>;
        pub type MutableHandleSymbol = root::JS::MutableHandle<*mut root::JS::Symbol>;
        pub type MutableHandleBigInt = root::JS::MutableHandle<*mut root::JS::BigInt>;
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        pub type MutableHandleValue = root::JS::MutableHandle<root::JS::Value>;
        pub type MutableHandleValueVector = u8;
        /** Local variable of type T whose value is always rooted. This is typically
 used for local variables, or for non-rooted values being passed to a
 function that requires a handle, e.g. Foo(Root<T>(cx, x)).

 If you want to add additional methods to Rooted for a specific
 specialization, define a RootedOperations<T> specialization containing them.*/
        pub type RootedObject = root::JS::Rooted<*mut root::JSObject>;
        pub type RootedFunction = root::JS::Rooted<*mut root::JSFunction>;
        pub type RootedScript = root::JS::Rooted<*mut root::JSScript>;
        pub type RootedString = root::JS::Rooted<*mut root::JSString>;
        pub type RootedSymbol = root::JS::Rooted<*mut root::JS::Symbol>;
        pub type RootedBigInt = root::JS::Rooted<*mut root::JS::BigInt>;
        pub type RootedId = root::JS::Rooted<root::JS::PropertyKey>;
        /** Local variable of type T whose value is always rooted. This is typically
 used for local variables, or for non-rooted values being passed to a
 function that requires a handle, e.g. Foo(Root<T>(cx, x)).

 If you want to add additional methods to Rooted for a specific
 specialization, define a RootedOperations<T> specialization containing them.*/
        pub type RootedValue = root::JS::Rooted<root::JS::Value>;
        pub type PersistentRootedFunction = u8;
        pub type PersistentRootedId = u8;
        /** A copyable, assignable global GC root type with arbitrary lifetime, an
 infallible constructor, and automatic unrooting on destruction.

 These roots can be used in heap-allocated data structures, so they are not
 associated with any particular JSContext or stack. They are registered with
 the JSRuntime itself, without locking. Initialization may take place on
 construction, or in two phases if the no-argument constructor is called
 followed by init().

 Note that you must not use an PersistentRooted in an object owned by a JS
 object:

 Whenever one object whose lifetime is decided by the GC refers to another
 such object, that edge must be traced only if the owning JS object is traced.
 This applies not only to JS objects (which obviously are managed by the GC)
 but also to C++ objects owned by JS objects.

 If you put a PersistentRooted in such a C++ object, that is almost certainly
 a leak. When a GC begins, the referent of the PersistentRooted is treated as
 live, unconditionally (because a PersistentRooted is a *root*), even if the
 JS object that owns it is unreachable. If there is any path from that
 referent back to the JS object, then the C++ object containing the
 PersistentRooted will not be destructed, and the whole blob of objects will
 not be freed, even if there are no references to them from the outside.

 In the context of Firefox, this is a severe restriction: almost everything in
 Firefox is owned by some JS object or another, so using PersistentRooted in
 such objects would introduce leaks. For these kinds of edges, Heap<T> or
 TenuredHeap<T> would be better types. It's up to the implementor of the type
 containing Heap<T> or TenuredHeap<T> members to make sure their referents get
 marked when the object itself is marked.*/
        pub type PersistentRootedObject = [u32; 4usize];
        pub type PersistentRootedScript = u8;
        pub type PersistentRootedString = u8;
        pub type PersistentRootedSymbol = u8;
        pub type PersistentRootedBigInt = u8;
        pub type PersistentRootedValue = u8;
        pub type PersistentRootedIdVector = [u32; 18usize];
        pub type PersistentRootedObjectVector = [u32; 18usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DeletePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct FreePolicy {
            pub _address: u8,
        }
        pub type UniqueChars = u32;
        pub type UniqueTwoByteChars = u8;
        pub type UniqueLatin1Chars = u32;
        pub type UniqueWideChars = u8;
        #[repr(i32)]
        /** Marker enum to notify callers that the buffer contents must be freed manually
 when the ArrayBuffer allocation failed.*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum NewArrayBufferOutOfMemory {
            CallerMustFreeMemory = 0,
        }
        pub type BufferContentsFreeFunc = ::std::option::Option<
            unsafe extern "C" fn(
                contents: *mut ::std::os::raw::c_void,
                userData: *mut ::std::os::raw::c_void,
            ),
        >;
        /// UniquePtr deleter for external buffer contents.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct BufferContentsDeleter {
            pub freeFunc_: root::JS::BufferContentsFreeFunc,
            pub userData_: *mut ::std::os::raw::c_void,
        }
        pub mod detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type Int64Limits = u8;
            pub type Uint64Limits = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct NumberToBigIntConverter {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BigIntToNumberChecker {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct DefineComparisonOps {
                pub _base: root::std::false_type,
            }
            pub type RootedTraits = root::std::conditional_t;
            pub const MaybeLimitedColumnNumber_OriginValue: u32 = 1;
            pub const ColumnNumberOneOriginLimit: u32 = 1073741823;
            pub const InfinitySignBit: ::std::os::raw::c_int = 0;
            pub const InfinityBits: u64 = 9218868437227405312;
            pub const CanonicalizedNaNSignBit: ::std::os::raw::c_int = 0;
            pub const CanonicalizedNaNSignificand: u64 = 2251799813685248;
            pub const CanonicalizedNaNBits: u64 = 9221120237041090560;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct IncludeUsedRval {
                pub usedRval_: bool,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct NoUsedRval {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct CallArgsBase {
                pub _address: u8,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum InitState {
                Uninitialized = 0,
                Initializing = 1,
                Running = 2,
                ShutDown = 3,
            }
            #[repr(i32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FrontendOnly {
                No = 0,
                Yes = 1,
            }
            pub type ExternalTypeOf_t = u8;
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6detail15BigIntFromInt64EP9JSContextx"]
                pub fn BigIntFromInt64(
                    cx: *mut root::JSContext,
                    num: i64,
                ) -> *mut root::JS::BigInt;
                #[link_name = "\u{1}_ZN2JS6detail16BigIntFromUint64EP9JSContexty"]
                pub fn BigIntFromUint64(
                    cx: *mut root::JSContext,
                    num: u64,
                ) -> *mut root::JS::BigInt;
                #[link_name = "\u{1}_ZN2JS6detail14BigIntFromBoolEP9JSContextb"]
                pub fn BigIntFromBool(
                    cx: *mut root::JSContext,
                    b: bool,
                ) -> *mut root::JS::BigInt;
                #[link_name = "\u{1}_ZN2JS6detail13BigIntIsInt64EPKNS_6BigIntEPx"]
                pub fn BigIntIsInt64(
                    bi: *const root::JS::BigInt,
                    result: *mut i64,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS6detail14BigIntIsUint64EPKNS_6BigIntEPy"]
                pub fn BigIntIsUint64(
                    bi: *const root::JS::BigInt,
                    result: *mut u64,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS6detailL26ValueUpperExclPrimitiveTagE"]
                pub static ValueUpperExclPrimitiveTag: root::JSValueTag;
                #[link_name = "\u{1}_ZN2JS6detailL23ValueUpperInclNumberTagE"]
                pub static ValueUpperInclNumberTag: root::JSValueTag;
                #[link_name = "\u{1}_ZN2JS6detailL24ValueLowerInclGCThingTagE"]
                pub static ValueLowerInclGCThingTag: root::JSValueTag;
                /** Assert that we're not doing GC on cx, that we're in a request as
 needed, and that the compartments for cx and v are correct.
 Also check that GC would be safe at this point.*/
                #[link_name = "\u{1}_ZN2JS6detail22AssertArgumentsAreSaneEP9JSContextNS_6HandleINS_5ValueEEE"]
                pub fn AssertArgumentsAreSane(
                    cx: *mut root::JSContext,
                    v: root::JS::HandleValue,
                );
                #[link_name = "\u{1}_ZN2JS6detail11ComputeThisEP9JSContextPNS_5ValueENS_13MutableHandleIP8JSObjectEE"]
                pub fn ComputeThis(
                    cx: *mut root::JSContext,
                    vp: *mut root::JS::Value,
                    thisObject: root::JS::MutableHandleObject,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS6detail25CheckIsValidConstructibleERKNS_5ValueE"]
                pub fn CheckIsValidConstructible(v: *const root::JS::Value);
                /** SpiderMonkey's initialization status is tracked here, and it controls things
 that should happen only once across all runtimes.  It's an API requirement
 that JS_Init (and JS_ShutDown, if called) be called in a thread-aware
 manner, so this (internal -- embedders, don't use!) variable doesn't need to
 be atomic.*/
                #[link_name = "\u{1}_ZN2JS6detail16libraryInitStateE"]
                pub static mut libraryInitState: root::JS::detail::InitState;
                #[link_name = "\u{1}_ZN2JS6detail25InitWithFailureDiagnosticEbNS0_12FrontendOnlyE"]
                pub fn InitWithFailureDiagnostic(
                    isDebugBuild: bool,
                    frontendOnly: root::JS::detail::FrontendOnly,
                ) -> *const ::std::os::raw::c_char;
                #[link_name = "\u{1}_ZN2JS6detail26SetReservedSlotWithBarrierEP8JSObjectmRKNS_5ValueE"]
                pub fn SetReservedSlotWithBarrier(
                    obj: *mut root::JSObject,
                    slot: usize,
                    value: *const root::JS::Value,
                );
                #[link_name = "\u{1}_ZN2JS6detail19CallMethodIfWrappedEP9JSContextPFbNS_6HandleINS_5ValueEEEEPFbS2_RKNS_8CallArgsEESA_"]
                pub fn CallMethodIfWrapped(
                    cx: *mut root::JSContext,
                    test: root::JS::IsAcceptableThis,
                    impl_: root::JS::NativeImpl,
                    args: *const root::JS::CallArgs,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEP9JSContext"]
                pub fn ReportSourceTooLong(cx: *mut root::JSContext);
                #[link_name = "\u{1}_ZN2JS6detail19ReportSourceTooLongEPN2js15FrontendContextE"]
                pub fn ReportSourceTooLong1(fc: *mut root::JS::FrontendContext);
                #[link_name = "\u{1}_ZN2JS6detail24StringToLinearStringSlowEP9JSContextP8JSString"]
                pub fn StringToLinearStringSlow(
                    cx: *mut root::JSContext,
                    str_: *mut root::JSString,
                ) -> *mut root::JSLinearString;
            }
        }
        /// Vector of characters used for holding build ids.
        pub type BuildIdCharVector = [u32; 5usize];
        /** Return the buildId (represented as a sequence of characters) associated with
 the currently-executing build. If the JS engine is embedded such that a
 single cache entry can be observed by different compiled versions of the JS
 engine, it is critical that the buildId shall change for each new build of
 the JS engine.*/
        pub type BuildIdOp = ::std::option::Option<
            unsafe extern "C" fn(buildId: *mut root::JS::BuildIdCharVector) -> bool,
        >;
        /** Type representing a JS error or exception. At the moment this only
 "represents" an error in a rather abstract way.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Error {
            pub kind: root::JS::Error_ErrorKind,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Error_ErrorKind {
            Unspecified = 2,
            OOM = 4,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OOM {
            pub _base: root::JS::Error,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnusedZero {
            pub _address: u8,
        }
        pub type UnusedZero_StorageType = root::std::underlying_type_t;
        /** `Result` is intended to be the return type of JSAPI calls and internal
 functions that can run JS code or allocate memory from the JS GC heap. Such
 functions can:

 -   succeed, possibly returning a value;

 -   fail with a JS exception (out-of-memory falls in this category); or

 -   fail because JS execution was terminated, which occurs when e.g. a
     user kills a script from the "slow script" UI. This is also how we
     unwind the stack when the debugger forces the current function to
     return. JS `catch` blocks can't catch this kind of failure,
     and JS `finally` blocks don't execute.*/
        pub type Result = root::mozilla::Result;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TraceKind {
            Object = 0,
            BigInt = 1,
            String = 2,
            Symbol = 3,
            Shape = 4,
            BaseShape = 5,
            Null = 6,
            JitCode = 7,
            Script = 8,
            Scope = 9,
            RegExpShared = 10,
            GetterSetter = 11,
            PropMap = 12,
        }
        pub const OutOfLineTraceKindMask: usize = 7;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MapTypeToTraceKind {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IsBaseTraceType {
            pub _base: root::std::false_type,
        }
        #[repr(i8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RootKind {
            BaseShape = 0,
            JitCode = 1,
            Scope = 2,
            Object = 3,
            Script = 4,
            Shape = 5,
            String = 6,
            Symbol = 7,
            BigInt = 8,
            RegExpShared = 9,
            GetterSetter = 10,
            PropMap = 11,
            Id = 12,
            Value = 13,
            Traceable = 14,
            Limit = 15,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MapTypeToRootKind {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoEnterCycleCollection {
            pub runtime_: *mut root::JSRuntime,
        }
        impl AutoEnterCycleCollection {
            #[inline]
            pub unsafe fn new(rt: *mut root::JSRuntime) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoEnterCycleCollection_AutoEnterCycleCollection(
                    __bindgen_tmp.as_mut_ptr(),
                    rt,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoEnterCycleCollection_AutoEnterCycleCollection_destructor(self)
            }
        }
        pub mod shadow {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct String {
                pub flags_: usize,
                pub length_: u32,
                pub __bindgen_anon_1: root::JS::shadow::String__bindgen_ty_1,
                pub externalCallbacks: *const root::JSExternalStringCallbacks,
            }
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub union String__bindgen_ty_1 {
                pub nonInlineCharsLatin1: *const root::JS::Latin1Char,
                pub nonInlineCharsTwoByte: *const u16,
                pub inlineStorageLatin1: [root::JS::Latin1Char; 1usize],
                pub inlineStorageTwoByte: [u16; 1usize],
            }
            pub const String_ATOM_BIT: u32 = 8;
            pub const String_LINEAR_BIT: u32 = 16;
            pub const String_INLINE_CHARS_BIT: u32 = 64;
            pub const String_LATIN1_CHARS_BIT: u32 = 1024;
            pub const String_EXTERNAL_FLAGS: u32 = 272;
            pub const String_TYPE_FLAGS_MASK: u32 = 1016;
            pub const String_PERMANENT_ATOM_MASK: u32 = 264;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Symbol {
                pub _1: *mut ::std::os::raw::c_void,
                pub code_: u32,
            }
            pub const Symbol_WellKnownAPILimit: u32 = 2147483648;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Zone {
                pub runtime_: *mut root::JSRuntime,
                pub barrierTracer_: *mut root::JSTracer,
                pub needsIncrementalBarrier_: root::JS::shadow::Zone_BarrierState,
                pub gcState_: root::JS::shadow::Zone_GCState,
                pub kind_: root::JS::shadow::Zone_Kind,
            }
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_GCState {
                NoGC = 0,
                Prepare = 1,
                MarkBlackOnly = 2,
                MarkBlackAndGray = 3,
                Sweep = 4,
                Finished = 5,
                Compact = 6,
                VerifyPreBarriers = 7,
                Limit = 8,
            }
            /** Atomic<T> implementation for integral types.

 In addition to atomic store and load operations, compound assignment and
 increment/decrement operators are implemented which perform the
 corresponding read-modify-write operation atomically.  Finally, an atomic
 swap method is provided.*/
            pub type Zone_BarrierState = u32;
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Zone_Kind {
                NormalZone = 0,
                AtomsZone = 1,
                SystemZone = 2,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Realm {
                pub compartment_: *mut root::JS::Compartment,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BaseShape {
                pub clasp: *const root::JSClass,
                pub realm: *mut root::JS::Realm,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Shape {
                pub base: *mut root::JS::shadow::BaseShape,
                pub immutableFlags: u32,
            }
            #[repr(u8)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Shape_Kind {
                Shared = 1,
                Dictionary = 3,
                Proxy = 0,
                WasmGC = 2,
            }
            pub const Shape_KIND_SHIFT: u32 = 4;
            pub const Shape_KIND_MASK: u32 = 3;
            pub const Shape_FIXED_SLOTS_SHIFT: u32 = 6;
            pub const Shape_FIXED_SLOTS_MASK: u32 = 1984;
            /** This layout is shared by all native objects. For non-native objects, the
 shape may always be accessed safely, and other members may be as well,
 depending on the object's specific layout.*/
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Object {
                pub shape: *mut root::JS::shadow::Shape,
                pub padding_: u32,
                pub slots: *mut root::JS::Value,
                pub _1: *mut ::std::os::raw::c_void,
            }
            pub const Object_MAX_FIXED_SLOTS: usize = 16;
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Function {
                pub _base: root::JS::shadow::Object,
            }
            pub const Function_FlagsAndArgCountSlot: root::JS::shadow::Function__bindgen_ty_1 = Function__bindgen_ty_1::FlagsAndArgCountSlot;
            pub const Function_NativeFuncOrInterpretedEnvSlot: root::JS::shadow::Function__bindgen_ty_1 = Function__bindgen_ty_1::NativeFuncOrInterpretedEnvSlot;
            pub const Function_NativeJitInfoOrInterpretedScriptSlot: root::JS::shadow::Function__bindgen_ty_1 = Function__bindgen_ty_1::NativeJitInfoOrInterpretedScriptSlot;
            pub const Function_AtomSlot: root::JS::shadow::Function__bindgen_ty_1 = Function__bindgen_ty_1::AtomSlot;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Function__bindgen_ty_1 {
                FlagsAndArgCountSlot = 0,
                NativeFuncOrInterpretedEnvSlot = 1,
                NativeJitInfoOrInterpretedScriptSlot = 2,
                AtomSlot = 3,
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum HeapState {
            Idle = 0,
            Tracing = 1,
            MajorCollecting = 2,
            MinorCollecting = 3,
            CycleCollecting = 4,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StackKind {
            StackForSystemCode = 0,
            StackForTrustedScript = 1,
            StackForUntrustedScript = 2,
            StackKindCount = 3,
        }
        pub const DefaultNurseryMaxBytes: u32 = 67108864;
        pub const DefaultHeapMaxBytes: u32 = 33554432;
        /** A GC pointer, tagged with the trace kind.

 In general, a GC pointer should be stored with an exact type. This class
 is for use when that is not possible because a single pointer must point
 to several kinds of GC thing.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCCellPtr {
            pub ptr: usize,
        }
        impl GCCellPtr {
            #[inline]
            pub unsafe fn new(v: *const root::JS::Value) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                GCCellPtr_GCCellPtr(__bindgen_tmp.as_mut_ptr(), v);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TracerKind {
            Marking = 0,
            Tenuring = 1,
            Moving = 2,
            ClearEdges = 3,
            Sweeping = 4,
            MinorSweeping = 5,
            Barrier = 6,
            Callback = 7,
            UnmarkGray = 8,
            VerifyTraceProtoAndIface = 9,
            CompartmentCheck = 10,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakMapTraceAction {
            /** Do not trace into weak map keys or values during traversal. Users must
 handle weak maps manually.*/
            Skip = 0,
            /** Do true ephemeron marking with a weak key lookup marking phase. This is
 the default for GCMarker.*/
            Expand = 1,
            /** Trace through to all values, irrespective of whether the keys are live
 or not. Used for non-marking tracers.*/
            TraceValues = 2,
            /** Trace through to all keys and values, irrespective of whether the keys
 are live or not. Used for non-marking tracers.*/
            TraceKeysAndValues = 3,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WeakEdgeTraceAction {
            Skip = 0,
            Trace = 1,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TraceOptions {
            pub weakMapAction: root::JS::WeakMapTraceAction,
            pub weakEdgeAction: root::JS::WeakEdgeTraceAction,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TracingContext {
            pub index_: usize,
            pub functor_: *mut root::JS::TracingContext_Functor,
        }
        #[repr(C)]
        pub struct TracingContext_Functor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TracingContext_Functor {
            pub vtable_: *const TracingContext_Functor__bindgen_vtable,
        }
        pub const TracingContext_InvalidIndex: usize = 4294967295;
        impl TracingContext {
            #[inline]
            pub unsafe fn getEdgeName(
                &mut self,
                name: *const ::std::os::raw::c_char,
                buffer: *mut ::std::os::raw::c_char,
                bufferSize: usize,
            ) {
                TracingContext_getEdgeName(self, name, buffer, bufferSize)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CallbackTracer {
            pub _base: root::js::GenericTracerImpl,
        }
        impl CallbackTracer {
            #[inline]
            pub unsafe fn new(
                cx: *mut root::JSContext,
                kind: root::JS::TracerKind,
                options: root::JS::TraceOptions,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CallbackTracer_CallbackTracer(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                    kind,
                    options,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoTracingIndex {
            pub trc_: *mut root::JSTracer,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoTracingDetails {
            pub trc_: *mut root::JSTracer,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoClearTracingContext {
            pub trc_: *mut root::JSTracer,
            pub prev_: root::JS::TracingContext,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StructGCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct IgnoreGCPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCPointerPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NonGCPointerPolicy {
            pub _address: u8,
        }
        impl root::JS::ProfilingCategoryPair {
            pub const LAST: root::JS::ProfilingCategoryPair = ProfilingCategoryPair::SANDBOX;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategoryPair {
            IDLE = 0,
            OTHER = 1,
            OTHER_PreferenceRead = 2,
            OTHER_Profiling = 3,
            TEST = 4,
            LAYOUT = 5,
            LAYOUT_FrameConstruction = 6,
            LAYOUT_Reflow = 7,
            LAYOUT_CSSParsing = 8,
            LAYOUT_SelectorQuery = 9,
            LAYOUT_StyleComputation = 10,
            LAYOUT_Destroy = 11,
            LAYOUT_Printing = 12,
            JS = 13,
            JS_Parsing = 14,
            JS_BaselineCompilation = 15,
            JS_IonCompilation = 16,
            JS_Interpreter = 17,
            JS_BaselineInterpret = 18,
            JS_Baseline = 19,
            JS_IonMonkey = 20,
            JS_Builtin = 21,
            JS_WasmIon = 22,
            JS_WasmBaseline = 23,
            JS_WasmOther = 24,
            GCCC = 25,
            GCCC_MinorGC = 26,
            GCCC_MajorGC = 27,
            GCCC_MajorGC_Mark = 28,
            GCCC_MajorGC_Sweep = 29,
            GCCC_MajorGC_Compact = 30,
            GCCC_UnmarkGray = 31,
            GCCC_Barrier = 32,
            GCCC_FreeSnowWhite = 33,
            GCCC_BuildGraph = 34,
            GCCC_ScanRoots = 35,
            GCCC_CollectWhite = 36,
            GCCC_Finalize = 37,
            NETWORK = 38,
            GRAPHICS = 39,
            GRAPHICS_DisplayListBuilding = 40,
            GRAPHICS_DisplayListMerging = 41,
            GRAPHICS_LayerBuilding = 42,
            GRAPHICS_TileAllocation = 43,
            GRAPHICS_WRDisplayList = 44,
            GRAPHICS_Rasterization = 45,
            GRAPHICS_FlushingAsyncPaints = 46,
            GRAPHICS_ImageDecoding = 47,
            DOM = 48,
            JAVA_ANDROID = 49,
            JAVA_ANDROIDX = 50,
            JAVA_LANGUAGE = 51,
            JAVA_MOZILLA = 52,
            JAVA_KOTLIN = 53,
            JAVA_BLOCKED = 54,
            IPC = 55,
            MEDIA = 56,
            MEDIA_CUBEB = 57,
            MEDIA_PLAYBACK = 58,
            MEDIA_RT = 59,
            A11Y = 60,
            PROFILER = 61,
            TIMER = 62,
            REMOTE_PROTOCOL = 63,
            SANDBOX = 64,
            COUNT = 65,
        }
        impl root::JS::ProfilingCategory {
            pub const LAST: root::JS::ProfilingCategory = ProfilingCategory::SANDBOX;
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ProfilingCategory {
            IDLE = 0,
            OTHER = 1,
            TEST = 2,
            LAYOUT = 3,
            JS = 4,
            GCCC = 5,
            NETWORK = 6,
            GRAPHICS = 7,
            DOM = 8,
            JAVA_ANDROID = 9,
            JAVA_ANDROIDX = 10,
            JAVA_LANGUAGE = 11,
            JAVA_MOZILLA = 12,
            JAVA_KOTLIN = 13,
            JAVA_BLOCKED = 14,
            IPC = 15,
            MEDIA = 16,
            A11Y = 17,
            PROFILER = 18,
            TIMER = 19,
            REMOTE_PROTOCOL = 20,
            SANDBOX = 21,
            COUNT = 22,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProfilingCategoryPairInfo {
            pub mCategory: root::JS::ProfilingCategory,
            pub mSubcategoryIndex: u32,
            pub mLabel: *const ::std::os::raw::c_char,
        }
        pub type RegisterThreadCallback = ::std::option::Option<
            unsafe extern "C" fn(
                threadName: *const ::std::os::raw::c_char,
                stackBase: *mut ::std::os::raw::c_void,
            ) -> *mut root::ProfilingStack,
        >;
        pub type UnregisterThreadCallback = ::std::option::Option<
            unsafe extern "C" fn(),
        >;
        pub type DestroyRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(
                gcx: *mut root::JS::GCContext,
                realm: *mut root::JS::Realm,
            ),
        >;
        pub type RealmNameCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                realm: *mut root::JS::Realm,
                buf: *mut ::std::os::raw::c_char,
                bufsize: usize,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum RuntimeCode {
            JS = 0,
            WASM = 1,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoHoldPrincipals {
            pub cx_: *mut root::JSContext,
            pub principals_: *mut root::JSPrincipals,
        }
        pub type NativeStackSize = usize;
        pub type NativeStackBase = usize;
        pub type NativeStackLimit = usize;
        pub const NativeStackLimitMin: root::JS::NativeStackLimit = 4294967295;
        pub const NativeStackLimitMax: root::JS::NativeStackLimit = 0;
        pub const WASINativeStackLimit: root::JS::NativeStackLimit = 1024;
        /// Capture all frames.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct AllFrames {
            pub _address: u8,
        }
        /// Capture at most this many frames.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MaxFrames {
            pub maxFrames: u32,
        }
        /** Capture the first frame with the given principals. By default, do not
 consider self-hosted frames with the given principals as satisfying the stack
 capture.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct FirstSubsumedFrame {
            pub cx: *mut root::JSContext,
            pub principals: *mut root::JSPrincipals,
            pub ignoreSelfHosted: bool,
        }
        impl FirstSubsumedFrame {
            #[inline]
            pub unsafe fn new(
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                FirstSubsumedFrame_FirstSubsumedFrame(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                    ignoreSelfHostedFrames,
                );
                __bindgen_tmp.assume_init()
            }
        }
        /** # mozilla::Variant

 A variant / tagged union / heterogenous disjoint union / sum-type template
 class. Similar in concept to (but not derived from) `boost::variant`.

 Sometimes, you may wish to use a C union with non-POD types. However, this is
 forbidden in C++ because it is not clear which type in the union should have
 its constructor and destructor run on creation and deletion
 respectively. This is the problem that `mozilla::Variant` solves.

 ## Usage

 A `mozilla::Variant` instance is constructed (via move or copy) from one of
 its variant types (ignoring const and references). It does *not* support
 construction from subclasses of variant types or types that coerce to one of
 the variant types.

     Variant<char, uint32_t> v1('a');
     Variant<UniquePtr<A>, B, C> v2(MakeUnique<A>());
     Variant<bool, char> v3(VariantType<char>, 0); // disambiguation needed
     Variant<int, int> v4(VariantIndex<1>, 0); // 2nd int

 Because specifying the full type of a Variant value is often verbose,
 there are two easier ways to construct values:

 A. AsVariant() can be used to construct a Variant value using type inference
 in contexts such as expressions or when returning values from functions.
 Because AsVariant() must copy or move the value into a temporary and this
 cannot necessarily be elided by the compiler, it's mostly appropriate only
 for use with primitive or very small types.

     Variant<char, uint32_t> Foo() { return AsVariant('x'); }
     // ...
     Variant<char, uint32_t> v1 = Foo();  // v1 holds char('x').

 B. Brace-construction with VariantType or VariantIndex; this also allows
 in-place construction with any number of arguments.

     struct AB { AB(int, int){...} };
     static Variant<AB, bool> foo()
     {
       return {VariantIndex<0>{}, 1, 2};
     }
     // ...
     Variant<AB, bool> v0 = Foo();  // v0 holds AB(1,2).

 All access to the contained value goes through type-safe accessors.
 Either the stored type, or the type index may be provided.

     void
     Foo(Variant<A, B, C> v)
     {
       if (v.is<A>()) {
         A& ref = v.as<A>();
         ...
       } else (v.is<1>()) { // Instead of v.is<B>.
         ...
       } else {
         ...
       }
     }

 In some situation, a Variant may be constructed from templated types, in
 which case it is possible that the same type could be given multiple times by
 an external developer. Or seemingly-different types could be aliases.
 In this case, repeated types can only be accessed through their index, to
 prevent ambiguous access by type.

    // Bad!
    template <typename T>
    struct ResultOrError
    {
      Variant<T, int> m;
      ResultOrError() : m(int(0)) {} // Error '0' by default
      ResultOrError(const T& r) : m(r) {}
      bool IsResult() const { return m.is<T>(); }
      bool IsError() const { return m.is<int>(); }
    };
    // Now instantiante with the result being an int too:
    ResultOrError<int> myResult(123); // Fail!
    // In Variant<int, int>, which 'int' are we refering to, from inside
    // ResultOrError functions?

    // Good!
    template <typename T>
    struct ResultOrError
    {
      Variant<T, int> m;
      ResultOrError() : m(VariantIndex<1>{}, 0) {} // Error '0' by default
      ResultOrError(const T& r) : m(VariantIndex<0>{}, r) {}
      bool IsResult() const { return m.is<0>(); } // 0 -> T
      bool IsError() const { return m.is<1>(); } // 1 -> int
    };
    // Now instantiante with the result being an int too:
    ResultOrError<int> myResult(123); // It now works!

 Attempting to use the contained value as type `T1` when the `Variant`
 instance contains a value of type `T2` causes an assertion failure.

     A a;
     Variant<A, B, C> v(a);
     v.as<B>(); // <--- Assertion failure!

 Trying to use a `Variant<Ts...>` instance as some type `U` that is not a
 member of the set of `Ts...` is a compiler error.

     A a;
     Variant<A, B, C> v(a);
     v.as<SomeRandomType>(); // <--- Compiler error!

 Additionally, you can turn a `Variant` that `is<T>` into a `T` by moving it
 out of the containing `Variant` instance with the `extract<T>` method:

     Variant<UniquePtr<A>, B, C> v(MakeUnique<A>());
     auto ptr = v.extract<UniquePtr<A>>();

 Finally, you can exhaustively match on the contained variant and branch into
 different code paths depending on which type is contained. This is preferred
 to manually checking every variant type T with is<T>() because it provides
 compile-time checking that you handled every type, rather than runtime
 assertion failures.

     // Bad!
     char* foo(Variant<A, B, C, D>& v) {
       if (v.is<A>()) {
         return ...;
       } else if (v.is<B>()) {
         return ...;
       } else {
         return doSomething(v.as<C>()); // Forgot about case D!
       }
     }

     // Instead, a single function object (that can deal with all possible
     // options) may be provided:
     struct FooMatcher
     {
       // The return type of all matchers must be identical.
       char* operator()(A& a) { ... }
       char* operator()(B& b) { ... }
       char* operator()(C& c) { ... }
       char* operator()(D& d) { ... } // Compile-time error to forget D!
     }
     char* foo(Variant<A, B, C, D>& v) {
       return v.match(FooMatcher());
     }

     // In some situations, a single generic lambda may also be appropriate:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](auto&) {...});
     }

     // Alternatively, multiple function objects may be provided, each one
     // corresponding to an option, in the same order:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](A&) { ... },
                      [](B&) { ... },
                      [](C&) { ... },
                      [](D&) { ... });
     }

     // In rare cases, the index of the currently-active alternative is
     // needed, it may be obtained by adding a first parameter in the matcner
     // callback, which will receive the index in its most compact type (just
     // use `size_t` if the exact type is not important), e.g.:
     char* foo(Variant<A, B, C, D>& v) {
       return v.match([](auto aIndex, auto& aAlternative) {...});
       // --OR--
       return v.match([](size_t aIndex, auto& aAlternative) {...});
     }

 ## Examples

 A tree is either an empty leaf, or a node with a value and two children:

     struct Leaf { };

     template<typename T>
     struct Node
     {
       T value;
       Tree<T>* left;
       Tree<T>* right;
     };

     template<typename T>
     using Tree = Variant<Leaf, Node<T>>;

 A copy-on-write string is either a non-owning reference to some existing
 string, or an owning reference to our copy:

     class CopyOnWriteString
     {
       Variant<const char*, UniquePtr<char[]>> string;

       ...
     };

 Because Variant must be aligned suitable to hold any value stored within it,
 and because |alignas| requirements don't affect platform ABI with respect to
 how parameters are laid out in memory, Variant can't be used as the type of a
 function parameter.  Pass Variant to functions by pointer or reference
 instead.*/
        pub type StackCapture = [u32; 4usize];
        /** SafelyInitialized<T>::create() creates a safely-initialized |T|, suitable for
 use as a default value in situations requiring a safe but arbitrary |T|
 value. Implemented as a static method of a struct to allow partial
 specialization for subclasses via the Enable template parameter.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct SafelyInitialized {
            pub _address: u8,
        }
        pub type Heap_ElementType<T> = T;
        /** The TenuredHeap<T> class is similar to the Heap<T> class above in that it
 encapsulates the GC concerns of an on-heap reference to a JS object. However,
 it has two important differences:

  1) Pointers which are statically known to only reference "tenured" objects
     can avoid the extra overhead of SpiderMonkey's post write barriers.

  2) Objects in the "tenured" heap have stronger alignment restrictions than
     those in the "nursery", so it is possible to store flags in the lower
     bits of pointers known to be tenured. TenuredHeap wraps a normal tagged
     pointer with a nice API for accessing the flag bits and adds various
     assertions to ensure that it is not mis-used.

 GC things are said to be "tenured" when they are located in the long-lived
 heap: e.g. they have gained tenure as an object by surviving past at least
 one GC. For performance, SpiderMonkey allocates some things which are known
 to normally be long lived directly into the tenured generation; for example,
 global objects. Additionally, SpiderMonkey does not visit individual objects
 when deleting non-tenured objects, so object with finalizers are also always
 tenured; for instance, this includes most DOM objects.

 The considerations to keep in mind when using a TenuredHeap<T> vs a normal
 Heap<T> are:

  - It is invalid for a TenuredHeap<T> to refer to a non-tenured thing.
  - It is however valid for a Heap<T> to refer to a tenured thing.
  - It is not possible to store flag bits in a Heap<T>.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct TenuredHeap {
            pub bits: usize,
        }
        pub type TenuredHeap_ElementType<T> = T;
        pub const TenuredHeap_maskBits: root::JS::TenuredHeap__bindgen_ty_1 = TenuredHeap__bindgen_ty_1::maskBits;
        pub const TenuredHeap_flagsMask: root::JS::TenuredHeap__bindgen_ty_1 = TenuredHeap__bindgen_ty_1::maskBits;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TenuredHeap__bindgen_ty_1 {
            maskBits = 0,
        }
        /** Reference to a T that has been rooted elsewhere. This is most useful
 as a parameter type, which guarantees that the T lvalue is properly
 rooted. See "Move GC Stack Rooting" above.

 If you want to add additional methods to Handle for a specific
 specialization, define a HandleOperations<T> specialization containing them.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Handle<T> {
            pub ptr: *const T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type Handle_ElementType<T> = T;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_Disambiguator {
            DeliberatelyChoosingThisOverload = 0,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Handle_CallerIdentity {
            ImUsingThisOnlyInFromFromMarkedLocation = 0,
        }
        /** Similar to a handle, but the underlying storage can be changed. This is
 useful for outparams.

 If you want to add additional methods to MutableHandle for a specific
 specialization, define a MutableHandleOperations<T> specialization containing
 them.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandle<T> {
            pub ptr: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type MutableHandle_ElementType<T> = T;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoGCRooterKind {
            WrapperVector = 0,
            Wrapper = 1,
            Custom = 2,
            Limit = 3,
        }
        /** EnumeratedArray is a fixed-size array container for use when an
 array is indexed by a specific enum class.

 This provides type safety by guarding at compile time against accidentally
 indexing such arrays with unrelated values. This also removes the need
 for manual casting when using a typed enum value to index arrays.

 Aside from the typing of indices, EnumeratedArray is similar to Array.

 Example:

   enum class AnimalSpecies {
     Cow,
     Sheep,
     Count
   };

   EnumeratedArray<AnimalSpecies, int, AnimalSpecies::Count> headCount;

   headCount[AnimalSpecies::Cow] = 17;
   headCount[AnimalSpecies::Sheep] = 30;

 If the enum class has contiguous values and provides a specialization of
 mozilla::MaxContiguousEnumValue then the size will be calculated as the max
 value + 1.*/
        pub type RootedListHeads = [u32; 15usize];
        /** EnumeratedArray is a fixed-size array container for use when an
 array is indexed by a specific enum class.

 This provides type safety by guarding at compile time against accidentally
 indexing such arrays with unrelated values. This also removes the need
 for manual casting when using a typed enum value to index arrays.

 Aside from the typing of indices, EnumeratedArray is similar to Array.

 Example:

   enum class AnimalSpecies {
     Cow,
     Sheep,
     Count
   };

   EnumeratedArray<AnimalSpecies, int, AnimalSpecies::Count> headCount;

   headCount[AnimalSpecies::Cow] = 17;
   headCount[AnimalSpecies::Sheep] = 30;

 If the enum class has contiguous values and provides a specialization of
 mozilla::MaxContiguousEnumValue then the size will be calculated as the max
 value + 1.*/
        pub type AutoRooterListHeads = [u32; 3usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RootingContext {
            pub stackRoots_: root::JS::RootedListHeads,
            pub autoGCRooters_: root::JS::AutoRooterListHeads,
            pub geckoProfiler_: root::js::GeckoProfilerThread,
            pub nursery_: *mut root::js::Nursery,
            pub zone_: *mut root::JS::Zone,
            pub realm_: *mut root::JS::Realm,
            pub nativeStackLimit: [root::JS::NativeStackLimit; 3usize],
            pub wasiRecursionDepth: u32,
        }
        pub const RootingContext_wasiRecursionDepthLimit: u32 = 350;
        impl RootingContext {
            #[inline]
            pub unsafe fn traceStackRoots(&mut self, trc: *mut root::JSTracer) {
                RootingContext_traceStackRoots(self, trc)
            }
            #[inline]
            pub unsafe fn traceAllGCRooters(&mut self, trc: *mut root::JSTracer) {
                RootingContext_traceAllGCRooters(self, trc)
            }
            #[inline]
            pub unsafe fn traceWrapperGCRooters(&mut self, trc: *mut root::JSTracer) {
                RootingContext_traceWrapperGCRooters(self, trc)
            }
            #[inline]
            pub unsafe fn traceGCRooterList(
                trc: *mut root::JSTracer,
                head: *mut root::JS::AutoGCRooter,
            ) {
                RootingContext_traceGCRooterList(trc, head)
            }
            #[inline]
            pub unsafe fn checkNoGCRooters(&mut self) {
                RootingContext_checkNoGCRooters(self)
            }
            #[inline]
            pub unsafe fn new(nursery: *mut root::js::Nursery) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                RootingContext_RootingContext(__bindgen_tmp.as_mut_ptr(), nursery);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoGCRooter {
            pub down: *mut root::JS::AutoGCRooter,
            pub stackTop: *mut *mut root::JS::AutoGCRooter,
            pub kind_: root::JS::AutoGCRooter_Kind,
        }
        pub use self::super::super::root::JS::AutoGCRooterKind as AutoGCRooter_Kind;
        impl AutoGCRooter {
            #[inline]
            pub unsafe fn trace(&mut self, trc: *mut root::JSTracer) {
                AutoGCRooter_trace(self, trc)
            }
        }
        #[repr(C)]
        pub struct CustomAutoRooter__bindgen_vtable(::std::os::raw::c_void);
        /** Custom rooting behavior for internal and external clients.

 Deprecated. Where possible, use Rooted<> instead.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct CustomAutoRooter {
            pub vtable_: *const CustomAutoRooter__bindgen_vtable,
            pub _base: root::JS::AutoGCRooter,
        }
        pub type Rooted_ElementType<T> = T;
        /** A copyable, assignable global GC root type with arbitrary lifetime, an
 infallible constructor, and automatic unrooting on destruction.

 These roots can be used in heap-allocated data structures, so they are not
 associated with any particular JSContext or stack. They are registered with
 the JSRuntime itself, without locking. Initialization may take place on
 construction, or in two phases if the no-argument constructor is called
 followed by init().

 Note that you must not use an PersistentRooted in an object owned by a JS
 object:

 Whenever one object whose lifetime is decided by the GC refers to another
 such object, that edge must be traced only if the owning JS object is traced.
 This applies not only to JS objects (which obviously are managed by the GC)
 but also to C++ objects owned by JS objects.

 If you put a PersistentRooted in such a C++ object, that is almost certainly
 a leak. When a GC begins, the referent of the PersistentRooted is treated as
 live, unconditionally (because a PersistentRooted is a *root*), even if the
 JS object that owns it is unreachable. If there is any path from that
 referent back to the JS object, then the C++ object containing the
 PersistentRooted will not be destructed, and the whole blob of objects will
 not be freed, even if there are no references to them from the outside.

 In the context of Firefox, this is a severe restriction: almost everything in
 Firefox is owned by some JS object or another, so using PersistentRooted in
 such objects would introduce leaks. For these kinds of edges, Heap<T> or
 TenuredHeap<T> would be better types. It's up to the implementor of the type
 containing Heap<T> or TenuredHeap<T> members to make sure their referents get
 marked when the object itself is marked.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PersistentRooted {
            pub _address: u8,
        }
        pub type PersistentRooted_ElementType = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Latin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type Latin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type Latin1Chars_CharT = root::JS::Latin1Char;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstLatin1Chars {
            pub _base: root::mozilla::Range<root::JS::Latin1Char>,
        }
        pub type ConstLatin1Chars_Base = root::mozilla::Range<root::JS::Latin1Char>;
        pub type ConstLatin1Chars_CharT = root::JS::Latin1Char;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Latin1CharsZ {
            pub _base: root::mozilla::RangedPtr<root::JS::Latin1Char>,
        }
        pub type Latin1CharsZ_Base = root::mozilla::RangedPtr<root::JS::Latin1Char>;
        pub type Latin1CharsZ_CharT = root::JS::Latin1Char;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UTF8Chars {
            pub _base: root::mozilla::Range<::std::os::raw::c_uchar>,
        }
        pub type UTF8Chars_Base = root::mozilla::Range<::std::os::raw::c_uchar>;
        pub type UTF8Chars_CharT = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UTF8CharsZ {
            pub _base: root::mozilla::RangedPtr<::std::os::raw::c_uchar>,
        }
        pub type UTF8CharsZ_Base = root::mozilla::RangedPtr<::std::os::raw::c_uchar>;
        pub type UTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstUTF8CharsZ {
            pub data_: *const ::std::os::raw::c_char,
        }
        pub type ConstUTF8CharsZ_CharT = ::std::os::raw::c_uchar;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type TwoByteChars_Base = root::mozilla::Range<u16>;
        pub type TwoByteChars_CharT = u16;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TwoByteCharsZ {
            pub _base: root::mozilla::RangedPtr<u16>,
        }
        pub type TwoByteCharsZ_Base = root::mozilla::RangedPtr<u16>;
        pub type TwoByteCharsZ_CharT = u16;
        pub type ConstCharPtr = root::mozilla::RangedPtr<u16>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ConstTwoByteChars {
            pub _base: root::mozilla::Range<u16>,
        }
        pub type ConstTwoByteChars_Base = root::mozilla::Range<u16>;
        pub type ConstTwoByteChars_CharT = u16;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SmallestEncoding {
            ASCII = 0,
            Latin1 = 1,
            UTF16 = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WasmFunctionIndex {
            pub value_: u32,
        }
        pub const WasmFunctionIndex_Limit: u32 = 1073741823;
        pub const WasmFunctionIndex_DefaultBinarySourceColumnNumberOneOrigin: u32 = 1;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberOffset {
            pub value_: i32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberUnsignedOffset {
            pub value_: u32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct LimitedColumnNumberOneOrigin {
            pub _base: u32,
        }
        pub type LimitedColumnNumberOneOrigin_Base = u32;
        pub const LimitedColumnNumberOneOrigin_Limit: u32 = 1073741823;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ColumnNumberOneOrigin {
            pub _base: u32,
        }
        pub type ColumnNumberOneOrigin_Base = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TaggedColumnNumberOneOrigin {
            pub value_: u32,
        }
        pub const TaggedColumnNumberOneOrigin_WasmFunctionTag: u32 = 2147483648;
        pub type FrontendContext = root::js::FrontendContext;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AsmJSOption {
            Enabled = 0,
            DisabledByAsmJSPref = 1,
            DisabledByLinker = 2,
            DisabledByNoWasmCompiler = 3,
            DisabledByDebugger = 4,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DelazificationOption {
            OnDemandOnly = 0,
            CheckConcurrentWithOnDemand = 1,
            ConcurrentDepthFirst = 2,
            ConcurrentLargeFirst = 3,
            ParseEverythingEagerly = 4,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PrefableCompileOptions {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub asmJSOption_: root::JS::AsmJSOption,
        }
        impl PrefableCompileOptions {
            #[inline]
            pub fn importAttributes_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_importAttributes_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn importAttributesAssertSyntax_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_importAttributesAssertSyntax_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn sourcePragmas_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_sourcePragmas_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnAsmJSValidationFailure_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_throwOnAsmJSValidationFailure_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                importAttributes_: bool,
                importAttributesAssertSyntax_: bool,
                sourcePragmas_: bool,
                throwOnAsmJSValidationFailure_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<
                    [u8; 1usize],
                > = Default::default();
                __bindgen_bitfield_unit
                    .set(
                        0usize,
                        1u8,
                        {
                            let importAttributes_: u8 = unsafe {
                                ::std::mem::transmute(importAttributes_)
                            };
                            importAttributes_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        1usize,
                        1u8,
                        {
                            let importAttributesAssertSyntax_: u8 = unsafe {
                                ::std::mem::transmute(importAttributesAssertSyntax_)
                            };
                            importAttributesAssertSyntax_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        2usize,
                        1u8,
                        {
                            let sourcePragmas_: u8 = unsafe {
                                ::std::mem::transmute(sourcePragmas_)
                            };
                            sourcePragmas_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        3usize,
                        1u8,
                        {
                            let throwOnAsmJSValidationFailure_: u8 = unsafe {
                                ::std::mem::transmute(throwOnAsmJSValidationFailure_)
                            };
                            throwOnAsmJSValidationFailure_ as u64
                        },
                    );
                __bindgen_bitfield_unit
            }
        }
        /** The common base class for the CompileOptions hierarchy.

 Use this in code that needs to propagate compile options from one
 compilation unit to another.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TransitiveCompileOptions {
            pub filename_: root::JS::ConstUTF8CharsZ,
            pub introducerFilename_: root::JS::ConstUTF8CharsZ,
            pub sourceMapURL_: *const u16,
            /** The Web Platform allows scripts to be loaded from arbitrary cross-origin
 sources. This allows an attack by which a malicious website loads a
 sensitive file (say, a bank statement) cross-origin (using the user's
 cookies), and sniffs the generated syntax errors (via a window.onerror
 handler) for juicy morsels of its contents.

 To counter this attack, HTML5 specifies that script errors should be
 sanitized ("muted") when the script is not same-origin with the global
 for which it is loaded. Callers should set this flag for cross-origin
 scripts, and it will be propagated appropriately to child scripts and
 passed back in JSErrorReports.*/
            pub mutedErrors_: bool,
            pub forceStrictMode_: bool,
            pub alwaysUseFdlibm_: bool,
            pub skipFilenameValidation_: bool,
            pub hideScriptFromDebugger_: bool,
            pub deferDebugMetadata_: bool,
            pub eagerDelazificationStrategy_: root::JS::DelazificationOption,
            pub selfHostingMode: bool,
            pub discardSource: bool,
            pub sourceIsLazy: bool,
            pub allowHTMLComments: bool,
            pub nonSyntacticScope: bool,
            pub topLevelAwait: bool,
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub deoptimizeModuleGlobalVars: bool,
            pub prefableOptions_: root::JS::PrefableCompileOptions,
            /** |introductionType| is a statically allocated C string. See JSScript.h
 for more information.*/
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: ::std::os::raw::c_uint,
            pub introductionOffset: u32,
            pub hasIntroductionInfo: bool,
        }
        impl TransitiveCompileOptions {
            #[inline]
            pub unsafe fn copyPODTransitiveOptions(
                &mut self,
                rhs: *const root::JS::TransitiveCompileOptions,
            ) {
                TransitiveCompileOptions_copyPODTransitiveOptions(self, rhs)
            }
        }
        /** The class representing a full set of compile options.

 Use this in code that only needs to access compilation options created
 elsewhere, like the compiler.  Don't instantiate this class (the constructor
 is protected anyway); instead, create instances only of the derived classes:
 CompileOptions and OwningCompileOptions.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReadOnlyCompileOptions {
            pub _base: root::JS::TransitiveCompileOptions,
            pub lineno: u32,
            pub column: root::JS::ColumnNumberOneOrigin,
            pub scriptSourceOffset: ::std::os::raw::c_uint,
            pub isRunOnce: bool,
            pub noScriptRval: bool,
        }
        impl ReadOnlyCompileOptions {
            #[inline]
            pub unsafe fn copyPODNonTransitiveOptions(
                &mut self,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            ) {
                ReadOnlyCompileOptions_copyPODNonTransitiveOptions(self, rhs)
            }
        }
        /** Compilation options, with dynamic lifetime. An instance of this type
 makes a copy of / holds / roots all dynamically allocated resources
 (principals; elements; strings) that it refers to. Its destructor frees
 / drops / unroots them. This is heavier than CompileOptions, below, but
 unlike CompileOptions, it can outlive any given stack frame.

 Note that this *roots* any JS values it refers to - they're live
 unconditionally. Thus, instances of this type can't be owned, directly
 or indirectly, by a JavaScript object: if any value that this roots ever
 comes to refer to the object that owns this, then the whole cycle, and
 anything else it entrains, will never be freed.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OwningCompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct OwningCompileOptions_ForFrontendContext {
            pub _address: u8,
        }
        impl OwningCompileOptions {
            #[inline]
            pub unsafe fn copy(
                &mut self,
                cx: *mut root::JSContext,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            ) -> bool {
                OwningCompileOptions_copy(self, cx, rhs)
            }
            #[inline]
            pub unsafe fn copy1(
                &mut self,
                fc: *mut root::JS::FrontendContext,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            ) -> bool {
                OwningCompileOptions_copy1(self, fc, rhs)
            }
            #[inline]
            pub unsafe fn steal(&mut self, rhs: *mut root::JS::OwningCompileOptions) {
                OwningCompileOptions_steal(self, rhs)
            }
            #[inline]
            pub unsafe fn steal1(&mut self, rhs: *mut root::JS::OwningDecodeOptions) {
                OwningCompileOptions_steal1(self, rhs)
            }
            #[inline]
            pub unsafe fn sizeOfExcludingThis(
                &self,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize {
                OwningCompileOptions_sizeOfExcludingThis(self, mallocSizeOf)
            }
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OwningCompileOptions_OwningCompileOptions(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                OwningCompileOptions_OwningCompileOptions_destructor(self)
            }
        }
        /** Compilation options stored on the stack. An instance of this type
 simply holds references to dynamically allocated resources (element;
 filename; source map URL) that are owned by something else. If you
 create an instance of this type, it's up to you to guarantee that
 everything you store in it will outlive it.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CompileOptions {
            pub _base: root::JS::ReadOnlyCompileOptions,
        }
        impl CompileOptions {
            #[inline]
            pub unsafe fn setIntroductionInfoToCaller(
                &mut self,
                cx: *mut root::JSContext,
                introductionType: *const ::std::os::raw::c_char,
                introductionScript: root::JS::MutableHandle<*mut root::JSScript>,
            ) -> *mut root::JS::CompileOptions {
                CompileOptions_setIntroductionInfoToCaller(
                    self,
                    cx,
                    introductionType,
                    introductionScript,
                )
            }
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CompileOptions_CompileOptions(__bindgen_tmp.as_mut_ptr(), cx);
                __bindgen_tmp.assume_init()
            }
        }
        /// Subset of CompileOptions fields used while instantiating Stencils.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct InstantiateOptions {
            pub skipFilenameValidation: bool,
            pub hideScriptFromDebugger: bool,
            pub deferDebugMetadata: bool,
        }
        /// Subset of CompileOptions fields used while decoding Stencils.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReadOnlyDecodeOptions {
            pub borrowBuffer: bool,
            pub usePinnedBytecode: bool,
            pub introducerFilename_: root::JS::ConstUTF8CharsZ,
            pub introductionType: *const ::std::os::raw::c_char,
            pub introductionLineno: u32,
            pub introductionOffset: u32,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DecodeOptions {
            pub _base: root::JS::ReadOnlyDecodeOptions,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OwningDecodeOptions {
            pub _base: root::JS::ReadOnlyDecodeOptions,
        }
        impl OwningDecodeOptions {
            #[inline]
            pub unsafe fn copy(
                &mut self,
                maybeFc: *mut root::JS::FrontendContext,
                rhs: *const root::JS::ReadOnlyDecodeOptions,
            ) -> bool {
                OwningDecodeOptions_copy(self, maybeFc, rhs)
            }
            #[inline]
            pub unsafe fn infallibleCopy(
                &mut self,
                rhs: *const root::JS::ReadOnlyDecodeOptions,
            ) {
                OwningDecodeOptions_infallibleCopy(self, rhs)
            }
            #[inline]
            pub unsafe fn sizeOfExcludingThis(
                &self,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize {
                OwningDecodeOptions_sizeOfExcludingThis(self, mallocSizeOf)
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                OwningDecodeOptions_OwningDecodeOptions_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ContextOptions {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub compileOptions_: root::JS::PrefableCompileOptions,
        }
        impl ContextOptions {
            #[inline]
            pub fn wasm_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasm_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmForTrustedPrinciples_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmForTrustedPrinciples_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmVerbose_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmVerbose_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmBaseline_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmBaseline_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn wasmIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_wasmIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn testWasmAwaitTier2_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_testWasmAwaitTier2_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disableIon_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableIon_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn disableEvalSecurityChecks_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_disableEvalSecurityChecks_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn asyncStack_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStack_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn asyncStackCaptureDebuggeeOnly_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_asyncStackCaptureDebuggeeOnly_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn throwOnDebuggeeWouldRun_(&self) -> bool {
                unsafe {
                    ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8)
                }
            }
            #[inline]
            pub fn set_throwOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(10usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn dumpStackOnDebuggeeWouldRun_(&self) -> bool {
                unsafe {
                    ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8)
                }
            }
            #[inline]
            pub fn set_dumpStackOnDebuggeeWouldRun_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(11usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn fuzzing_(&self) -> bool {
                unsafe {
                    ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8)
                }
            }
            #[inline]
            pub fn set_fuzzing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(12usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                wasm_: bool,
                wasmForTrustedPrinciples_: bool,
                wasmVerbose_: bool,
                wasmBaseline_: bool,
                wasmIon_: bool,
                testWasmAwaitTier2_: bool,
                disableIon_: bool,
                disableEvalSecurityChecks_: bool,
                asyncStack_: bool,
                asyncStackCaptureDebuggeeOnly_: bool,
                throwOnDebuggeeWouldRun_: bool,
                dumpStackOnDebuggeeWouldRun_: bool,
                fuzzing_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<
                    [u8; 2usize],
                > = Default::default();
                __bindgen_bitfield_unit
                    .set(
                        0usize,
                        1u8,
                        {
                            let wasm_: u8 = unsafe { ::std::mem::transmute(wasm_) };
                            wasm_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        1usize,
                        1u8,
                        {
                            let wasmForTrustedPrinciples_: u8 = unsafe {
                                ::std::mem::transmute(wasmForTrustedPrinciples_)
                            };
                            wasmForTrustedPrinciples_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        2usize,
                        1u8,
                        {
                            let wasmVerbose_: u8 = unsafe {
                                ::std::mem::transmute(wasmVerbose_)
                            };
                            wasmVerbose_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        3usize,
                        1u8,
                        {
                            let wasmBaseline_: u8 = unsafe {
                                ::std::mem::transmute(wasmBaseline_)
                            };
                            wasmBaseline_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        4usize,
                        1u8,
                        {
                            let wasmIon_: u8 = unsafe {
                                ::std::mem::transmute(wasmIon_)
                            };
                            wasmIon_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        5usize,
                        1u8,
                        {
                            let testWasmAwaitTier2_: u8 = unsafe {
                                ::std::mem::transmute(testWasmAwaitTier2_)
                            };
                            testWasmAwaitTier2_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        6usize,
                        1u8,
                        {
                            let disableIon_: u8 = unsafe {
                                ::std::mem::transmute(disableIon_)
                            };
                            disableIon_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        7usize,
                        1u8,
                        {
                            let disableEvalSecurityChecks_: u8 = unsafe {
                                ::std::mem::transmute(disableEvalSecurityChecks_)
                            };
                            disableEvalSecurityChecks_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        8usize,
                        1u8,
                        {
                            let asyncStack_: u8 = unsafe {
                                ::std::mem::transmute(asyncStack_)
                            };
                            asyncStack_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        9usize,
                        1u8,
                        {
                            let asyncStackCaptureDebuggeeOnly_: u8 = unsafe {
                                ::std::mem::transmute(asyncStackCaptureDebuggeeOnly_)
                            };
                            asyncStackCaptureDebuggeeOnly_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        10usize,
                        1u8,
                        {
                            let throwOnDebuggeeWouldRun_: u8 = unsafe {
                                ::std::mem::transmute(throwOnDebuggeeWouldRun_)
                            };
                            throwOnDebuggeeWouldRun_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        11usize,
                        1u8,
                        {
                            let dumpStackOnDebuggeeWouldRun_: u8 = unsafe {
                                ::std::mem::transmute(dumpStackOnDebuggeeWouldRun_)
                            };
                            dumpStackOnDebuggeeWouldRun_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        12usize,
                        1u8,
                        {
                            let fuzzing_: u8 = unsafe {
                                ::std::mem::transmute(fuzzing_)
                            };
                            fuzzing_ as u64
                        },
                    );
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn setFuzzing(
                &mut self,
                flag: bool,
            ) -> *mut root::JS::ContextOptions {
                ContextOptions_setFuzzing(self, flag)
            }
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ValueType {
            Double = 0,
            Int32 = 1,
            Boolean = 2,
            Undefined = 3,
            Null = 4,
            Magic = 5,
            String = 6,
            Symbol = 7,
            PrivateGCThing = 8,
            BigInt = 9,
            Object = 12,
        }
        /** [SMDOC] JS::Value type

 JS::Value is the interface for a single JavaScript Engine value.  A few
 general notes on JS::Value:

 - JS::Value has setX() and isX() members for X in

     { Int32, Double, String, Symbol, BigInt, Boolean, Undefined, Null,
       Object, Magic }

   JS::Value also contains toX() for each of the non-singleton types.

 - Magic is a singleton type whose payload contains either a JSWhyMagic
   "reason" for the magic value or a uint32_t value. By providing JSWhyMagic
   values when creating and checking for magic values, it is possible to
   assert, at runtime, that only magic values with the expected reason flow
   through a particular value. For example, if cx->exception has a magic
   value, the reason must be JS_GENERATOR_CLOSING.

 - The JS::Value operations are preferred.  The JSVAL_* operations remain for
   compatibility; they may be removed at some point.  These operations mostly
   provide similar functionality.  But there are a few key differences.  One
   is that JS::Value gives null a separate type.
   Also, to help prevent mistakenly boxing a nullable JSObject* as an object,
   Value::setObject takes a JSObject&. (Conversely, Value::toObject returns a
   JSObject&.)  A convenience member Value::setObjectOrNull is provided.

 - Note that JS::Value is 8 bytes on 32 and 64-bit architectures. Thus, on
   32-bit user code should avoid copying jsval/JS::Value as much as possible,
   preferring to pass by const Value&.

 Spectre mitigations
 ===================
 To mitigate Spectre attacks, we do the following:

 - On 64-bit platforms, when unboxing a Value, we XOR the bits with the
   expected type tag (instead of masking the payload bits). This guarantees
   that toString, toObject, toSymbol will return an invalid pointer (because
   some high bits will be set) when called on a Value with a different type
   tag.

 - On 32-bit platforms,when unboxing an object/string/symbol Value, we use a
   conditional move (not speculated) to zero the payload register if the type
   doesn't match.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct Value {
            pub asBits_: u64,
        }
        pub type Value_PayloadType = u32;
        impl Value {
            #[inline]
            pub unsafe fn dump(&self) {
                Value_dump(self)
            }
            #[inline]
            pub unsafe fn dump1(&self, out: *mut root::js::GenericPrinter) {
                Value_dump1(self, out)
            }
            #[inline]
            pub unsafe fn dump2(&self, json: *mut root::js::JSONPrinter) {
                Value_dump2(self, json)
            }
            #[inline]
            pub unsafe fn dumpFields(&self, json: *mut root::js::JSONPrinter) {
                Value_dumpFields(self, json)
            }
            #[inline]
            pub unsafe fn dumpStringContent(&self, out: *mut root::js::GenericPrinter) {
                Value_dumpStringContent(self, out)
            }
        }
        /** An amount of space large enough to store the null-terminated result of
 |ToString| on any Number.

 The <https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type>
 |NumberToString| algorithm is specified in terms of results, not an
 algorithm.  It is extremely unclear from the algorithm's definition what its
 longest output can be.  |-(2**-19 - 2**-72)| requires 25 + 1 characters and
 is believed to be at least *very close* to the upper bound, so we round that
 *very generously* upward to a 64-bit pointer-size boundary (to be extra
 cautious) and assume that's adequate.

 If you can supply better reasoning for a tighter bound, file a bug to improve
 this!*/
        pub const MaximumNumberToStringLength: usize = 32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyKey {
            pub asBits_: usize,
        }
        pub const PropertyKey_IntTagBit: usize = 1;
        pub const PropertyKey_StringTypeTag: usize = 0;
        pub const PropertyKey_VoidTypeTag: usize = 2;
        pub const PropertyKey_SymbolTypeTag: usize = 4;
        pub const PropertyKey_TypeMask: usize = 7;
        pub const PropertyKey_IntMin: u32 = 0;
        pub const PropertyKey_IntMax: u32 = 2147483647;
        impl PropertyKey {
            #[inline]
            pub unsafe fn isPrivateName(&self) -> bool {
                PropertyKey_isPrivateName(self)
            }
            #[inline]
            pub unsafe fn isWellKnownSymbol(&self, code: root::JS::SymbolCode) -> bool {
                PropertyKey_isWellKnownSymbol(self, code)
            }
            #[inline]
            pub unsafe fn fromPinnedString(
                str_: *mut root::JSString,
            ) -> root::JS::PropertyKey {
                PropertyKey_fromPinnedString(str_)
            }
            #[inline]
            pub unsafe fn dump(&self) {
                PropertyKey_dump(self)
            }
            #[inline]
            pub unsafe fn dump1(&self, out: *mut root::js::GenericPrinter) {
                PropertyKey_dump1(self, out)
            }
            #[inline]
            pub unsafe fn dump2(&self, json: *mut root::js::JSONPrinter) {
                PropertyKey_dump2(self, json)
            }
            #[inline]
            pub unsafe fn dumpFields(&self, json: *mut root::js::JSONPrinter) {
                PropertyKey_dumpFields(self, json)
            }
            #[inline]
            pub unsafe fn dumpPropertyName(&self, out: *mut root::js::GenericPrinter) {
                PropertyKey_dumpPropertyName(self, out)
            }
            #[inline]
            pub unsafe fn dumpStringContent(&self, out: *mut root::js::GenericPrinter) {
                PropertyKey_dumpStringContent(self, out)
            }
        }
        /** Per ES6, the [[DefineOwnProperty]] internal method has three different
 possible outcomes:

 -   It can throw an exception (which we indicate by returning false).

 -   It can return true, indicating unvarnished success.

 -   It can return false, indicating "strict failure". The property could
     not be defined. It's an error, but no exception was thrown.

 It's not just [[DefineOwnProperty]]: all the mutating internal methods have
 the same three outcomes. (The other affected internal methods are [[Set]],
 [[Delete]], [[SetPrototypeOf]], and [[PreventExtensions]].)

 If you think this design is awful, you're not alone.  But as it's the
 standard, we must represent these boolean "success" values somehow.
 ObjectOpSuccess is the class for this. It's like a bool, but when it's false
 it also stores an error code.

 Typical usage:

     ObjectOpResult result;
     if (!DefineProperty(cx, obj, id, ..., result)) {
         return false;
     }
     if (!result) {
         return result.reportError(cx, obj, id);
     }

 Users don't have to call `result.report()`; another possible ending is:

     argv.rval().setBoolean(result.ok());
     return true;*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectOpResult {
            /** code_ is either one of the special codes OkCode or Uninitialized, or an
 error code. For now the error codes are JS friend API and are defined in
 js/public/friend/ErrorNumbers.msg.

 code_ is uintptr_t (rather than uint32_t) for the convenience of the
 JITs, which would otherwise have to deal with either padding or stack
 alignment on 64-bit platforms.*/
            pub code_: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ObjectOpResult_SpecialCodes {
            OkCode = 0,
            Uninitialized = 4294967295,
        }
        impl ObjectOpResult {
            #[inline]
            pub unsafe fn failCantRedefineProp(&mut self) -> bool {
                ObjectOpResult_failCantRedefineProp(self)
            }
            #[inline]
            pub unsafe fn failReadOnly(&mut self) -> bool {
                ObjectOpResult_failReadOnly(self)
            }
            #[inline]
            pub unsafe fn failGetterOnly(&mut self) -> bool {
                ObjectOpResult_failGetterOnly(self)
            }
            #[inline]
            pub unsafe fn failCantDelete(&mut self) -> bool {
                ObjectOpResult_failCantDelete(self)
            }
            #[inline]
            pub unsafe fn failCantSetInterposed(&mut self) -> bool {
                ObjectOpResult_failCantSetInterposed(self)
            }
            #[inline]
            pub unsafe fn failCantDefineWindowElement(&mut self) -> bool {
                ObjectOpResult_failCantDefineWindowElement(self)
            }
            #[inline]
            pub unsafe fn failCantDeleteWindowElement(&mut self) -> bool {
                ObjectOpResult_failCantDeleteWindowElement(self)
            }
            #[inline]
            pub unsafe fn failCantDefineWindowNamedProperty(&mut self) -> bool {
                ObjectOpResult_failCantDefineWindowNamedProperty(self)
            }
            #[inline]
            pub unsafe fn failCantDeleteWindowNamedProperty(&mut self) -> bool {
                ObjectOpResult_failCantDeleteWindowNamedProperty(self)
            }
            #[inline]
            pub unsafe fn failCantPreventExtensions(&mut self) -> bool {
                ObjectOpResult_failCantPreventExtensions(self)
            }
            #[inline]
            pub unsafe fn failCantSetProto(&mut self) -> bool {
                ObjectOpResult_failCantSetProto(self)
            }
            #[inline]
            pub unsafe fn failNoNamedSetter(&mut self) -> bool {
                ObjectOpResult_failNoNamedSetter(self)
            }
            #[inline]
            pub unsafe fn failNoIndexedSetter(&mut self) -> bool {
                ObjectOpResult_failNoIndexedSetter(self)
            }
            #[inline]
            pub unsafe fn failNotDataDescriptor(&mut self) -> bool {
                ObjectOpResult_failNotDataDescriptor(self)
            }
            #[inline]
            pub unsafe fn failInvalidDescriptor(&mut self) -> bool {
                ObjectOpResult_failInvalidDescriptor(self)
            }
            #[inline]
            pub unsafe fn failCantDefineWindowNonConfigurable(&mut self) -> bool {
                ObjectOpResult_failCantDefineWindowNonConfigurable(self)
            }
            #[inline]
            pub unsafe fn failBadArrayLength(&mut self) -> bool {
                ObjectOpResult_failBadArrayLength(self)
            }
            #[inline]
            pub unsafe fn failBadIndex(&mut self) -> bool {
                ObjectOpResult_failBadIndex(self)
            }
            #[inline]
            pub unsafe fn reportError(
                &mut self,
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
            ) -> bool {
                ObjectOpResult_reportError(self, cx, obj, id)
            }
            #[inline]
            pub unsafe fn reportError1(
                &mut self,
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool {
                ObjectOpResult_reportError1(self, cx, obj)
            }
        }
        #[repr(i32)]
        /// Specification for which compartment/zone a newly created realm should use.
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentSpecifier {
            NewCompartmentInSystemZone = 0,
            NewCompartmentInExistingZone = 1,
            NewCompartmentAndZone = 2,
            ExistingCompartment = 3,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct LocaleString {
            pub _base: root::js::RefCounted,
            pub chars_: *const ::std::os::raw::c_char,
        }
        /** RealmCreationOptions specifies options relevant to creating a new realm, that
 are either immutable characteristics of that realm or that are discarded
 after the realm has been created.

 Access to these options on an existing realm is read-only: if you need
 particular selections, you must make them before you create the realm.*/
        #[repr(C)]
        pub struct RealmCreationOptions {
            pub traceGlobal_: root::JSTraceOp,
            pub compSpec_: root::JS::CompartmentSpecifier,
            pub __bindgen_anon_1: root::JS::RealmCreationOptions__bindgen_ty_1,
            pub profilerRealmID_: u64,
            pub locale_: root::RefPtr<root::JS::LocaleString>,
            pub invisibleToDebugger_: bool,
            pub preserveJitCode_: bool,
            pub sharedMemoryAndAtomics_: bool,
            pub defineSharedArrayBufferConstructor_: bool,
            pub coopAndCoep_: bool,
            pub streams_: bool,
            pub toSource_: bool,
            pub secureContext_: bool,
            pub freezeBuiltins_: bool,
            pub forceUTC_: bool,
            pub alwaysUseFdlibm_: bool,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union RealmCreationOptions__bindgen_ty_1 {
            pub comp_: *mut root::JS::Compartment,
            pub zone_: *mut root::JS::Zone,
        }
        impl RealmCreationOptions {
            #[inline]
            pub unsafe fn setNewCompartmentInSystemZone(
                &mut self,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setNewCompartmentInSystemZone(self)
            }
            #[inline]
            pub unsafe fn setNewCompartmentInExistingZone(
                &mut self,
                obj: *mut root::JSObject,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setNewCompartmentInExistingZone(self, obj)
            }
            #[inline]
            pub unsafe fn setNewCompartmentAndZone(
                &mut self,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setNewCompartmentAndZone(self)
            }
            #[inline]
            pub unsafe fn setExistingCompartment(
                &mut self,
                obj: *mut root::JSObject,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setExistingCompartment(self, obj)
            }
            #[inline]
            pub unsafe fn setExistingCompartment1(
                &mut self,
                compartment: *mut root::JS::Compartment,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setExistingCompartment1(self, compartment)
            }
            #[inline]
            pub unsafe fn getSharedMemoryAndAtomicsEnabled(&self) -> bool {
                RealmCreationOptions_getSharedMemoryAndAtomicsEnabled(self)
            }
            #[inline]
            pub unsafe fn setSharedMemoryAndAtomicsEnabled(
                &mut self,
                flag: bool,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setSharedMemoryAndAtomicsEnabled(self, flag)
            }
            #[inline]
            pub unsafe fn getCoopAndCoepEnabled(&self) -> bool {
                RealmCreationOptions_getCoopAndCoepEnabled(self)
            }
            #[inline]
            pub unsafe fn setCoopAndCoepEnabled(
                &mut self,
                flag: bool,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setCoopAndCoepEnabled(self, flag)
            }
            #[inline]
            pub unsafe fn setLocaleCopyZ(
                &mut self,
                locale: *const ::std::os::raw::c_char,
            ) -> *mut root::JS::RealmCreationOptions {
                RealmCreationOptions_setLocaleCopyZ(self, locale)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RTPCallerTypeToken {
            pub value: u8,
        }
        /** RealmBehaviors specifies behaviors of a realm that can be changed after the
 realm's been created.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RealmBehaviors {
            pub rtpCallerType: root::mozilla::Maybe,
            pub discardSource_: bool,
            pub clampAndJitterTime_: bool,
            pub isNonLive_: bool,
        }
        /** RealmOptions specifies realm characteristics: both those that can't be
 changed on a realm once it's been created (RealmCreationOptions), and those
 that can be changed on an existing realm (RealmBehaviors).*/
        #[repr(C)]
        pub struct RealmOptions {
            pub creationOptions_: root::JS::RealmCreationOptions,
            pub behaviors_: root::JS::RealmBehaviors,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClippedTime {
            pub t: f64,
        }
        pub type ReduceMicrosecondTimePrecisionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: f64,
                arg2: root::JS::RTPCallerTypeToken,
                arg3: *mut root::JSContext,
            ) -> f64,
        >;
        /** A convenience class for imitating a JS for-of loop. Typical usage:

     JS::ForOfIterator it(cx);
     if (!it.init(iterable)) {
       return false;
     }
     JS::Rooted<JS::Value> val(cx);
     while (true) {
       bool done;
       if (!it.next(&val, &done)) {
         return false;
       }
       if (done) {
         break;
       }
       if (!DoStuff(cx, val)) {
         return false;
       }
     }*/
        #[repr(C)]
        pub struct ForOfIterator {
            pub cx_: *mut root::JSContext,
            pub iterator: root::JS::Rooted<*mut root::JSObject>,
            pub nextMethod: root::JS::Rooted<root::JS::Value>,
            pub index: u32,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ForOfIterator_NonIterableBehavior {
            ThrowOnNonIterable = 0,
            AllowNonIterable = 1,
        }
        pub const ForOfIterator_NOT_ARRAY: u32 = 4294967295;
        impl ForOfIterator {
            #[inline]
            #[must_use]
            pub unsafe fn init(
                &mut self,
                iterable: root::JS::Handle<root::JS::Value>,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool {
                ForOfIterator_init(self, iterable, nonIterableBehavior)
            }
            #[inline]
            #[must_use]
            pub unsafe fn next(
                &mut self,
                val: root::JS::MutableHandle<root::JS::Value>,
                done: *mut bool,
            ) -> bool {
                ForOfIterator_next(self, val, done)
            }
            #[inline]
            pub unsafe fn closeThrow(&mut self) {
                ForOfIterator_closeThrow(self)
            }
        }
        /** Span - slices for C++

 Span implements Rust's slice concept for C++. It's called "Span" instead of
 "Slice" to follow the naming used in C++ Core Guidelines.

 A Span wraps a pointer and a length that identify a non-owning view to a
 contiguous block of memory of objects of the same type. Various types,
 including (pre-decay) C arrays, XPCOM strings, nsTArray, mozilla::Array,
 mozilla::Range and contiguous standard-library containers, auto-convert
 into Spans when attempting to pass them as arguments to methods that take
 Spans. (Span itself autoconverts into mozilla::Range.)

 Like Rust's slices, Span provides safety against out-of-bounds access by
 performing run-time bound checks. However, unlike Rust's slices, Span
 cannot provide safety against use-after-free.

 (Note: Span is like Rust's slice only conceptually. Due to the lack of
 ABI guarantees, you should still decompose spans/slices to raw pointer
 and length parts when crossing the FFI. The Elements() and data() methods
 are guaranteed to return a non-null pointer even for zero-length spans,
 so the pointer can be used as a raw part of a Rust slice without further
 checks.)

 In addition to having constructors (with the support of deduction guides)
 that take various well-known types, a Span for an arbitrary type can be
 constructed from a pointer and a length or a pointer and another pointer
 pointing just past the last element.

 A Span<const char> or Span<const char16_t> can be obtained for const char*
 or const char16_t pointing to a zero-terminated string using the
 MakeStringSpan() function (which treats a nullptr argument equivalently
 to the empty string). Corresponding implicit constructor does not exist
 in order to avoid accidental construction in cases where const char* or
 const char16_t* do not point to a zero-terminated string.

 Span has methods that follow the Mozilla naming style and methods that
 don't. The methods that follow the Mozilla naming style are meant to be
 used directly from Mozilla code. The methods that don't are meant for
 integration with C++11 range-based loops and with meta-programming that
 expects the same methods that are found on the standard-library
 containers. For example, to decompose a Span into its parts in Mozilla
 code, use Elements() and Length() (as with nsTArray) instead of data()
 and size() (as with std::vector).

 The pointer and length wrapped by a Span cannot be changed after a Span has
 been created. When new values are required, simply create a new Span. Span
 has a method called Subspan() that works analogously to the Substring()
 method of XPCOM strings taking a start index and an optional length. As a
 Mozilla extension (relative to Microsoft's gsl::span that mozilla::Span is
 based on), Span has methods From(start), To(end) and FromTo(start, end)
 that correspond to Rust's &slice[start..], &slice[..end] and
 &slice[start..end], respectively. (That is, the end index is the index of
 the first element not to be included in the new subspan.)

 When indicating a Span that's only read from, const goes inside the type
 parameter. Don't put const in front of Span. That is:
 size_t ReadsFromOneSpanAndWritesToAnother(Span<const uint8_t> aReadFrom,
                                           Span<uint8_t> aWrittenTo);

 Any Span<const T> can be viewed as Span<const uint8_t> using the function
 AsBytes(). Any Span<T> can be viewed as Span<uint8_t> using the function
 AsWritableBytes().

 Note that iterators from different Span instances are uncomparable, even if
 they refer to the same memory. This also applies to any spans derived via
 Subspan etc.*/
        pub type SelfHostedCache = [u32; 2usize];
        pub type SelfHostedWriter = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::SelfHostedCache,
            ) -> bool,
        >;
        #[repr(C)]
        pub struct JSONParseHandler__bindgen_vtable(::std::os::raw::c_void);
        /** Handler with callbacks for JS::ParseJSONWithHandler.

 Each method is called during parsing the JSON string. If the method returns
 true, the parsing keeps going.  If the method returns false, the parsing
 stops and fails.

 The error method is called when syntax error happens while parsing the input.
 This method is not called when handler's method returns false.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JSONParseHandler {
            pub vtable_: *const JSONParseHandler__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TabSizes {
            pub objects_: usize,
            pub strings_: usize,
            pub private_: usize,
            pub other_: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TabSizes_Kind {
            Objects = 0,
            Strings = 1,
            Private = 2,
            Other = 3,
        }
        /// These are the measurements used by Servo.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ServoSizes {
            pub gcHeapUsed: usize,
            pub gcHeapUnused: usize,
            pub gcHeapAdmin: usize,
            pub gcHeapDecommitted: usize,
            pub mallocHeap: usize,
            pub nonHeap: usize,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ServoSizes_Kind {
            GCHeapUsed = 0,
            GCHeapUnused = 1,
            GCHeapAdmin = 2,
            GCHeapDecommitted = 3,
            MallocHeap = 4,
            NonHeap = 5,
            Ignore = 6,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ClassInfo {
            pub objectsGCHeap: usize,
            pub objectsMallocHeapSlots: usize,
            pub objectsMallocHeapElementsNormal: usize,
            pub objectsMallocHeapElementsAsmJS: usize,
            pub objectsMallocHeapGlobalData: usize,
            pub objectsMallocHeapGlobalVarNamesSet: usize,
            pub objectsMallocHeapMisc: usize,
            pub objectsNonHeapElementsNormal: usize,
            pub objectsNonHeapElementsShared: usize,
            pub objectsNonHeapElementsWasm: usize,
            pub objectsNonHeapElementsWasmShared: usize,
            pub objectsNonHeapCodeWasm: usize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ShapeInfo {
            pub shapesGCHeapShared: usize,
            pub shapesGCHeapDict: usize,
            pub shapesGCHeapBase: usize,
            pub shapesMallocHeapCache: usize,
        }
        /** Holds data about a notable class (one whose combined object and shape
 instances use more than a certain amount of memory) so we can report it
 individually.

 The only difference between this class and ClassInfo is that this class
 holds a copy of the filename.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableClassInfo {
            pub _base: root::JS::ClassInfo,
            pub className_: root::JS::UniqueChars,
        }
        impl NotableClassInfo {
            #[inline]
            pub unsafe fn new(
                className: *const ::std::os::raw::c_char,
                info: *const root::JS::ClassInfo,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NotableClassInfo_NotableClassInfo(
                    __bindgen_tmp.as_mut_ptr(),
                    className,
                    info,
                );
                __bindgen_tmp.assume_init()
            }
        }
        /// Data for tracking JIT-code memory usage.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CodeSizes {
            pub ion: usize,
            pub baseline: usize,
            pub regexp: usize,
            pub other: usize,
            pub unused: usize,
        }
        /// Data for tracking GC memory usage.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCSizes {
            pub marker: usize,
            pub nurseryCommitted: usize,
            pub nurseryMallocedBuffers: usize,
            pub nurseryMallocedBlockCache: usize,
            pub nurseryTrailerBlockSets: usize,
            pub storeBufferVals: usize,
            pub storeBufferCells: usize,
            pub storeBufferSlots: usize,
            pub storeBufferWasmAnyRefs: usize,
            pub storeBufferWholeCells: usize,
            pub storeBufferGenerics: usize,
        }
        /** This class holds information about the memory taken up by identical copies of
 a particular string.  Multiple JSStrings may have their sizes aggregated
 together into one StringInfo object.  Note that two strings with identical
 chars will not be aggregated together if one is a short string and the other
 is not.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StringInfo {
            pub gcHeapLatin1: usize,
            pub gcHeapTwoByte: usize,
            pub mallocHeapLatin1: usize,
            pub mallocHeapTwoByte: usize,
            pub numCopies: u32,
        }
        /** Holds data about a notable string (one which, counting all duplicates, uses
 more than a certain amount of memory) so we can report it individually.

 The only difference between this class and StringInfo is that
 NotableStringInfo holds a copy of some or all of the string's chars.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableStringInfo {
            pub _base: root::JS::StringInfo,
            pub buffer: root::JS::UniqueChars,
            pub length: usize,
        }
        pub const NotableStringInfo_MAX_SAVED_CHARS: usize = 1024;
        impl NotableStringInfo {
            #[inline]
            pub unsafe fn new(
                str_: *mut root::JSString,
                info: *const root::JS::StringInfo,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NotableStringInfo_NotableStringInfo(
                    __bindgen_tmp.as_mut_ptr(),
                    str_,
                    info,
                );
                __bindgen_tmp.assume_init()
            }
        }
        /** This class holds information about the memory taken up by script sources
 from a particular file.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ScriptSourceInfo {
            pub misc: usize,
            pub numScripts: u32,
        }
        /** Holds data about a notable script source file (one whose combined
 script sources use more than a certain amount of memory) so we can report it
 individually.

 The only difference between this class and ScriptSourceInfo is that this
 class holds a copy of the filename.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct NotableScriptSourceInfo {
            pub _base: root::JS::ScriptSourceInfo,
            pub filename_: root::JS::UniqueChars,
        }
        impl NotableScriptSourceInfo {
            #[inline]
            pub unsafe fn new(
                filename: *const ::std::os::raw::c_char,
                info: *const root::JS::ScriptSourceInfo,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NotableScriptSourceInfo_NotableScriptSourceInfo(
                    __bindgen_tmp.as_mut_ptr(),
                    filename,
                    info,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HelperThreadStats {
            pub stateData: usize,
            pub ionCompileTask: usize,
            pub wasmCompile: usize,
            pub contexts: usize,
            pub idleThreadCount: ::std::os::raw::c_uint,
            pub activeThreadCount: ::std::os::raw::c_uint,
        }
        /// Measurements that not associated with any individual runtime.
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GlobalStats {
            pub helperThread: root::JS::HelperThreadStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        /** These measurements relate directly to the JSRuntime, and not to zones,
 compartments, and realms within it.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RuntimeSizes {
            pub object: usize,
            pub atomsTable: usize,
            pub atomsMarkBitmaps: usize,
            pub selfHostStencil: usize,
            pub contexts: usize,
            pub temporary: usize,
            pub interpreterStack: usize,
            pub sharedImmutableStringsCache: usize,
            pub sharedIntlData: usize,
            pub uncompressedSourceCache: usize,
            pub scriptData: usize,
            pub wasmRuntime: usize,
            pub wasmGuardPages: usize,
            pub jitLazyLink: usize,
            pub scriptSourceInfo: root::JS::ScriptSourceInfo,
            pub gc: root::JS::GCSizes,
            pub allScriptSources: root::mozilla::Maybe,
            pub notableScriptSources: [u32; 5usize],
        }
        pub type RuntimeSizes_ScriptSourcesHashMap = [u64; 5usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnusedGCThingSizes {
            pub object: usize,
            pub script: usize,
            pub shape: usize,
            pub baseShape: usize,
            pub getterSetter: usize,
            pub propMap: usize,
            pub string: usize,
            pub symbol: usize,
            pub bigInt: usize,
            pub jitcode: usize,
            pub scope: usize,
            pub regExpShared: usize,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ZoneStats {
            pub symbolsGCHeap: usize,
            pub bigIntsGCHeap: usize,
            pub bigIntsMallocHeap: usize,
            pub gcHeapArenaAdmin: usize,
            pub jitCodesGCHeap: usize,
            pub getterSettersGCHeap: usize,
            pub compactPropMapsGCHeap: usize,
            pub normalPropMapsGCHeap: usize,
            pub dictPropMapsGCHeap: usize,
            pub propMapChildren: usize,
            pub propMapTables: usize,
            pub scopesGCHeap: usize,
            pub scopesMallocHeap: usize,
            pub regExpSharedsGCHeap: usize,
            pub regExpSharedsMallocHeap: usize,
            pub zoneObject: usize,
            pub regexpZone: usize,
            pub jitZone: usize,
            pub cacheIRStubs: usize,
            pub uniqueIdMap: usize,
            pub initialPropMapTable: usize,
            pub shapeTables: usize,
            pub compartmentObjects: usize,
            pub crossCompartmentWrappersTables: usize,
            pub compartmentsPrivateData: usize,
            pub scriptCountsMap: usize,
            pub unusedGCThings: root::JS::UnusedGCThingSizes,
            pub stringInfo: root::JS::StringInfo,
            pub shapeInfo: root::JS::ShapeInfo,
            pub code: root::JS::CodeSizes,
            pub extra: *mut ::std::os::raw::c_void,
            pub allStrings: root::mozilla::Maybe,
            pub notableStrings: [u32; 5usize],
            pub isTotals: bool,
        }
        pub type ZoneStats_StringsHashMap = [u64; 5usize];
        impl ZoneStats {
            #[inline]
            pub unsafe fn initStrings(&mut self) {
                ZoneStats_initStrings(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RealmStats {
            pub objectsPrivate: usize,
            pub scriptsGCHeap: usize,
            pub scriptsMallocHeapData: usize,
            pub baselineData: usize,
            pub allocSites: usize,
            pub ionData: usize,
            pub jitScripts: usize,
            pub realmObject: usize,
            pub realmTables: usize,
            pub innerViewsTable: usize,
            pub objectMetadataTable: usize,
            pub savedStacksSet: usize,
            pub nonSyntacticLexicalScopesTable: usize,
            pub classInfo: root::JS::ClassInfo,
            pub extra: *mut ::std::os::raw::c_void,
            pub allClasses: root::mozilla::Maybe,
            pub notableClasses: [u32; 5usize],
            pub isTotals: bool,
        }
        pub type RealmStats_ClassesHashMap = [u64; 5usize];
        impl RealmStats {
            #[inline]
            pub unsafe fn initClasses(&mut self) {
                RealmStats_initClasses(self)
            }
        }
        pub type RealmStatsVector = [u32; 5usize];
        pub type ZoneStatsVector = [u32; 5usize];
        #[repr(C)]
        pub struct RuntimeStats__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RuntimeStats {
            pub vtable_: *const RuntimeStats__bindgen_vtable,
            pub gcHeapChunkTotal: usize,
            pub gcHeapDecommittedPages: usize,
            pub gcHeapUnusedChunks: usize,
            pub gcHeapUnusedArenas: usize,
            pub gcHeapChunkAdmin: usize,
            pub gcHeapGCThings: usize,
            pub runtime: root::JS::RuntimeSizes,
            pub realmTotals: root::JS::RealmStats,
            pub zTotals: root::JS::ZoneStats,
            pub realmStatsVector: root::JS::RealmStatsVector,
            pub zoneStatsVector: root::JS::ZoneStatsVector,
            pub currZoneStats: *mut root::JS::ZoneStats,
            pub mallocSizeOf_: root::mozilla::MallocSizeOf,
        }
        #[repr(C)]
        pub struct ObjectPrivateVisitor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ObjectPrivateVisitor {
            pub vtable_: *const ObjectPrivateVisitor__bindgen_vtable,
            pub getISupports_: root::JS::ObjectPrivateVisitor_GetISupportsFun,
        }
        pub type ObjectPrivateVisitor_GetISupportsFun = ::std::option::Option<
            unsafe extern "C" fn(
                obj: *mut root::JSObject,
                iface: *mut *mut root::nsISupports,
            ) -> bool,
        >;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ModuleType {
            Unknown = 0,
            JavaScript = 1,
            JSON = 2,
        }
        /** The HostResolveImportedModule hook.

 See: https://tc39.es/ecma262/#sec-hostresolveimportedmodule

 This embedding-defined hook is used to implement module loading. It is called
 to get or create a module object corresponding to |moduleRequest| occurring
 in the context of the script or module with private value
 |referencingPrivate|.

 The module specifier string for the request can be obtained by calling
 JS::GetModuleRequestSpecifier.

 The private value for a script or module is set with JS::SetScriptPrivate or
 JS::SetModulePrivate. It's assumed that the embedding can handle receiving
 either here.

 This hook must obey the restrictions defined in the spec:
  - Each time the hook is called with the same arguemnts, the same module must
    be returned.
  - If a module cannot be created for the given arguments, an exception must
    be thrown.

 This is a synchronous operation.*/
        pub type ModuleResolveHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject,
        >;
        /** The module metadata hook.

 See: https://tc39.es/ecma262/#sec-hostgetimportmetaproperties

 Populate the |metaObject| object returned when import.meta is evaluated in
 the context of the script or module with private value |privateValue|.

 This is based on the spec's HostGetImportMetaProperties hook but defines
 properties on the meta object directly rather than returning a list.*/
        pub type ModuleMetadataHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                privateValue: root::JS::Handle<root::JS::Value>,
                metaObject: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        /** The HostImportModuleDynamically hook.

 See https://tc39.es/ecma262/#sec-hostimportmoduledynamically

 Used to implement dynamic module import. Called when evaluating import()
 expressions.

 This starts an asynchronous operation. Some time after this hook is called
 the embedding must call JS::FinishDynamicModuleImport() passing the
 |referencingPrivate|, |moduleRequest| and |promise| arguments from the
 call. This must happen for both success and failure cases.

 In the meantime the embedding can take whatever steps it needs to make the
 module available. If successful, after calling FinishDynamicModuleImport()
 the module should be returned by the resolve hook when passed
 |referencingPrivate| and |moduleRequest|.*/
        pub type ModuleDynamicImportHook = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool,
        >;
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ModuleErrorBehaviour {
            ReportModuleErrorsAsync = 0,
            ThrowModuleErrorsSync = 1,
        }
        #[repr(C)]
        pub struct JobQueue__bindgen_vtable(::std::os::raw::c_void);
        /** Abstract base class for an ECMAScript Job Queue:
 https://www.ecma-international.org/ecma-262/9.0/index.html#sec-jobs-and-job-queues

 SpiderMonkey doesn't schedule Promise resolution jobs itself; instead, the
 embedding can provide an instance of this class SpiderMonkey can use to do
 that scheduling.

 The JavaScript shell includes a simple implementation adequate for running
 tests. Browsers need to augment job handling to meet their own additional
 requirements, so they can provide their own implementation.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JobQueue {
            pub vtable_: *const JobQueue__bindgen_vtable,
        }
        #[repr(C)]
        pub struct JobQueue_SavedJobQueue__bindgen_vtable(::std::os::raw::c_void);
        /** A saved job queue, represented however the JobQueue implementation pleases.
 Use AutoDebuggerJobQueueInterruption rather than trying to construct one of
 these directly; see documentation there.

 Destructing an instance of this class should assert that the current queue
 is empty, and then restore the queue the instance captured.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct JobQueue_SavedJobQueue {
            pub vtable_: *const JobQueue_SavedJobQueue__bindgen_vtable,
        }
        /** [SMDOC] Protecting the debuggee's job/microtask queue from debugger activity.

 When the JavaScript debugger interrupts the execution of some debuggee code
 (for a breakpoint, for example), the debuggee's execution must be paused
 while the developer takes time to look at it. During this interruption, other
 tabs should remain active and usable. If the debuggee shares a main thread
 with non-debuggee tabs, that means that the thread will have to process
 non-debuggee HTML tasks and microtasks as usual, even as the debuggee's are
 on hold until the debugger lets it continue execution. (Letting debuggee
 microtasks run during the interruption would mean that, from the debuggee's
 point of view, their side effects would take place wherever the breakpoint
 was set - in general, not a place other code should ever run, and a violation
 of the run-to-completion rule.)

 This means that, even though the timing and ordering of microtasks is
 carefully specified by the standard - and important to preserve for
 compatibility and predictability - debugger use may, correctly, have the
 effect of reordering microtasks. During the interruption, microtasks enqueued
 by non-debuggee tabs must run immediately alongside their HTML tasks as
 usual, whereas any debuggee microtasks that were in the queue when the
 interruption began must wait for the debuggee to be continued - and thus run
 after microtasks enqueued after they were.

 Fortunately, this reordering is visible only at the global level: when
 implemented correctly, it is not detectable by an individual debuggee. Note
 that a debuggee should generally be a complete unit of similar-origin related
 browsing contexts. Since non-debuggee activity falls outside that unit, it
 should never be visible to the debuggee (except via mechanisms that are
 already asynchronous, like events), so the debuggee should be unable to
 detect non-debuggee microtasks running when they normally would not. As long
 as behavior *visible to the debuggee* is unaffected by the interruption, we
 have respected the spirit of the rule.

 Of course, even as we accept the general principle that interrupting the
 debuggee should have as little detectable effect as possible, we still permit
 the developer to do things like evaluate expressions at the console that have
 arbitrary effects on the debuggee's state—effects that could never occur
 naturally at that point in the program. But since these are explicitly
 requested by the developer, who presumably knows what they're doing, we
 support this as best we can. If the developer evaluates an expression in the
 console that resolves a promise, it seems most natural for the promise's
 reaction microtasks to run immediately, within the interruption. This is an
 'unnatural' time for the microtasks to run, but no more unnatural than the
 evaluation that triggered them.

 So the overall behavior we need is as follows:

 - When the debugger interrupts a debuggee, the debuggee's microtask queue
   must be saved.

 - When debuggee execution resumes, the debuggee's microtask queue must be
   restored exactly as it was when the interruption occurred.

 - Non-debuggee task and microtask execution must take place normally during
   the interruption.

 Since each HTML task begins with an empty microtask queue, and it should not
 be possible for a task to mix debuggee and non-debuggee code, interrupting a
 debuggee should always find a microtask queue containing exclusively debuggee
 microtasks, if any. So saving and restoring the microtask queue should affect
 only the debuggee, not any non-debuggee content.

 AutoDebuggerJobQueueInterruption
 --------------------------------

 AutoDebuggerJobQueueInterruption is an RAII class, meant for use by the
 Debugger API implementation, that takes care of saving and restoring the
 queue.

 Constructing and initializing an instance of AutoDebuggerJobQueueInterruption
 sets aside the given JSContext's job queue, leaving the JSContext's queue
 empty. When the AutoDebuggerJobQueueInterruption instance is destroyed, it
 asserts that the JSContext's current job queue (holding jobs enqueued while
 the AutoDebuggerJobQueueInterruption was alive) is empty, and restores the
 saved queue to the JSContext.

 Since the Debugger API's behavior is up to us, we can specify that Debugger
 hooks begin execution with an empty job queue, and that we drain the queue
 after each hook function has run. This drain will be visible to debugger
 hooks, and makes hook calls resemble HTML tasks, with their own automatic
 microtask checkpoint. But, the drain will be invisible to the debuggee, as
 its queue is preserved across the hook invocation.

 To protect the debuggee's job queue, Debugger takes care to invoke callback
 functions only within the scope of an AutoDebuggerJobQueueInterruption
 instance.

 Why not let the hook functions themselves take care of this?
 ------------------------------------------------------------

 Certainly, we could leave responsibility for saving and restoring the job
 queue to the Debugger hook functions themselves.

 In fact, early versions of this change tried making the devtools server save
 and restore the queue explicitly, but because hooks are set and changed in
 numerous places, it was hard to be confident that every case had been
 covered, and it seemed that future changes could easily introduce new holes.

 Later versions of this change modified the accessor properties on the
 Debugger objects' prototypes to automatically protect the job queue when
 calling hooks, but the effect was essentially a monkeypatch applied to an API
 we defined and control, which doesn't make sense.

 In the end, since promises have become such a pervasive part of JavaScript
 programming, almost any imaginable use of Debugger would need to provide some
 kind of protection for the debuggee's job queue, so it makes sense to simply
 handle it once, carefully, in the implementation of Debugger itself.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoDebuggerJobQueueInterruption {
            pub cx: *mut root::JSContext,
            pub saved: u32,
        }
        impl AutoDebuggerJobQueueInterruption {
            #[inline]
            pub unsafe fn init(&mut self, cx: *mut root::JSContext) -> bool {
                AutoDebuggerJobQueueInterruption_init(self, cx)
            }
            #[inline]
            pub unsafe fn runJobs(&mut self) {
                AutoDebuggerJobQueueInterruption_runJobs(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoDebuggerJobQueueInterruption_AutoDebuggerJobQueueInterruption(
                    __bindgen_tmp.as_mut_ptr(),
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoDebuggerJobQueueInterruption_AutoDebuggerJobQueueInterruption_destructor(
                    self,
                )
            }
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseRejectionHandlingState {
            Unhandled = 0,
            Handled = 1,
        }
        pub type PromiseRejectionTrackerCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                mutedErrors: bool,
                promise: root::JS::HandleObject,
                state: root::JS::PromiseRejectionHandlingState,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseState {
            Pending = 0,
            Fulfilled = 1,
            Rejected = 2,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PromiseUserInputEventHandlingState {
            DontCare = 0,
            HadUserInteractionAtCreation = 1,
            DidntHaveUserInteractionAtCreation = 2,
        }
        #[repr(C)]
        pub struct Dispatchable__bindgen_vtable(::std::os::raw::c_void);
        /** The Dispatchable interface allows the embedding to call SpiderMonkey
 on a JSContext thread when requested via DispatchToEventLoopCallback.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct Dispatchable {
            pub vtable_: *const Dispatchable__bindgen_vtable,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum Dispatchable_MaybeShuttingDown {
            NotShuttingDown = 0,
            ShuttingDown = 1,
        }
        /** Callback to dispatch a JS::Dispatchable to a JSContext's thread's event loop.

 The DispatchToEventLoopCallback set on a particular JSContext must accept
 JS::Dispatchable instances and arrange for their `run` methods to be called
 eventually on the JSContext's thread. This is used for cross-thread dispatch,
 so the callback itself must be safe to call from any thread.

 If the callback returns `true`, it must eventually run the given
 Dispatchable; otherwise, SpiderMonkey may leak memory or hang.

 The callback may return `false` to indicate that the JSContext's thread is
 shutting down and is no longer accepting runnables. Shutting down is a
 one-way transition: once the callback has rejected a runnable, it must reject
 all subsequently submitted runnables as well.

 To establish a DispatchToEventLoopCallback, the embedding may either call
 InitDispatchToEventLoop to provide its own, or call js::UseInternalJobQueues
 to select a default implementation built into SpiderMonkey. This latter
 depends on the embedding to call js::RunJobs on the JavaScript thread to
 process queued Dispatchables at appropriate times.*/
        pub type DispatchToEventLoopCallback = ::std::option::Option<
            unsafe extern "C" fn(
                closure: *mut ::std::os::raw::c_void,
                dispatchable: *mut root::JS::Dispatchable,
            ) -> bool,
        >;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum PropertyAttribute {
            Configurable = 0,
            Enumerable = 1,
            Writable = 2,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyAttributes {
            pub _base: root::mozilla::EnumSet<::std::os::raw::c_uchar>,
        }
        /** A structure that represents a property on an object, or the absence of a
 property.  Use {,Mutable}Handle<PropertyDescriptor> to interact with
 instances of this structure rather than interacting directly with member
 fields.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PropertyDescriptor {
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 2usize]>,
            pub getter_: *mut root::JSObject,
            pub setter_: *mut root::JSObject,
            pub value_: root::JS::Value,
        }
        impl PropertyDescriptor {
            #[inline]
            pub fn hasConfigurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasConfigurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn configurable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_configurable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasEnumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasEnumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(2usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn enumerable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_enumerable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(3usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasWritable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasWritable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(4usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn writable_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_writable_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(5usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(6usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasGetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasGetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(7usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn hasSetter_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_hasSetter_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(8usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn resolving_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_resolving_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(9usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                hasConfigurable_: bool,
                configurable_: bool,
                hasEnumerable_: bool,
                enumerable_: bool,
                hasWritable_: bool,
                writable_: bool,
                hasValue_: bool,
                hasGetter_: bool,
                hasSetter_: bool,
                resolving_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 2usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<
                    [u8; 2usize],
                > = Default::default();
                __bindgen_bitfield_unit
                    .set(
                        0usize,
                        1u8,
                        {
                            let hasConfigurable_: u8 = unsafe {
                                ::std::mem::transmute(hasConfigurable_)
                            };
                            hasConfigurable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        1usize,
                        1u8,
                        {
                            let configurable_: u8 = unsafe {
                                ::std::mem::transmute(configurable_)
                            };
                            configurable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        2usize,
                        1u8,
                        {
                            let hasEnumerable_: u8 = unsafe {
                                ::std::mem::transmute(hasEnumerable_)
                            };
                            hasEnumerable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        3usize,
                        1u8,
                        {
                            let enumerable_: u8 = unsafe {
                                ::std::mem::transmute(enumerable_)
                            };
                            enumerable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        4usize,
                        1u8,
                        {
                            let hasWritable_: u8 = unsafe {
                                ::std::mem::transmute(hasWritable_)
                            };
                            hasWritable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        5usize,
                        1u8,
                        {
                            let writable_: u8 = unsafe {
                                ::std::mem::transmute(writable_)
                            };
                            writable_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        6usize,
                        1u8,
                        {
                            let hasValue_: u8 = unsafe {
                                ::std::mem::transmute(hasValue_)
                            };
                            hasValue_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        7usize,
                        1u8,
                        {
                            let hasGetter_: u8 = unsafe {
                                ::std::mem::transmute(hasGetter_)
                            };
                            hasGetter_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        8usize,
                        1u8,
                        {
                            let hasSetter_: u8 = unsafe {
                                ::std::mem::transmute(hasSetter_)
                            };
                            hasSetter_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        9usize,
                        1u8,
                        {
                            let resolving_: u8 = unsafe {
                                ::std::mem::transmute(resolving_)
                            };
                            resolving_ as u64
                        },
                    );
                __bindgen_bitfield_unit
            }
            #[inline]
            pub unsafe fn trace(&mut self, trc: *mut root::JSTracer) {
                PropertyDescriptor_trace(self, trc)
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SymbolCode {
            isConcatSpreadable = 0,
            iterator = 1,
            match_ = 2,
            replace = 3,
            search = 4,
            species = 5,
            hasInstance = 6,
            split = 7,
            toPrimitive = 8,
            toStringTag = 9,
            unscopables = 10,
            asyncIterator = 11,
            matchAll = 12,
            Limit = 13,
            WellKnownAPILimit = 2147483648,
            PrivateNameSymbol = 4294967293,
            InSymbolRegistry = 4294967294,
            UniqueSymbol = 4294967295,
        }
        pub const WellKnownSymbolLimit: usize = 13;
        #[repr(i32)]
        /** The answer to a successful query as to whether an object is an Array per
 ES6's internal |IsArray| operation (as exposed by |Array.isArray|).*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum IsArrayAnswer {
            Array = 0,
            NotArray = 1,
            RevokedProxy = 2,
        }
        pub type IsAcceptableThis = ::std::option::Option<
            unsafe extern "C" fn(v: root::JS::HandleValue) -> bool,
        >;
        pub type NativeImpl = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                args: *const root::JS::CallArgs,
            ) -> bool,
        >;
        /** Regular expression flag values, suitable for initializing a collection of
 regular expression flags as defined below in |RegExpFlags|.  Flags are listed
 in alphabetical order by syntax -- /d, /g, /i, /m, /s, /u, /v, /y.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RegExpFlag {
            pub _address: u8,
        }
        /// Add .indices property to the match result, i.e. /d
        pub const RegExpFlag_HasIndices: u8 = 64;
        /** Act globally and find *all* matches (rather than stopping after just the
 first one), i.e. /g.*/
        pub const RegExpFlag_Global: u8 = 2;
        /** Interpret regular expression source text case-insensitively by folding
 uppercase letters to lowercase, i.e. /i.*/
        pub const RegExpFlag_IgnoreCase: u8 = 1;
        /// Treat ^ and $ as begin and end of line, i.e. /m.
        pub const RegExpFlag_Multiline: u8 = 4;
        pub const RegExpFlag_DotAll: u8 = 32;
        /// Use Unicode semantics, i.e. /u.
        pub const RegExpFlag_Unicode: u8 = 16;
        /// Use Unicode Sets semantics, i.e. /v.
        pub const RegExpFlag_UnicodeSets: u8 = 128;
        /// Only match starting from <regular expression>.lastIndex, i.e. /y.
        pub const RegExpFlag_Sticky: u8 = 8;
        /// No regular expression flags.
        pub const RegExpFlag_NoFlags: u8 = 0;
        /// All regular expression flags.
        pub const RegExpFlag_AllFlags: u8 = 255;
        /** A collection of regular expression flags.  Individual flag values may be
 combined into a collection using bitwise operators.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RegExpFlags {
            pub flags_: root::JS::RegExpFlags_Flag,
        }
        pub type RegExpFlags_Flag = u8;
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameResult {
            Ok = 0,
            AccessDenied = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SavedFrameSelfHosted {
            Include = 0,
            Exclude = 1,
        }
        pub mod Scalar {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Type {
                Int8 = 0,
                Uint8 = 1,
                Int16 = 2,
                Uint16 = 3,
                Int32 = 4,
                Uint32 = 5,
                Float32 = 6,
                Float64 = 7,
                /** Special type that is a uint8_t, but assignments are clamped to [0, 256).
 Treat the raw data type as a uint8_t.*/
                Uint8Clamped = 8,
                /** Special type that is a uint8_t, but assignments are clamped to [0, 256).
 Treat the raw data type as a uint8_t.*/
                BigInt64 = 9,
                /** Special type that is a uint8_t, but assignments are clamped to [0, 256).
 Treat the raw data type as a uint8_t.*/
                BigUint64 = 10,
                /** Special type that is a uint8_t, but assignments are clamped to [0, 256).
 Treat the raw data type as a uint8_t.*/
                Float16 = 11,
                /** Types that don't have their own TypedArray equivalent, for now.
 E.g. DataView*/
                MaxTypedArrayViewType = 12,
                /** Types that don't have their own TypedArray equivalent, for now.
 E.g. DataView*/
                Int64 = 13,
                /** Types that don't have their own TypedArray equivalent, for now.
 E.g. DataView*/
                Simd128 = 14,
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS6ScalarL8byteSizeENS0_4TypeE"]
                pub fn byteSize(atype: root::JS::Scalar::Type) -> usize;
                #[link_name = "\u{1}_ZN2JS6ScalarL15isSignedIntTypeENS0_4TypeE"]
                pub fn isSignedIntType(atype: root::JS::Scalar::Type) -> bool;
                #[link_name = "\u{1}_ZN2JS6ScalarL12isBigIntTypeENS0_4TypeE"]
                pub fn isBigIntType(atype: root::JS::Scalar::Type) -> bool;
                #[link_name = "\u{1}_ZN2JS6ScalarL14isFloatingTypeENS0_4TypeE"]
                pub fn isFloatingType(atype: root::JS::Scalar::Type) -> bool;
                #[link_name = "\u{1}_ZN2JS6ScalarL4nameENS0_4TypeE"]
                pub fn name(
                    atype: root::JS::Scalar::Type,
                ) -> *const ::std::os::raw::c_char;
                #[link_name = "\u{1}_ZN2JS6ScalarL14byteSizeStringENS0_4TypeE"]
                pub fn byteSizeString(
                    atype: root::JS::Scalar::Type,
                ) -> *const ::std::os::raw::c_char;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AutoStableStringChars {
            _unused: [u8; 0],
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum SourceOwnership {
            Borrowed = 0,
            TakeOwnership = 1,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SourceText<Unit> {
            /// |char16_t| or |Utf8Unit| source units of uncertain validity.
            pub units_: *const Unit,
            /// The length in code units of |units_|.
            pub length_: u32,
            /** Whether this owns |units_| or merely observes source units owned by some
 other object.*/
            pub ownsUnits_: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Unit>>,
        }
        pub type SourceText_CharT = root::std::conditional_t;
        #[repr(C)]
        pub struct ReadableStreamUnderlyingSource__bindgen_vtable(
            ::std::os::raw::c_void,
        );
        /** Abstract base class for external underlying sources.

 The term "underlying source" is defined in the Streams spec:
   https://streams.spec.whatwg.org/#underlying-source

 A `ReadableStreamUnderlyingSource` is an underlying source that is
 implemented in C++ rather than JS. It can be passed to
 `JS::NewReadableExternalSourceStreamObject` to create a custom,
 embedding-defined ReadableStream.

 There are several API difference between this class and the standard API for
 underlying sources implemented in JS:

 -   JS underlying sources can be either byte sources or non-byte sources.
     External underlying source are always byte sources.

 -   The C++ API does not bother with controller objects. Instead of using
     controller methods, the underlying source directly calls API functions
     like JS::ReadableStream{UpdateDataAvailableFromSource,Close,Error}.

 -   External readable streams are optimized to allow the embedding to
     interact with them with a minimum of overhead: chunks aren't enqueued as
     individual typed arrays; instead, the embedding only updates the amount
     of data available using
     JS::ReadableStreamUpdateDataAvailableFromSource. When JS requests data
     from a reader, writeIntoReadRequestBuffer is invoked, asking the
     embedding to write data directly into the buffer we're about to hand to
     JS.

 -   The C++ API provides extra callbacks onClosed() and onErrored().

 -   This class has a `finalize()` method, because C++ cares about lifetimes.

 Additionally, ReadableStreamGetExternalUnderlyingSource can be used to get
 the pointer to the underlying source. This locks the stream until it is
 released again using JS::ReadableStreamReleaseExternalUnderlyingSource.

 Embeddings can use this to optimize away the JS `ReadableStream` overhead
 when an embedding-defined C++ stream is passed to an embedding-defined C++
 consumer. For example, consider a ServiceWorker piping a `fetch` Response
 body to a TextDecoder. Instead of copying chunks of data into JS typed array
 buffers and creating a Promise per chunk, only to immediately resolve the
 Promises and read the data out again, the embedding can directly feed the
 incoming data to the TextDecoder.

 Compartment safety: All methods (except `finalize`) receive `cx` and
 `stream` arguments. SpiderMonkey enters the realm of the stream object
 before invoking these methods, so `stream` is never a wrapper. Other
 arguments may be wrappers.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct ReadableStreamUnderlyingSource {
            pub vtable_: *const ReadableStreamUnderlyingSource__bindgen_vtable,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReadableStreamMode {
            Default = 0,
            Byte = 1,
            ExternalSource = 2,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ReadableStreamReaderMode {
            Default = 0,
            Byob = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum WritableStreamState {
            Writable = 0,
            Closed = 1,
            Erroring = 2,
            Errored = 3,
        }
        #[repr(C)]
        pub struct WritableStreamUnderlyingSink__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct WritableStreamUnderlyingSink {
            pub vtable_: *const WritableStreamUnderlyingSink__bindgen_vtable,
        }
        /** The signature of a function that, when passed an |AbortSignal| instance, will
 return the value of its "aborted" flag.

 This function will be called while |signal|'s realm has been entered.*/
        pub type AbortSignalIsAborted = ::std::option::Option<
            unsafe extern "C" fn(signal: *mut root::JSObject) -> bool,
        >;
        /** Maximum length of a JS string. This is chosen so that the number of bytes
 allocated for a null-terminated TwoByte string still fits in int32_t.*/
        pub const MaxStringLength: u32 = 1073741822;
        #[repr(u32)]
        /** Indicates the "scope of validity" of serialized data.

 Writing plain JS data produces an array of bytes that can be copied and
 read in another process or whatever. The serialized data is Plain Old Data.
 However, HTML also supports `Transferable` objects, which, when cloned, can
 be moved from the source object into the clone, like when you take a
 photograph of someone and it steals their soul.
 See <https://developer.mozilla.org/en-US/docs/Web/API/Transferable>.
 We support cloning and transferring objects of many types.

 For example, when we transfer an ArrayBuffer (within a process), we "detach"
 the ArrayBuffer, embed the raw buffer pointer in the serialized data, and
 later install it in a new ArrayBuffer in the destination realm. Ownership
 of that buffer memory is transferred from the original ArrayBuffer to the
 serialized data and then to the clone.

 This only makes sense within a single address space. When we transfer an
 ArrayBuffer to another process, the contents of the buffer must be copied
 into the serialized data. (The original ArrayBuffer is still detached,
 though, for consistency; in some cases the caller shouldn't know or care if
 the recipient is in the same process.)

 ArrayBuffers are actually a lucky case; some objects (like MessagePorts)
 can't reasonably be stored by value in serialized data -- it's pointers or
 nothing.

 So there is a tradeoff between scope of validity -- how far away the
 serialized data may be sent and still make sense -- and efficiency or
 features. The read and write algorithms therefore take an argument of this
 type, allowing the user to control those trade-offs.*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum StructuredCloneScope {
            /** The most restrictive scope, with greatest efficiency and features.

 When writing, this means: The caller promises that the serialized data
 will **not** be shipped off to a different process or stored in a
 database. However, it may be shipped to another thread. It's OK to
 produce serialized data that contains pointers to data that is safe to
 send across threads, such as array buffers. In Rust terms, the
 serialized data will be treated as `Send` but not `Copy`.

 When reading, this means: Accept transferred objects and buffers
 (pointers). The caller promises that the serialized data was written
 using this API (otherwise, the serialized data may contain bogus
 pointers, leading to undefined behavior).

 Starts from 1 because there used to be a SameProcessSameThread enum value
 of 0 and these values are encoded into the structured serialization format
 as part of the SCTAG_HEADER, and IndexedDB persists the representation to
 disk.*/
            SameProcess = 1,
            /** When writing, this means we're writing for an audience in a different
 process. Produce serialized data that can be sent to other processes,
 bitwise copied, or even stored as bytes in a database and read by later
 versions of Firefox years from now. The HTML5 spec refers to this as
 "ForStorage" as in StructuredSerializeForStorage, though we use
 DifferentProcess for IPC as well as storage.

 Transferable objects are limited to ArrayBuffers, whose contents are
 copied into the serialized data (rather than just writing a pointer).

 When reading, this means: Do not accept pointers.*/
            DifferentProcess = 2,
            /** Handle a backwards-compatibility case with IndexedDB (bug 1434308): when
 reading, this means to treat legacy SameProcess data as if it were
 DifferentProcess.

 Do not use this for writing; use DifferentProcess instead.*/
            DifferentProcessForIndexedDB = 3,
            /** Existing code wants to be able to create an uninitialized
 JSStructuredCloneData without knowing the scope, then populate it with
 data (at which point the scope *is* known.)*/
            Unassigned = 4,
            /** This scope is used when the deserialization context is unknown. When
 writing, DifferentProcess or SameProcess scope is chosen based on the
 nature of the object.*/
            UnknownDestination = 5,
        }
        impl root::JS::TransferableOwnership {
            pub const SCTAG_TMO_ALLOC_DATA: root::JS::TransferableOwnership = TransferableOwnership::SCTAG_TMO_FIRST_OWNED;
        }
        #[repr(u32)]
        /** Values used to describe the ownership individual Transferables.

 Note that these *can* show up in DifferentProcess clones, since
 DifferentProcess ArrayBuffers can be Transferred. In that case, this will
 distinguish the specific ownership mechanism: is it a malloc pointer or a
 memory mapping?*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TransferableOwnership {
            /// Transferable data has not been filled in yet.
            SCTAG_TMO_UNFILLED = 0,
            /// Structured clone buffer does not yet own the data.
            SCTAG_TMO_UNOWNED = 1,
            /// All enum values at least this large are owned by the clone buffer.
            SCTAG_TMO_FIRST_OWNED = 2,
            /// Data is a memory mapped pointer.
            SCTAG_TMO_MAPPED_DATA = 3,
            /** Data is embedding-specific. The engine can free it by calling the
 freeTransfer op.*/
            SCTAG_TMO_CUSTOM = 4,
            /** Same as SCTAG_TMO_CUSTOM, but the embedding can also use
 SCTAG_TMO_USER_MIN and greater, up to 2^32-1, to distinguish specific
 ownership variants.*/
            SCTAG_TMO_USER_MIN = 5,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CloneDataPolicy {
            pub allowIntraClusterClonableSharedObjects_: bool,
            pub allowSharedMemoryObjects_: bool,
        }
        pub type WarningReporter = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                report: *mut root::JSErrorReport,
            ),
        >;
        /** A simple RAII class that clears the registered warning reporter on
 construction and restores it on destruction.

 A fresh warning reporter *may* be set while an instance of this class is
 live, but it must be unset in LIFO fashion by the time that instance is
 destroyed.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoSuppressWarningReporter {
            pub context_: *mut root::JSContext,
            pub prevReporter_: root::JS::WarningReporter,
        }
        #[repr(C)]
        pub struct WasmModule__bindgen_vtable(::std::os::raw::c_void);
        /** The WasmModule interface allows the embedding to hold a reference to the
 underying C++ implementation of a JS WebAssembly.Module object for purposes
 of efficient postMessage() and (de)serialization from a random thread.

 In particular, this allows postMessage() of a WebAssembly.Module:
 GetWasmModule() is called when making a structured clone of a payload
 containing a WebAssembly.Module object. The structured clone buffer holds a
 refcount of the JS::WasmModule until createObject() is called in the target
 agent's JSContext. The new WebAssembly.Module object continues to hold the
 JS::WasmModule and thus the final reference of a JS::WasmModule may be
 dropped from any thread and so the virtual destructor (and all internal
 methods of the C++ module) must be thread-safe.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct WasmModule {
            pub vtable_: *const WasmModule__bindgen_vtable,
            pub _base: root::js::AtomicRefCounted,
        }
        pub type TranscodeBuffer = u8;
        pub type TranscodeRange = root::mozilla::Range<u8>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TranscodeSource {
            pub range: root::JS::TranscodeRange,
            pub filename: *const ::std::os::raw::c_char,
            pub lineno: u32,
        }
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TranscodeResult {
            Ok = 0,
            Failure = 16,
            Failure_BadBuildId = 17,
            Failure_AsmJSNotSupported = 18,
            Failure_BadDecode = 19,
            Throw = 32,
        }
        pub const BytecodeOffsetAlignment: usize = 4;
        pub type Stencil = root::js::frontend::CompilationStencil;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct InstantiationStorage {
            pub gcOutput_: *mut root::js::frontend::PreallocatedCompilationGCOutput,
        }
        impl InstantiationStorage {
            #[inline]
            pub unsafe fn destruct(&mut self) {
                InstantiationStorage_InstantiationStorage_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBufferOrView {
            pub obj: *mut root::JSObject,
        }
        pub type ArrayBufferOrView_DataType = u8;
        impl ArrayBufferOrView {
            #[inline]
            pub unsafe fn unwrap(
                maybeWrapped: *mut root::JSObject,
            ) -> root::JS::ArrayBufferOrView {
                ArrayBufferOrView_unwrap(maybeWrapped)
            }
            #[inline]
            pub unsafe fn isDetached(&self) -> bool {
                ArrayBufferOrView_isDetached(self)
            }
            #[inline]
            pub unsafe fn isResizable(&self) -> bool {
                ArrayBufferOrView_isResizable(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBuffer {
            pub _base: root::JS::ArrayBufferOrView,
        }
        impl ArrayBuffer {
            #[inline]
            pub unsafe fn unwrap(
                maybeWrapped: *mut root::JSObject,
            ) -> root::JS::ArrayBuffer {
                ArrayBuffer_unwrap(maybeWrapped)
            }
            #[inline]
            pub unsafe fn create(
                cx: *mut root::JSContext,
                nbytes: usize,
            ) -> root::JS::ArrayBuffer {
                ArrayBuffer_create(cx, nbytes)
            }
            #[inline]
            pub unsafe fn getData(
                &mut self,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> [u32; 2usize] {
                ArrayBuffer_getData(self, isSharedMemory, arg1)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ArrayBufferView {
            pub _base: root::JS::ArrayBufferOrView,
        }
        impl ArrayBufferView {
            #[inline]
            pub unsafe fn isDetached(&self) -> bool {
                ArrayBufferView_isDetached(self)
            }
            #[inline]
            pub unsafe fn isResizable(&self) -> bool {
                ArrayBufferView_isResizable(self)
            }
            #[inline]
            pub unsafe fn getData(
                &mut self,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> [u32; 2usize] {
                ArrayBufferView_getData(self, isSharedMemory, arg1)
            }
            #[inline]
            pub unsafe fn getByteLength(
                &mut self,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> usize {
                ArrayBufferView_getByteLength(self, arg1)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct DataView {
            pub _base: root::JS::ArrayBufferView,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TypedArray_base {
            pub _base: root::JS::ArrayBufferView,
        }
        impl TypedArray_base {
            #[inline]
            pub unsafe fn fromObject(
                unwrapped: *mut root::JSObject,
            ) -> root::JS::TypedArray_base {
                TypedArray_base_fromObject(unwrapped)
            }
        }
        pub type TypedArray_DataType = root::JS::detail::ExternalTypeOf_t;
        pub type Int8Array = u32;
        pub type Uint8Array = u32;
        pub type Int16Array = u32;
        pub type Uint16Array = u32;
        pub type Int32Array = u32;
        pub type Uint32Array = u32;
        pub type Float32Array = u32;
        pub type Float64Array = u32;
        pub type Uint8ClampedArray = u32;
        pub type BigInt64Array = u32;
        pub type BigUint64Array = u32;
        pub type Float16Array = u32;
        #[repr(C)]
        pub struct ExpandoAndGeneration {
            pub expando: root::JS::Heap<root::JS::Value>,
            pub generation: u64,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum DOMProxyShadowsResult {
            ShadowCheckFailed = 0,
            Shadows = 1,
            DoesntShadow = 2,
            DoesntShadowUnique = 3,
            ShadowsViaDirectExpando = 4,
            ShadowsViaIndirectExpando = 5,
        }
        pub type DOMProxyShadowsCheck = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::Handle<*mut root::JSObject>,
                arg3: root::JS::Handle<root::JS::PropertyKey>,
            ) -> root::JS::DOMProxyShadowsResult,
        >;
        pub type GCVector_ElementType<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct StackGCVector {
            pub _address: u8,
        }
        pub type StackGCVector_Base = u8;
        pub type RootedVector_Vec = u8;
        /** Local variable of type T whose value is always rooted. This is typically
 used for local variables, or for non-rooted values being passed to a
 function that requires a handle, e.g. Foo(Root<T>(cx, x)).

 If you want to add additional methods to Rooted for a specific
 specialization, define a RootedOperations<T> specialization containing them.*/
        pub type RootedVector_Base = root::JS::Rooted<root::JS::RootedVector_Vec>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct PersistentRootedVector {
            pub _address: u8,
        }
        pub type PersistentRootedVector_Vec = u8;
        /** A copyable, assignable global GC root type with arbitrary lifetime, an
 infallible constructor, and automatic unrooting on destruction.

 These roots can be used in heap-allocated data structures, so they are not
 associated with any particular JSContext or stack. They are registered with
 the JSRuntime itself, without locking. Initialization may take place on
 construction, or in two phases if the no-argument constructor is called
 followed by init().

 Note that you must not use an PersistentRooted in an object owned by a JS
 object:

 Whenever one object whose lifetime is decided by the GC refers to another
 such object, that edge must be traced only if the owning JS object is traced.
 This applies not only to JS objects (which obviously are managed by the GC)
 but also to C++ objects owned by JS objects.

 If you put a PersistentRooted in such a C++ object, that is almost certainly
 a leak. When a GC begins, the referent of the PersistentRooted is treated as
 live, unconditionally (because a PersistentRooted is a *root*), even if the
 JS object that owns it is unreachable. If there is any path from that
 referent back to the JS object, then the C++ object containing the
 PersistentRooted will not be destructed, and the whole blob of objects will
 not be freed, even if there are no references to them from the outside.

 In the context of Firefox, this is a severe restriction: almost everything in
 Firefox is owned by some JS object or another, so using PersistentRooted in
 such objects would introduce leaks. For these kinds of edges, Heap<T> or
 TenuredHeap<T> would be better types. It's up to the implementor of the type
 containing Heap<T> or TenuredHeap<T> members to make sure their referents get
 marked when the object itself is marked.*/
        pub type PersistentRootedVector_Base = u8;
        /** A generic handle to an array of rooted values.

 The rooted array refernced can take several forms, therfore this is not the
 same as Handle<js::ValueArray>.*/
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleValueArray {
            pub length_: usize,
            pub elements_: *const root::JS::Value,
        }
        /** Install a process-wide callback to validate script filenames. The JS engine
 will invoke this callback for each JS script it parses or XDR decodes.

 If the callback returns |false|, an exception is thrown and parsing/decoding
 will be aborted.

 See also CompileOptions::setSkipFilenameValidation to opt-out of the callback
 for specific parse jobs.*/
        pub type FilenameValidationCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                filename: *const ::std::os::raw::c_char,
            ) -> bool,
        >;
        /** Install an context wide callback that implements the ECMA262 specification
 host hook `HostEnsureCanAddPrivateElement`.

 This hook, which should only be overriden for Web Browsers, examines the
 provided object to determine if the addition of a private field is allowed,
 throwing an exception and returning false if not.

 The default implementation of this hook, which will be used unless overriden,
 examines only proxy objects, and throws if the proxy handler returns true
 from the handler method `throwOnPrivateField()`.*/
        pub type EnsureCanAddPrivateElementOp = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                val: root::JS::HandleValue,
            ) -> bool,
        >;
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoBrittleMode {
            pub wasBrittle: bool,
            pub cx: *mut root::JSContext,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct TimeBudget {
            pub budget: root::mozilla::TimeDuration,
            pub deadline: root::mozilla::TimeStamp,
        }
        impl TimeBudget {
            #[inline]
            pub unsafe fn setDeadlineFromNow(&mut self) {
                TimeBudget_setDeadlineFromNow(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WorkBudget {
            pub budget: i64,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct UnlimitedBudget {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct SliceBudget {
            pub counter: i64,
            pub interruptRequested: *mut root::JS::SliceBudget_InterruptRequestFlag,
            pub budget: [u64; 3usize],
            pub interrupted: bool,
            pub idle: bool,
            pub extended: bool,
        }
        pub type SliceBudget_InterruptRequestFlag = u8;
        pub const SliceBudget_UnlimitedCounter: i64 = 9223372036854775807;
        pub const SliceBudget_StepsPerExpensiveCheck: i64 = 1000;
        impl SliceBudget {
            #[inline]
            pub unsafe fn describe(
                &self,
                buffer: *mut ::std::os::raw::c_char,
                maxlen: usize,
            ) -> ::std::os::raw::c_int {
                SliceBudget_describe(self, buffer, maxlen)
            }
            #[inline]
            pub unsafe fn new(
                time: root::JS::TimeBudget,
                interrupt: *mut root::JS::SliceBudget_InterruptRequestFlag,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SliceBudget_SliceBudget(__bindgen_tmp.as_mut_ptr(), time, interrupt);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(work: root::JS::WorkBudget) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SliceBudget_SliceBudget1(__bindgen_tmp.as_mut_ptr(), work);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCOptions {
            Normal = 0,
            Shrink = 1,
            Shutdown = 2,
        }
        impl root::JS::GCReason {
            pub const DOM_WINDOW_UTILS: root::JS::GCReason = GCReason::FIRST_FIREFOX_REASON;
        }
        impl root::JS::GCReason {
            pub const RESERVED1: root::JS::GCReason = GCReason::FIRST_RESERVED_REASON;
        }
        impl root::JS::GCReason {
            pub const NUM_TELEMETRY_REASONS: root::JS::GCReason = GCReason::NUM_REASONS;
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCReason {
            FIRST_FIREFOX_REASON = 33,
            FIRST_RESERVED_REASON = 90,
            API = 0,
            EAGER_ALLOC_TRIGGER = 1,
            DESTROY_RUNTIME = 2,
            ROOTS_REMOVED = 3,
            LAST_DITCH = 4,
            TOO_MUCH_MALLOC = 5,
            ALLOC_TRIGGER = 6,
            DEBUG_GC = 7,
            COMPARTMENT_REVIVED = 8,
            RESET = 9,
            OUT_OF_NURSERY = 10,
            EVICT_NURSERY = 11,
            SHARED_MEMORY_LIMIT = 13,
            EAGER_NURSERY_COLLECTION = 14,
            BG_TASK_FINISHED = 15,
            ABORT_GC = 16,
            FULL_WHOLE_CELL_BUFFER = 17,
            FULL_GENERIC_BUFFER = 18,
            FULL_VALUE_BUFFER = 19,
            FULL_CELL_PTR_OBJ_BUFFER = 20,
            FULL_SLOT_BUFFER = 21,
            FULL_SHAPE_BUFFER = 22,
            TOO_MUCH_WASM_MEMORY = 23,
            DISABLE_GENERATIONAL_GC = 24,
            FINISH_GC = 25,
            PREPARE_FOR_TRACING = 26,
            FULL_WASM_ANYREF_BUFFER = 27,
            FULL_CELL_PTR_STR_BUFFER = 28,
            TOO_MUCH_JIT_CODE = 29,
            FULL_CELL_PTR_BIGINT_BUFFER = 30,
            NURSERY_TRAILERS = 31,
            NURSERY_MALLOC_BUFFERS = 32,
            COMPONENT_UTILS = 34,
            MEM_PRESSURE = 35,
            CC_FINISHED = 36,
            CC_FORCED = 37,
            LOAD_END = 38,
            UNUSED3 = 39,
            PAGE_HIDE = 40,
            NSJSCONTEXT_DESTROY = 41,
            WORKER_SHUTDOWN = 42,
            SET_DOC_SHELL = 43,
            DOM_UTILS = 44,
            DOM_IPC = 45,
            DOM_WORKER = 46,
            INTER_SLICE_GC = 47,
            UNUSED1 = 48,
            FULL_GC_TIMER = 49,
            SHUTDOWN_CC = 50,
            UNUSED2 = 51,
            USER_INACTIVE = 52,
            XPCONNECT_SHUTDOWN = 53,
            DOCSHELL = 54,
            HTML_PARSER = 55,
            DOM_TESTUTILS = 56,
            PREPARE_FOR_PAGELOAD = 57,
            RESERVED2 = 91,
            RESERVED3 = 92,
            RESERVED4 = 93,
            RESERVED5 = 94,
            RESERVED6 = 95,
            RESERVED7 = 96,
            RESERVED8 = 97,
            RESERVED9 = 98,
            NO_REASON = 99,
            NUM_REASONS = 100,
        }
        pub mod dbg {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct GarbageCollectionEvent {
                pub majorGCNumber_: u64,
                pub reason: *const ::std::os::raw::c_char,
                pub nonincrementalReason: *const ::std::os::raw::c_char,
                pub collections: [u32; 5usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct GarbageCollectionEvent_Collection {
                pub startTimestamp: root::mozilla::TimeStamp,
                pub endTimestamp: root::mozilla::TimeStamp,
            }
            pub type GarbageCollectionEvent_Ptr = u8;
            impl GarbageCollectionEvent {
                #[inline]
                pub unsafe fn Create(
                    rt: *mut root::JSRuntime,
                    stats: *mut root::js::gcstats::Statistics,
                    majorGCNumber: u64,
                ) -> root::JS::dbg::GarbageCollectionEvent_Ptr {
                    GarbageCollectionEvent_Create(rt, stats, majorGCNumber)
                }
                #[inline]
                pub unsafe fn toJSObject(
                    &self,
                    cx: *mut root::JSContext,
                ) -> *mut root::JSObject {
                    GarbageCollectionEvent_toJSObject(self, cx)
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Builder {
                pub debuggerObject: root::JS::PersistentRootedObject,
                pub debugger: *mut root::js::Debugger,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Builder_BuiltThing {
                pub owner: *mut root::JS::dbg::Builder,
                pub value: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct Builder_Object {
                pub _base: root::JS::dbg::Builder_BuiltThing,
            }
            pub type Builder_Object_Base = root::JS::dbg::Builder_BuiltThing;
            impl Builder_Object {
                #[inline]
                pub unsafe fn defineProperty(
                    &mut self,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: root::JS::HandleValue,
                ) -> bool {
                    Builder_Object_defineProperty(self, cx, name, value)
                }
                #[inline]
                pub unsafe fn defineProperty1(
                    &mut self,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: root::JS::HandleObject,
                ) -> bool {
                    Builder_Object_defineProperty1(self, cx, name, value)
                }
                #[inline]
                pub unsafe fn defineProperty2(
                    &mut self,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: *mut root::JS::dbg::Builder_Object,
                ) -> bool {
                    Builder_Object_defineProperty2(self, cx, name, value)
                }
            }
            impl Builder {
                #[inline]
                pub unsafe fn newObject(
                    &mut self,
                    cx: *mut root::JSContext,
                ) -> root::JS::dbg::Builder_Object {
                    Builder_newObject(self, cx)
                }
                #[inline]
                pub unsafe fn new(
                    cx: *mut root::JSContext,
                    debugger: *mut root::js::Debugger,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    Builder_Builder(__bindgen_tmp.as_mut_ptr(), cx, debugger);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BuilderOrigin {
                pub _base: root::JS::dbg::Builder,
            }
            #[repr(C)]
            pub struct AutoEntryMonitor__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct AutoEntryMonitor {
                pub vtable_: *const AutoEntryMonitor__bindgen_vtable,
                pub cx_: *mut root::JSContext,
                pub savedMonitor_: *mut root::JS::dbg::AutoEntryMonitor,
            }
            impl AutoEntryMonitor {
                #[inline]
                pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AutoEntryMonitor_AutoEntryMonitor(__bindgen_tmp.as_mut_ptr(), cx);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    AutoEntryMonitor_AutoEntryMonitor_destructor(self)
                }
            }
            extern "C" {
                #[link_name = "\u{1}_ZN2JS3dbg22GarbageCollectionEvent6CreateEP9JSRuntimeRN2js7gcstats10StatisticsEy"]
                pub fn GarbageCollectionEvent_Create(
                    rt: *mut root::JSRuntime,
                    stats: *mut root::js::gcstats::Statistics,
                    majorGCNumber: u64,
                ) -> root::JS::dbg::GarbageCollectionEvent_Ptr;
                #[link_name = "\u{1}_ZNK2JS3dbg22GarbageCollectionEvent10toJSObjectEP9JSContext"]
                pub fn GarbageCollectionEvent_toJSObject(
                    this: *const root::JS::dbg::GarbageCollectionEvent,
                    cx: *mut root::JSContext,
                ) -> *mut root::JSObject;
                #[link_name = "\u{1}_ZN2JS3dbg7Builder6Object14definePropertyEP9JSContextPKcNS_6HandleINS_5ValueEEE"]
                pub fn Builder_Object_defineProperty(
                    this: *mut root::JS::dbg::Builder_Object,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: root::JS::HandleValue,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg7Builder6Object14definePropertyEP9JSContextPKcNS_6HandleIP8JSObjectEE"]
                pub fn Builder_Object_defineProperty1(
                    this: *mut root::JS::dbg::Builder_Object,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: root::JS::HandleObject,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg7Builder6Object14definePropertyEP9JSContextPKcRS2_"]
                pub fn Builder_Object_defineProperty2(
                    this: *mut root::JS::dbg::Builder_Object,
                    cx: *mut root::JSContext,
                    name: *const ::std::os::raw::c_char,
                    value: *mut root::JS::dbg::Builder_Object,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg7Builder9newObjectEP9JSContext"]
                pub fn Builder_newObject(
                    this: *mut root::JS::dbg::Builder,
                    cx: *mut root::JSContext,
                ) -> root::JS::dbg::Builder_Object;
                #[link_name = "\u{1}_ZN2JS3dbg7BuilderC1EP9JSContextPN2js8DebuggerE"]
                pub fn Builder_Builder(
                    this: *mut root::JS::dbg::Builder,
                    cx: *mut root::JSContext,
                    debugger: *mut root::js::Debugger,
                ) -> *mut ::std::os::raw::c_void;
                #[link_name = "\u{1}_ZN2JS3dbg23SetDebuggerMallocSizeOfEP9JSContextPFmPKvE"]
                pub fn SetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                    mallocSizeOf: root::mozilla::MallocSizeOf,
                );
                #[link_name = "\u{1}_ZN2JS3dbg23GetDebuggerMallocSizeOfEP9JSContext"]
                pub fn GetDebuggerMallocSizeOf(
                    cx: *mut root::JSContext,
                ) -> root::mozilla::MallocSizeOf;
                #[link_name = "\u{1}_ZN2JS3dbg35FireOnGarbageCollectionHookRequiredEP9JSContext"]
                pub fn FireOnGarbageCollectionHookRequired(
                    cx: *mut root::JSContext,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg27FireOnGarbageCollectionHookEP9JSContextON7mozilla9UniquePtrINS0_22GarbageCollectionEventENS_12DeletePolicyIS5_EEEE"]
                pub fn FireOnGarbageCollectionHook(
                    cx: *mut root::JSContext,
                    data: *mut root::JS::dbg::GarbageCollectionEvent_Ptr,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg10IsDebuggerER8JSObject"]
                pub fn IsDebugger(obj: *mut root::JSObject) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg18GetDebuggeeGlobalsEP9JSContextR8JSObjectNS_13MutableHandleINS_13StackGCVectorIPS3_N2js15TempAllocPolicyEEEEE"]
                pub fn GetDebuggeeGlobals(
                    cx: *mut root::JSContext,
                    dbgObj: *mut root::JSObject,
                    vector: root::JS::MutableHandleObjectVector,
                ) -> bool;
                #[link_name = "\u{1}_ZN2JS3dbg16AutoEntryMonitorC2EP9JSContext"]
                pub fn AutoEntryMonitor_AutoEntryMonitor(
                    this: *mut root::JS::dbg::AutoEntryMonitor,
                    cx: *mut root::JSContext,
                ) -> *mut ::std::os::raw::c_void;
                #[link_name = "\u{1}_ZN2JS3dbg16AutoEntryMonitorD1Ev"]
                pub fn AutoEntryMonitor_AutoEntryMonitor_destructor(
                    this: *mut root::JS::dbg::AutoEntryMonitor,
                );
                #[link_name = "\u{1}_ZN2JS3dbg22ShouldAvoidSideEffectsEP9JSContext"]
                pub fn ShouldAvoidSideEffects(cx: *mut root::JSContext) -> bool;
            }
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCProgress {
            GC_CYCLE_BEGIN = 0,
            GC_SLICE_BEGIN = 1,
            GC_SLICE_END = 2,
            GC_CYCLE_END = 3,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct GCDescription {
            pub isZone_: bool,
            pub isComplete_: bool,
            pub options_: root::JS::GCOptions,
            pub reason_: root::JS::GCReason,
        }
        impl GCDescription {
            #[inline]
            pub unsafe fn formatSliceMessage(
                &self,
                cx: *mut root::JSContext,
            ) -> *mut u16 {
                GCDescription_formatSliceMessage(self, cx)
            }
            #[inline]
            pub unsafe fn formatSummaryMessage(
                &self,
                cx: *mut root::JSContext,
            ) -> *mut u16 {
                GCDescription_formatSummaryMessage(self, cx)
            }
            #[inline]
            pub unsafe fn startTime(
                &self,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp {
                GCDescription_startTime(self, cx)
            }
            #[inline]
            pub unsafe fn endTime(
                &self,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp {
                GCDescription_endTime(self, cx)
            }
            #[inline]
            pub unsafe fn lastSliceStart(
                &self,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp {
                GCDescription_lastSliceStart(self, cx)
            }
            #[inline]
            pub unsafe fn lastSliceEnd(
                &self,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp {
                GCDescription_lastSliceEnd(self, cx)
            }
            #[inline]
            pub unsafe fn sliceToJSONProfiler(
                &self,
                cx: *mut root::JSContext,
            ) -> root::JS::UniqueChars {
                GCDescription_sliceToJSONProfiler(self, cx)
            }
            #[inline]
            pub unsafe fn formatJSONProfiler(
                &self,
                cx: *mut root::JSContext,
            ) -> root::JS::UniqueChars {
                GCDescription_formatJSONProfiler(self, cx)
            }
            #[inline]
            pub unsafe fn toGCEvent(
                &self,
                cx: *mut root::JSContext,
            ) -> root::JS::dbg::GarbageCollectionEvent_Ptr {
                GCDescription_toGCEvent(self, cx)
            }
        }
        pub type GCSliceCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCProgress,
                desc: *const root::JS::GCDescription,
            ),
        >;
        #[repr(i32)]
        /// Describes the progress of an observed nursery collection.
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum GCNurseryProgress {
            /// The nursery collection is starting.
            GC_NURSERY_COLLECTION_START = 0,
            /// The nursery collection is ending.
            GC_NURSERY_COLLECTION_END = 1,
        }
        /** A nursery collection callback receives the progress of the nursery collection
 and the reason for the collection.*/
        pub type GCNurseryCollectionCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                progress: root::JS::GCNurseryProgress,
                reason: root::JS::GCReason,
                data: *mut ::std::os::raw::c_void,
            ),
        >;
        pub type DoCycleCollectionCallback = ::std::option::Option<
            unsafe extern "C" fn(cx: *mut root::JSContext),
        >;
        pub type CreateSliceBudgetCallback = ::std::option::Option<
            unsafe extern "C" fn(
                reason: root::JS::GCReason,
                millis: i64,
            ) -> root::JS::SliceBudget,
        >;
        /** Ensure that generational GC is disabled within some scope.

 This evicts the nursery and discards JIT code so it is not a lightweight
 operation.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoDisableGenerationalGC {
            pub cx: *mut root::JSContext,
        }
        impl AutoDisableGenerationalGC {
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoDisableGenerationalGC_AutoDisableGenerationalGC(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoDisableGenerationalGC_AutoDisableGenerationalGC_destructor(self)
            }
        }
        /** Pass a subclass of this "abstract" class to callees to require that they
 never GC. Subclasses can use assertions or the hazard analysis to ensure no
 GC happens.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoRequireNoGC {
            pub _address: u8,
        }
        /** Diagnostic assert (see MOZ_DIAGNOSTIC_ASSERT) that GC cannot occur while this
 class is live. This class does not disable the static rooting hazard
 analysis.

 This works by entering a GC unsafe region, which is checked on allocation and
 on GC.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertNoGC {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoSuppressGCAnalysis {
            pub _address: u8,
        }
        /** Assert that code is only ever called from a GC callback, disable the static
 rooting hazard analysis and assert if any allocation that could potentially
 trigger a GC occurs while this guard object is live.

 This is useful to make the static analysis ignore code that runs in GC
 callbacks.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoAssertGCCallback {
            pub _address: u8,
        }
        impl AutoAssertGCCallback {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoAssertGCCallback_AutoAssertGCCallback(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoCheckCannotGC {
            pub _address: u8,
        }
        pub const ShellDefaultGCZealFrequency: u32 = 100;
        pub const BrowserDefaultGCZealFrequency: u32 = 5000;
        #[repr(C)]
        pub struct ErrorReportBuilder {
            pub reportp: *mut root::JSErrorReport,
            pub ownedReport: root::JSErrorReport,
            pub exnObject: root::JS::RootedObject,
            pub filename: root::JS::UniqueChars,
            pub toStringResult_: root::JS::ConstUTF8CharsZ,
            pub toStringResultBytesStorage: root::JS::UniqueChars,
        }
        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ErrorReportBuilder_SniffingBehavior {
            WithSideEffects = 0,
            NoSideEffects = 1,
        }
        impl ErrorReportBuilder {
            #[inline]
            pub unsafe fn init(
                &mut self,
                cx: *mut root::JSContext,
                exnStack: *const root::JS::ExceptionStack,
                sniffingBehavior: root::JS::ErrorReportBuilder_SniffingBehavior,
            ) -> bool {
                ErrorReportBuilder_init(self, cx, exnStack, sniffingBehavior)
            }
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ErrorReportBuilder_ErrorReportBuilder(__bindgen_tmp.as_mut_ptr(), cx);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ErrorReportBuilder_ErrorReportBuilder_destructor(self)
            }
        }
        pub const MaxNumErrorArguments: u16 = 10;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStackBehavior {
            DoNotCapture = 0,
            Capture = 1,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum ExceptionStatus {
            None = 0,
            ForcedReturn = 1,
            Throwing = 2,
            OutOfMemory = 3,
            OverRecursed = 4,
        }
        #[repr(C)]
        pub struct ExceptionStack {
            pub exception_: root::JS::Rooted<root::JS::Value>,
            pub stack_: root::JS::Rooted<*mut root::JSObject>,
        }
        /** Save and later restore the current exception state of a given JSContext.
 This is useful for implementing behavior in C++ that's like try/catch
 or try/finally in JS.

 Typical usage:

     bool ok = JS::Evaluate(cx, ...);
     AutoSaveExceptionState savedExc(cx);
     ... cleanup that might re-enter JS ...
     return ok;*/
        #[repr(C)]
        pub struct AutoSaveExceptionState {
            pub context: *mut root::JSContext,
            pub status: root::JS::ExceptionStatus,
            pub exceptionValue: root::JS::RootedValue,
            pub exceptionStack: root::JS::RootedObject,
        }
        impl AutoSaveExceptionState {
            #[inline]
            pub unsafe fn drop(&mut self) {
                AutoSaveExceptionState_drop(self)
            }
            #[inline]
            pub unsafe fn restore(&mut self) {
                AutoSaveExceptionState_restore(self)
            }
            #[inline]
            pub unsafe fn new(cx: *mut root::JSContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoSaveExceptionState_AutoSaveExceptionState(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoSaveExceptionState_AutoSaveExceptionState_destructor(self)
            }
        }
        #[repr(u32)]
        /** During global creation, we fire notifications to callbacks registered
 via the Debugger API. These callbacks are arbitrary script, and can touch
 the global in arbitrary ways. When that happens, the global should not be
 in a half-baked state. But this creates a problem for consumers that need
 to set slots on the global to put it in a consistent state.

 This API provides a way for consumers to set slots atomically (immediately
 after the global is created), before any debugger hooks are fired. It's
 unfortunately on the clunky side, but that's the way the cookie crumbles.

 If callers have no additional state on the global to set up, they may pass
 |FireOnNewGlobalHook| to JS_NewGlobalObject, which causes that function to
 fire the hook as its final act before returning. Otherwise, callers should
 pass |DontFireOnNewGlobalHook|, which means that they are responsible for
 invoking JS_FireOnNewGlobalObject upon successfully creating the global. If
 an error occurs and the operation aborts, callers should skip firing the
 hook. But otherwise, callers must take care to fire the hook exactly once
 before compiling any script in the global's scope (we have assertions in
 place to enforce this). This lets us be sure that debugger clients never miss
 breakpoints.*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum OnNewGlobalHookOption {
            FireOnNewGlobalHook = 0,
            DontFireOnNewGlobalHook = 1,
        }
        /** If a large allocation fails when calling pod_{calloc,realloc}CanGC, the JS
 engine may call the large-allocation-failure callback, if set, to allow the
 embedding to flush caches, possibly perform shrinking GCs, etc. to make some
 room. The allocation will then be retried (and may still fail.) This callback
 can be called on any thread and must be set at most once in a process.*/
        pub type LargeAllocationFailureCallback = ::std::option::Option<
            unsafe extern "C" fn(),
        >;
        /** Unlike the error reporter, which is only called if the exception for an OOM
 bubbles up and is not caught, the OutOfMemoryCallback is called immediately
 at the OOM site to allow the embedding to capture the current state of heap
 allocation before anything is freed. If the large-allocation-failure callback
 is called at all (not all allocation sites call the large-allocation-failure
 callback on failure), it is called before the out-of-memory callback; the
 out-of-memory callback is only called if the allocation still fails after the
 large-allocation-failure callback has returned.*/
        pub type OutOfMemoryCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >;
        #[repr(u8)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MemoryUse {
            XPCWrappedNative = 0,
            DOMBinding = 1,
            CTypeFFIType = 2,
            CTypeFFITypeElements = 3,
            CTypeFunctionInfo = 4,
            CTypeFieldInfo = 5,
            CDataBufferPtr = 6,
            CDataBuffer = 7,
            CClosureInfo = 8,
            CTypesInt64 = 9,
            Embedding1 = 10,
            Embedding2 = 11,
            Embedding3 = 12,
            Embedding4 = 13,
            Embedding5 = 14,
        }
        pub type IdVector = u8;
        pub type IterateRealmCallback = ::std::option::Option<
            unsafe extern "C" fn(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realm: *mut root::JS::Realm,
                nogc: *const root::JS::AutoRequireNoGC,
            ),
        >;
        #[repr(i32)]
        /** An enum that JSIterateCompartmentCallback can return to indicate
 whether to keep iterating.*/
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum CompartmentIterResult {
            KeepGoing = 0,
            Stop = 1,
        }
        /** Hooks called when references to a script private value are created or
 destroyed. This allows use of a reference counted object as the
 script private.*/
        pub type ScriptPrivateReferenceHook = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::JS::Value),
        >;
        #[repr(C)]
        pub struct OptimizedEncodingListener__bindgen_vtable(::std::os::raw::c_void);
        /** The ConsumeStreamCallback is called from an active JSContext, passing a
 StreamConsumer that wishes to consume the given host object as a stream of
 bytes with the given MIME type. On failure, the embedding must report the
 appropriate error on 'cx'. On success, the embedding must call
 consumer->consumeChunk() repeatedly on any thread until exactly one of:
  - consumeChunk() returns false
  - the embedding calls consumer->streamEnd()
  - the embedding calls consumer->streamError()
 before JS_DestroyContext(cx) or JS::ShutdownAsyncTasks(cx) is called.

 Note: consumeChunk(), streamEnd() and streamError() may be called
 synchronously by ConsumeStreamCallback.

 When streamEnd() is called, the embedding may optionally pass an
 OptimizedEncodingListener*, indicating that there is a cache entry associated
 with this stream that can store an optimized encoding of the bytes that were
 just streamed at some point in the future by having SpiderMonkey call
 storeOptimizedEncoding(). Until the optimized encoding is ready, SpiderMonkey
 will hold an outstanding refcount to keep the listener alive.

 After storeOptimizedEncoding() is called, on cache hit, the embedding
 may call consumeOptimizedEncoding() instead of consumeChunk()/streamEnd().
 The embedding must ensure that the GetOptimizedEncodingBuildId() (see
 js/BuildId.h) at the time when an optimized encoding is created is the same
 as when it is later consumed.*/
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct OptimizedEncodingListener {
            pub vtable_: *const OptimizedEncodingListener__bindgen_vtable,
        }
        #[repr(C)]
        pub struct StreamConsumer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct StreamConsumer {
            pub vtable_: *const StreamConsumer__bindgen_vtable,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum MimeType {
            Wasm = 0,
        }
        pub type ConsumeStreamCallback = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::JSContext,
                arg2: root::JS::HandleObject,
                arg3: root::JS::MimeType,
                arg4: *mut root::JS::StreamConsumer,
            ) -> bool,
        >;
        pub type ReportStreamErrorCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::JSContext, arg2: usize),
        >;
        /// Timing information for telemetry purposes
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSTimers {
            pub executionTime: root::mozilla::TimeDuration,
            pub delazificationTime: root::mozilla::TimeDuration,
            pub xdrEncodingTime: root::mozilla::TimeDuration,
            pub gcTime: root::mozilla::TimeDuration,
            pub protectTime: root::mozilla::TimeDuration,
            pub baselineCompileTime: root::mozilla::TimeDuration,
        }
        /** When the JSRuntime is about to block in an Atomics.wait() JS call or in a
 `wait` instruction in WebAssembly, it can notify the host by means of a call
 to BeforeWaitCallback.  After the wait, it can notify the host by means of a
 call to AfterWaitCallback.  Both callbacks must be null, or neither.

 (If you change the callbacks from null to not-null or vice versa while some
 thread on the runtime is in a wait, you will be sorry.)

 The argument to the BeforeWaitCallback is a pointer to uninitialized
 stack-allocated working memory of size WAIT_CALLBACK_CLIENT_MAXMEM bytes.
 The caller of SetWaitCallback() must pass the amount of memory it will need,
 and this amount will be checked against that limit and the process will crash
 reliably if the check fails.

 The value returned by the BeforeWaitCallback will be passed to the
 AfterWaitCallback.

 The AfterWaitCallback will be called even if the wakeup is spurious and the
 thread goes right back to waiting again.  Of course the thread will call the
 BeforeWaitCallback once more before it goes to sleep in this situation.*/
        pub const WAIT_CALLBACK_CLIENT_MAXMEM: usize = 32;
        pub type BeforeWaitCallback = ::std::option::Option<
            unsafe extern "C" fn(memory: *mut u8) -> *mut ::std::os::raw::c_void,
        >;
        pub type AfterWaitCallback = ::std::option::Option<
            unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void),
        >;
        pub type ValueVector = u8;
        pub type ScriptVector = u8;
        pub type StringVector = u8;
        /** Supply an alternative stack to incorporate into captured SavedFrame
 backtraces as the imputed caller of asynchronous JavaScript calls, like async
 function resumptions and DOM callbacks.

 When one async function awaits the result of another, it's natural to think
 of that as a sort of function call: just as execution resumes from an
 ordinary call expression when the callee returns, with the return value
 providing the value of the call expression, execution resumes from an 'await'
 expression after the awaited asynchronous function call returns, passing the
 return value along.

 Call the two async functions in such a situation the 'awaiter' and the
 'awaitee'.

 As an async function, the awaitee contains 'await' expressions of its own.
 Whenever it executes after its first 'await', there are never any actual
 frames on the JavaScript stack under it; its awaiter is certainly not there.
 An await expression's continuation is invoked as a promise callback, and
 those are always called directly from the event loop in their own microtick.
 (Ignore unusual cases like nested event loops.)

 But because await expressions bear such a strong resemblance to calls (and
 deliberately so!), it would be unhelpful for stacks captured within the
 awaitee to be empty; instead, they should present the awaiter as the caller.

 The AutoSetAsyncStackForNewCalls RAII class supplies a SavedFrame stack to
 treat as the caller of any JavaScript invocations that occur within its
 lifetime. Any SavedFrame stack captured during such an invocation uses the
 SavedFrame passed to the constructor's 'stack' parameter as the 'asyncParent'
 property of the SavedFrame for the invocation's oldest frame. Its 'parent'
 property will be null, so stack-walking code can distinguish this
 awaiter/awaitee transition from an ordinary caller/callee transition.

 The constructor's 'asyncCause' parameter supplies a string explaining what
 sort of asynchronous call caused 'stack' to be spliced into the backtrace;
 for example, async function resumptions use the string "async". This appears
 as the 'asyncCause' property of the 'asyncParent' SavedFrame.

 Async callers are distinguished in the string form of a SavedFrame chain by
 including the 'asyncCause' string in the frame. It appears before the
 function name, with the two separated by a '*'.

 Note that, as each compartment has its own set of SavedFrames, the
 'asyncParent' may actually point to a copy of 'stack', rather than the exact
 SavedFrame object passed.

 The youngest frame of 'stack' is not mutated to take the asyncCause string as
 its 'asyncCause' property; SavedFrame objects are immutable. Rather, a fresh
 clone of the frame is created with the needed 'asyncCause' property.

 The 'kind' argument specifies how aggressively 'stack' supplants any
 JavaScript frames older than this AutoSetAsyncStackForNewCalls object. If
 'kind' is 'EXPLICIT', then all captured SavedFrame chains take on 'stack' as
 their 'asyncParent' where the chain crosses this object's scope. If 'kind' is
 'IMPLICIT', then 'stack' is only included in captured chains if there are no
 other JavaScript frames on the stack --- that is, only if the stack would
 otherwise end at that point.

 AutoSetAsyncStackForNewCalls affects only SavedFrame chains; it does not
 affect Debugger.Frame or js::FrameIter. SavedFrame chains are used for
 Error.stack, allocation profiling, Promise debugging, and so on.

 See also `js/src/doc/SavedFrame/SavedFrame.md` for documentation on async
 stack frames.*/
        #[repr(C)]
        pub struct AutoSetAsyncStackForNewCalls {
            pub cx: *mut root::JSContext,
            pub oldAsyncStack: root::JS::RootedObject,
            pub oldAsyncCause: *const ::std::os::raw::c_char,
            pub oldAsyncCallIsExplicit: bool,
        }
        #[repr(i32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum AutoSetAsyncStackForNewCalls_AsyncCallKind {
            IMPLICIT = 0,
            EXPLICIT = 1,
        }
        impl AutoSetAsyncStackForNewCalls {
            #[inline]
            pub unsafe fn new(
                cx: *mut root::JSContext,
                stack: root::JS::HandleObject,
                asyncCause: *const ::std::os::raw::c_char,
                kind: root::JS::AutoSetAsyncStackForNewCalls_AsyncCallKind,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AutoSetAsyncStackForNewCalls_AutoSetAsyncStackForNewCalls(
                    __bindgen_tmp.as_mut_ptr(),
                    cx,
                    stack,
                    asyncCause,
                    kind,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                AutoSetAsyncStackForNewCalls_AutoSetAsyncStackForNewCalls_destructor(
                    self,
                )
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoFilename {
            pub ss_: *mut root::js::ScriptSource,
            pub filename_: [u32; 2usize],
        }
        impl AutoFilename {
            #[inline]
            pub unsafe fn reset(&mut self) {
                AutoFilename_reset(self)
            }
            #[inline]
            pub unsafe fn setOwned(&mut self, filename: *mut root::JS::UniqueChars) {
                AutoFilename_setOwned(self, filename)
            }
            #[inline]
            pub unsafe fn setUnowned(
                &mut self,
                filename: *const ::std::os::raw::c_char,
            ) {
                AutoFilename_setUnowned(self, filename)
            }
            #[inline]
            pub unsafe fn setScriptSource(&mut self, ss: *mut root::js::ScriptSource) {
                AutoFilename_setScriptSource(self, ss)
            }
            #[inline]
            pub unsafe fn get(&self) -> *const ::std::os::raw::c_char {
                AutoFilename_get(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct AutoHideScriptedCaller {
            pub mContext: *mut root::JSContext,
        }
        /// <div rustbindgen replaces="JS::CallArgs"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct CallArgs {
            pub argv_: *mut root::JS::Value,
            pub argc_: ::std::os::raw::c_uint,
            pub _bitfield_align_1: [u8; 0],
            pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
            pub wantUsedRval_: root::JS::detail::IncludeUsedRval,
        }
        impl CallArgs {
            #[inline]
            pub fn constructing_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_constructing_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(0usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn ignoresReturnValue_(&self) -> bool {
                unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
            }
            #[inline]
            pub fn set_ignoresReturnValue_(&mut self, val: bool) {
                unsafe {
                    let val: u8 = ::std::mem::transmute(val);
                    self._bitfield_1.set(1usize, 1u8, val as u64)
                }
            }
            #[inline]
            pub fn new_bitfield_1(
                constructing_: bool,
                ignoresReturnValue_: bool,
            ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
                let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<
                    [u8; 1usize],
                > = Default::default();
                __bindgen_bitfield_unit
                    .set(
                        0usize,
                        1u8,
                        {
                            let constructing_: u8 = unsafe {
                                ::std::mem::transmute(constructing_)
                            };
                            constructing_ as u64
                        },
                    );
                __bindgen_bitfield_unit
                    .set(
                        1usize,
                        1u8,
                        {
                            let ignoresReturnValue_: u8 = unsafe {
                                ::std::mem::transmute(ignoresReturnValue_)
                            };
                            ignoresReturnValue_ as u64
                        },
                    );
                __bindgen_bitfield_unit
            }
        }
        /// <div rustbindgen replaces="JS::MutableHandleIdVector"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleIdVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        /// <div rustbindgen replaces="JS::HandleObjectVector"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct HandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        /// <div rustbindgen replaces="JS::MutableHandleObjectVector"></div>
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct MutableHandleObjectVector {
            pub ptr: *mut ::std::os::raw::c_void,
        }
        extern "C" {
            /// Create a new ArrayBuffer with the given byte length.
            #[link_name = "\u{1}_ZN2JS14NewArrayBufferEP9JSContextm"]
            pub fn NewArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
            ) -> *mut root::JSObject;
            /** Create a new ArrayBuffer with the given |contents|, which may be null only
 if |nbytes == 0|.  |contents| must be allocated compatible with deallocation
 by |JS_free|.

 Care must be taken that |nbytes| bytes of |contents| remain valid for the
 duration of this call.  In particular, passing the length/pointer of existing
 typed array or ArrayBuffer data is generally unsafe: if a GC occurs during a
 call to this function, it could move those contents to a different location
 and invalidate the provided pointer.*/
            #[link_name = "\u{1}_ZN2JS26NewArrayBufferWithContentsEP9JSContextmN7mozilla9UniquePtrIvNS_10FreePolicyEEE"]
            pub fn NewArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: u32,
            ) -> *mut root::JSObject;
            /** Create a new ArrayBuffer with the given |contents|, which may be null only
 if |nbytes == 0|.  |contents| must be allocated compatible with deallocation
 by |JS_free|.

 !!! IMPORTANT !!!
 If and only if an ArrayBuffer is successfully created and returned,
 ownership of |contents| is transferred to the new ArrayBuffer.

 Care must be taken that |nbytes| bytes of |contents| remain valid for the
 duration of this call.  In particular, passing the length/pointer of existing
 typed array or ArrayBuffer data is generally unsafe: if a GC occurs during a
 call to this function, it could move those contents to a different location
 and invalidate the provided pointer.*/
            #[link_name = "\u{1}_ZN2JS26NewArrayBufferWithContentsEP9JSContextmPvNS_25NewArrayBufferOutOfMemoryE"]
            pub fn NewArrayBufferWithContents1(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
                arg1: root::JS::NewArrayBufferOutOfMemory,
            ) -> *mut root::JSObject;
            /** Create a new ArrayBuffer, whose bytes are set to the values of the bytes in
 the provided ArrayBuffer.

 |maybeArrayBuffer| is asserted to be non-null.  An error is thrown if
 |maybeArrayBuffer| would fail the |IsArrayBufferObject| test given further
 below or if |maybeArrayBuffer| is detached.

 |maybeArrayBuffer| may store its contents in any fashion (i.e. it doesn't
 matter whether |maybeArrayBuffer| was allocated using |JS::NewArrayBuffer|,
 |JS::NewExternalArrayBuffer|, or any other ArrayBuffer-allocating function).

 The newly-created ArrayBuffer is effectively creatd as if by
 |JS::NewArrayBufferWithContents| passing in |maybeArrayBuffer|'s internal
 data pointer and length, in a manner safe against |maybeArrayBuffer|'s data
 being moved around by the GC.  In particular, the new ArrayBuffer will not
 behave like one created for WASM or asm.js, so it *can* be detached.*/
            #[link_name = "\u{1}_ZN2JS15CopyArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn CopyArrayBuffer(
                cx: *mut root::JSContext,
                maybeArrayBuffer: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
            /** Create a new ArrayBuffer with the given contents. The contents must not be
 modified by any other code, internal or external.

 When the ArrayBuffer is ready to be disposed of, `freeFunc(contents,
 freeUserData)` will be called to release the ArrayBuffer's reference on the
 contents.

 `freeFunc()` must not call any JSAPI functions that could cause a garbage
 collection.

 The caller must keep the buffer alive until `freeFunc()` is called, or, if
 `freeFunc` is null, until the JSRuntime is destroyed.

 The caller must not access the buffer on other threads. The JS engine will
 not allow the buffer to be transferred to other threads. If you try to
 transfer an external ArrayBuffer to another thread, the data is copied to a
 new malloc buffer. `freeFunc()` must be threadsafe, and may be called from
 any thread.

 This allows ArrayBuffers to be used with embedder objects that use reference
 counting, for example. In that case the caller is responsible
 for incrementing the reference count before passing the contents to this
 function. This also allows using non-reference-counted contents that must be
 freed with some function other than free().*/
            #[link_name = "\u{1}_ZN2JS22NewExternalArrayBufferEP9JSContextmN7mozilla9UniquePtrIvNS_21BufferContentsDeleterEEE"]
            pub fn NewExternalArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: u8,
            ) -> *mut root::JSObject;
            /** Create a new ArrayBuffer with the given non-null |contents|.

 Ownership of |contents| remains with the caller: it isn't transferred to the
 returned ArrayBuffer.  Callers of this function *must* ensure that they
 perform these two steps, in this order, to properly relinquish ownership of
 |contents|:

   1. Call |JS::DetachArrayBuffer| on the buffer returned by this function.
      (|JS::DetachArrayBuffer| is generally fallible, but a call under these
      circumstances is guaranteed to succeed.)
   2. |contents| may be deallocated or discarded consistent with the manner
      in which it was allocated.

 Do not simply allow the returned buffer to be garbage-collected before
 deallocating |contents|, because in general there is no way to know *when*
 an object is fully garbage-collected to the point where this would be safe.*/
            #[link_name = "\u{1}_ZN2JS35NewArrayBufferWithUserOwnedContentsEP9JSContextmPv"]
            pub fn NewArrayBufferWithUserOwnedContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
            /** Create a new mapped ArrayBuffer with the given memory mapped contents. It
 must be legal to free the contents pointer by unmapping it. On success,
 ownership is transferred to the new mapped ArrayBuffer.*/
            #[link_name = "\u{1}_ZN2JS32NewMappedArrayBufferWithContentsEP9JSContextmPv"]
            pub fn NewMappedArrayBufferWithContents(
                cx: *mut root::JSContext,
                nbytes: usize,
                contents: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
            /** Create memory mapped ArrayBuffer contents.
 Caller must take care of closing fd after calling this function.*/
            #[link_name = "\u{1}_ZN2JS31CreateMappedArrayBufferContentsEimm"]
            pub fn CreateMappedArrayBufferContents(
                fd: ::std::os::raw::c_int,
                offset: usize,
                length: usize,
            ) -> *mut ::std::os::raw::c_void;
            /** Release the allocated resource of mapped ArrayBuffer contents before the
 object is created.
 If a new object has been created by JS::NewMappedArrayBufferWithContents()
 with this content, then JS::DetachArrayBuffer() should be used instead to
 release the resource used by the object.*/
            #[link_name = "\u{1}_ZN2JS32ReleaseMappedArrayBufferContentsEPvm"]
            pub fn ReleaseMappedArrayBufferContents(
                contents: *mut ::std::os::raw::c_void,
                length: usize,
            );
            #[link_name = "\u{1}_ZN2JS19IsArrayBufferObjectEP8JSObject"]
            pub fn IsArrayBufferObject(obj: *mut root::JSObject) -> bool;
            /** Check whether the obj is a detached ArrayBufferObject. Note that this may
 return false if a security wrapper is encountered that denies the
 unwrapping.*/
            #[link_name = "\u{1}_ZN2JS27IsDetachedArrayBufferObjectEP8JSObject"]
            pub fn IsDetachedArrayBufferObject(obj: *mut root::JSObject) -> bool;
            /** Check whether the obj is ArrayBufferObject and memory mapped. Note that this
 may return false if a security wrapper is encountered that denies the
 unwrapping.*/
            #[link_name = "\u{1}_ZN2JS25IsMappedArrayBufferObjectEP8JSObject"]
            pub fn IsMappedArrayBufferObject(obj: *mut root::JSObject) -> bool;
            /** Return true if the ArrayBuffer |obj| contains any data, i.e. it is not a
 detached ArrayBuffer.  (ArrayBuffer.prototype is not an ArrayBuffer.)

 |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known
 that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 ArrayBuffer, and the unwrapping will succeed.*/
            #[link_name = "\u{1}_ZN2JS18ArrayBufferHasDataEP8JSObject"]
            pub fn ArrayBufferHasData(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS17UnwrapArrayBufferEP8JSObject"]
            pub fn UnwrapArrayBuffer(obj: *mut root::JSObject) -> *mut root::JSObject;
            /** Attempt to unwrap |obj| as an ArrayBuffer.

 If |obj| *is* an ArrayBuffer, return it unwrapped and set |*length| and
 |*data| to weakly refer to the ArrayBuffer's contents.

 If |obj| isn't an ArrayBuffer, return nullptr and do not modify |*length| or
 |*data|.*/
            #[link_name = "\u{1}_ZN2JS22GetObjectAsArrayBufferEP8JSObjectPmPPh"]
            pub fn GetObjectAsArrayBuffer(
                obj: *mut root::JSObject,
                length: *mut usize,
                data: *mut *mut u8,
            ) -> *mut root::JSObject;
            /** Return the available byte length of an ArrayBuffer.

 |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known
 that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 ArrayBuffer, and the unwrapping will succeed.*/
            #[link_name = "\u{1}_ZN2JS24GetArrayBufferByteLengthEP8JSObject"]
            pub fn GetArrayBufferByteLength(obj: *mut root::JSObject) -> usize;
            #[link_name = "\u{1}_ZN2JS27GetArrayBufferLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            /** Return a pointer to the start of the data referenced by a typed array. The
 data is still owned by the typed array, and should not be modified on
 another thread. Furthermore, the pointer can become invalid on GC (if the
 data is small and fits inside the array's GC header), so callers must take
 care not to hold on across anything that could GC.

 |obj| must have passed a JS::IsArrayBufferObject test, or somehow be known
 that it would pass such a test: it is an ArrayBuffer or a wrapper of an
 ArrayBuffer, and the unwrapping will succeed.

 |*isSharedMemory| is always set to false.  The argument is present to
 simplify its use from code that also interacts with SharedArrayBuffer.*/
            #[link_name = "\u{1}_ZN2JS18GetArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
            /** Detach an ArrayBuffer, causing all associated views to no longer refer to
 the ArrayBuffer's original attached memory.

 This function throws only if it is provided a non-ArrayBuffer object or if
 the provided ArrayBuffer is a WASM-backed ArrayBuffer or an ArrayBuffer used
 in asm.js code.*/
            #[link_name = "\u{1}_ZN2JS17DetachArrayBufferEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DetachArrayBuffer(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS30HasDefinedArrayBufferDetachKeyEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn HasDefinedArrayBufferDetachKey(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDefined: *mut bool,
            ) -> bool;
            /** Steal the contents of the given ArrayBuffer. The ArrayBuffer has its length
 set to 0 and its contents array cleared. The caller takes ownership of the
 return value and must free it or transfer ownership via
 JS::NewArrayBufferWithContents when done using it.*/
            #[link_name = "\u{1}_ZN2JS24StealArrayBufferContentsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn StealArrayBufferContents(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut ::std::os::raw::c_void;
            #[must_use]
            /** Copy data from one array buffer to another.

 Both fromBuffer and toBuffer must be (possibly wrapped)
 ArrayBufferObjectMaybeShared.

 This method may throw if the sizes don't match, or if unwrapping fails.

 The API for this is modelled on CopyDataBlockBytes from the spec:
 https://tc39.es/ecma262/#sec-copydatablockbytes*/
            #[link_name = "\u{1}_ZN2JS19ArrayBufferCopyDataEP9JSContextNS_6HandleIP8JSObjectEEmS5_mm"]
            pub fn ArrayBufferCopyData(
                cx: *mut root::JSContext,
                toBlock: root::JS::Handle<*mut root::JSObject>,
                toIndex: usize,
                fromBlock: root::JS::Handle<*mut root::JSObject>,
                fromIndex: usize,
                count: usize,
            ) -> bool;
            /** Copy data from one array buffer to another.

 srcBuffer must be a (possibly wrapped) ArrayBufferObjectMaybeShared.

 This method may throw if unwrapping or allocation fails.

 The API for this is modelled on CloneArrayBuffer from the spec:
 https://tc39.es/ecma262/#sec-clonearraybuffer*/
            #[link_name = "\u{1}_ZN2JS16ArrayBufferCloneEP9JSContextNS_6HandleIP8JSObjectEEmm"]
            pub fn ArrayBufferClone(
                cx: *mut root::JSContext,
                srcBuffer: root::JS::Handle<*mut root::JSObject>,
                srcByteOffset: usize,
                srcLength: usize,
            ) -> *mut root::JSObject;
            /** Check whether obj supports the JS::GetArrayBufferMaybeShared* APIs.  Note
 that this may return false if a security wrapper is encountered that denies
 the unwrapping. If this test succeeds, then it is safe to call the various
 predicate and accessor JSAPI calls defined below.*/
            #[link_name = "\u{1}_ZN2JS30IsArrayBufferObjectMaybeSharedEP8JSObject"]
            pub fn IsArrayBufferObjectMaybeShared(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS28UnwrapArrayBufferMaybeSharedEP8JSObject"]
            pub fn UnwrapArrayBufferMaybeShared(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            /** Get the length, sharedness, and data from an ArrayBufferMaybeShared subtypes.

 The computed length and data pointer may be invalidated by a GC or by an
 unshared array buffer becoming detached. Callers must take care not to
 perform any actions that could trigger a GC or result in an unshared array
 buffer becoming detached. If such actions nonetheless must be performed,
 callers should perform this call a second time (and sensibly handle results
 that may be different from those returned the first time). (Sharedness is an
 immutable characteristic of an array buffer or shared array buffer, so that
 boolean remains valid across GC or detaching.)

 |obj| must be an ArrayBufferMaybeShared subtype: an ArrayBuffer or a
 SharedArrayBuffer.

 |*length| will be set to bytes in the buffer.

 |*isSharedMemory| will be set to true if it is a SharedArrayBuffer, otherwise
 to false.

 |*data| will be set to a pointer to the bytes in the buffer.*/
            #[link_name = "\u{1}_ZN2JS38GetArrayBufferMaybeSharedLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetArrayBufferMaybeSharedLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            /** Return a pointer to the start of the array buffer's data, and indicate
 whether the data is from a shared array buffer through an outparam.

 The returned data pointer may be invalidated by a GC or by an unshared array
 buffer becoming detached. Callers must take care not to perform any actions
 that could trigger a GC or result in an unshared array buffer becoming
 detached. If such actions nonetheless must be performed, callers should
 perform this call a second time (and sensibly handle results that may be
 different from those returned the first time). (Sharedness is an immutable
 characteristic of an array buffer or shared array buffer, so that boolean
 remains valid across GC or detaching.)

 |obj| must have passed a JS::IsArrayBufferObjectMaybeShared test, or somehow
 be known that it would pass such a test: it is an ArrayBuffer or
 SharedArrayBuffer or a wrapper of an ArrayBuffer/SharedArrayBuffer, and the
 unwrapping will succeed.

 |*isSharedMemory| will be set to true if the typed array maps a
 SharedArrayBuffer, otherwise to false.*/
            #[link_name = "\u{1}_ZN2JS29GetArrayBufferMaybeSharedDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetArrayBufferMaybeSharedData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
            /** Returns whether the passed array buffer is 'large': its byteLength >= 2 GB.

 |obj| must pass a JS::IsArrayBufferObjectMaybeShared test.*/
            #[link_name = "\u{1}_ZN2JS29IsLargeArrayBufferMaybeSharedEP8JSObject"]
            pub fn IsLargeArrayBufferMaybeShared(obj: *mut root::JSObject) -> bool;
            /** Returns whether the passed array buffer is resizable or growable for shared
 array buffers.

 |obj| must pass a JS::IsArrayBufferObjectMaybeShared test.*/
            #[link_name = "\u{1}_ZN2JS33IsResizableArrayBufferMaybeSharedEP8JSObject"]
            pub fn IsResizableArrayBufferMaybeShared(obj: *mut root::JSObject) -> bool;
            /** Create a BigInt from a floating-point value. If the number isn't integral
 (that is, if it's NaN, an infinity, or contains a fractional component),
 this function returns null and throws an exception.

 Passing -0.0 will produce the bigint 0n.*/
            #[link_name = "\u{1}_ZN2JS14NumberToBigIntEP9JSContextd"]
            pub fn NumberToBigInt(
                cx: *mut root::JSContext,
                num: f64,
            ) -> *mut root::JS::BigInt;
            /** Create a BigInt by parsing a string using the ECMAScript StringToBigInt
 algorithm (https://tc39.es/ecma262/#sec-stringtobigint). Latin1 and two-byte
 character ranges are supported. It may be convenient to use
 JS::ConstLatin1Chars or JS::ConstTwoByteChars.

 (StringToBigInt performs parsing similar to that performed by the |Number|
 global function when passed a string, but it doesn't allow infinities,
 decimal points, or exponential notation, and neither algorithm allows numeric
 separators or an 'n' suffix character. This fast-and-loose description is
 offered purely as a convenience to the reader: see the specification
 algorithm for exact behavior.)

 If parsing fails, this function returns null and throws an exception.*/
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextRKN7mozilla5RangeIKhEE"]
            pub fn StringToBigInt(
                cx: *mut root::JSContext,
                chars: *const root::mozilla::Range<root::JS::Latin1Char>,
            ) -> *mut root::JS::BigInt;
            #[link_name = "\u{1}_ZN2JS14StringToBigIntEP9JSContextRKN7mozilla5RangeIKDsEE"]
            pub fn StringToBigInt1(
                cx: *mut root::JSContext,
                chars: *const root::mozilla::Range<u16>,
            ) -> *mut root::JS::BigInt;
            /** Create a BigInt by parsing a string consisting of an optional sign character
 followed by one or more alphanumeric ASCII digits in the provided radix.

 If the radix is not in the range [2, 36], or the string fails to parse, this
 function returns null and throws an exception.*/
            #[link_name = "\u{1}_ZN2JS20SimpleStringToBigIntEP9JSContextN7mozilla4SpanIKcLm4294967295EEEh"]
            pub fn SimpleStringToBigInt(
                cx: *mut root::JSContext,
                chars: [u32; 2usize],
                radix: u8,
            ) -> *mut root::JS::BigInt;
            /** Convert a JS::Value to a BigInt using the ECMAScript ToBigInt algorithm
 (https://tc39.es/ecma262/#sec-tobigint).

 (Note in particular that this will throw if passed a value whose type is
 'number'. To convert a number to a BigInt, use one of the overloads of
 JS::NumberToBigInt().)*/
            #[link_name = "\u{1}_ZN2JS8ToBigIntEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn ToBigInt(
                cx: *mut root::JSContext,
                val: root::JS::Handle<root::JS::Value>,
            ) -> *mut root::JS::BigInt;
            /// Convert the given BigInt, modulo 2**64, to a signed 64-bit integer.
            #[link_name = "\u{1}_ZN2JS10ToBigInt64EPKNS_6BigIntE"]
            pub fn ToBigInt64(bi: *const root::JS::BigInt) -> i64;
            /// Convert the given BigInt, modulo 2**64, to an unsigned 64-bit integer.
            #[link_name = "\u{1}_ZN2JS11ToBigUint64EPKNS_6BigIntE"]
            pub fn ToBigUint64(bi: *const root::JS::BigInt) -> u64;
            /** Convert the given BigInt to a Number value as if calling the Number
 constructor on it
 (https://tc39.es/ecma262/#sec-number-constructor-number-value). The value
 may be rounded if it doesn't fit without loss of precision.*/
            #[link_name = "\u{1}_ZN2JS14BigIntToNumberEPKNS_6BigIntE"]
            pub fn BigIntToNumber(bi: *const root::JS::BigInt) -> f64;
            /// Return true if the given BigInt is negative.
            #[link_name = "\u{1}_ZN2JS16BigIntIsNegativeEPKNS_6BigIntE"]
            pub fn BigIntIsNegative(bi: *const root::JS::BigInt) -> bool;
            /// Same as BigIntFits(), but checks if the value fits inside a JS Number value.
            #[link_name = "\u{1}_ZN2JS16BigIntFitsNumberEPKNS_6BigIntEPd"]
            pub fn BigIntFitsNumber(bi: *const root::JS::BigInt, out: *mut f64) -> bool;
            /** Convert the given BigInt to a String value as if toString() were called on
 it.

 If the radix is not in the range [2, 36], then this function returns null and
 throws an exception.*/
            #[link_name = "\u{1}_ZN2JS14BigIntToStringEP9JSContextNS_6HandleIPNS_6BigIntEEEh"]
            pub fn BigIntToString(
                cx: *mut root::JSContext,
                bi: root::JS::Handle<*mut root::JS::BigInt>,
                radix: u8,
            ) -> *mut root::JSString;
            /// Embedder hook to set the buildId-generating function.
            #[link_name = "\u{1}_ZN2JS19SetProcessBuildIdOpEPFbPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEEE"]
            pub fn SetProcessBuildIdOp(buildIdOp: root::JS::BuildIdOp);
            #[must_use]
            /** Some cached data is, in addition to being build-specific, CPU-specific: the
 cached data depends on CPU features like a particular level of SSE support.

 This function produces a buildId that includes:

   * the buildId defined by the embedder-provided BuildIdOp set by
     JS::SetProcessBuildIdOp, and
   * CPU feature information for the current CPU.

 Embedders may use this function to tag cached data whose validity depends
 on having consistent buildId *and* on the CPU supporting features identical
 to those in play when the cached data was computed.*/
            #[link_name = "\u{1}_ZN2JS27GetOptimizedEncodingBuildIdEPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEE"]
            pub fn GetOptimizedEncodingBuildId(
                buildId: *mut root::JS::BuildIdCharVector,
            ) -> bool;
            #[must_use]
            /** Script bytecode is dependent on the buildId and a few other things.

 This function produces a buildId that includes:

   * The buildId defined by the embedder-provided BuildIdOp set by
     JS::SetProcessBuildIdOp.
   * Additional bytes describing things like endianness, pointer size and
     other state XDR buffers depend on.

 Note: this value may depend on runtime preferences so isn't guaranteed to be
 stable across restarts.

 Embedders should use this function to tag transcoded bytecode.
 See Transcoding.h.*/
            #[link_name = "\u{1}_ZN2JS27GetScriptTranscodingBuildIdEPN7mozilla6VectorIcLm0EN2js17SystemAllocPolicyEEE"]
            pub fn GetScriptTranscodingBuildId(
                buildId: *mut root::JS::BuildIdCharVector,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS24AutoEnterCycleCollectionC1EP9JSRuntime"]
            pub fn AutoEnterCycleCollection_AutoEnterCycleCollection(
                this: *mut root::JS::AutoEnterCycleCollection,
                rt: *mut root::JSRuntime,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS24AutoEnterCycleCollectionD1Ev"]
            pub fn AutoEnterCycleCollection_AutoEnterCycleCollection_destructor(
                this: *mut root::JS::AutoEnterCycleCollection,
            );
            #[link_name = "\u{1}_ZN2JS16RuntimeHeapStateEv"]
            pub fn RuntimeHeapState() -> root::JS::HeapState;
            #[link_name = "\u{1}_ZN2JSL17RuntimeHeapIsBusyEv"]
            pub fn RuntimeHeapIsBusy() -> bool;
            #[link_name = "\u{1}_ZN2JSL20RuntimeHeapIsTracingEv"]
            pub fn RuntimeHeapIsTracing() -> bool;
            #[link_name = "\u{1}_ZN2JSL28RuntimeHeapIsMajorCollectingEv"]
            pub fn RuntimeHeapIsMajorCollecting() -> bool;
            #[link_name = "\u{1}_ZN2JSL28RuntimeHeapIsMinorCollectingEv"]
            pub fn RuntimeHeapIsMinorCollecting() -> bool;
            #[link_name = "\u{1}_ZN2JSL23RuntimeHeapIsCollectingENS_9HeapStateE"]
            pub fn RuntimeHeapIsCollecting(state: root::JS::HeapState) -> bool;
            #[link_name = "\u{1}_ZN2JSL23RuntimeHeapIsCollectingEv"]
            pub fn RuntimeHeapIsCollecting1() -> bool;
            #[link_name = "\u{1}_ZN2JSL28RuntimeHeapIsCycleCollectingEv"]
            pub fn RuntimeHeapIsCycleCollecting() -> bool;
            #[link_name = "\u{1}_ZN2JS9GCCellPtrC1ERKNS_5ValueE"]
            pub fn GCCellPtr_GCCellPtr(
                this: *mut root::JS::GCCellPtr,
                v: *const root::JS::Value,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS21GetTenuredGCThingZoneENS_9GCCellPtrE"]
            pub fn GetTenuredGCThingZone(
                thing: root::JS::GCCellPtr,
            ) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2JS18GetNurseryCellZoneEPN2js2gc4CellE"]
            pub fn GetNurseryCellZone(
                cell: *mut root::js::gc::Cell,
            ) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2JSL14GetGCThingZoneENS_9GCCellPtrE"]
            pub fn GetGCThingZone(thing: root::JS::GCCellPtr) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2JSL13GetStringZoneEP8JSString"]
            pub fn GetStringZone(str_: *mut root::JSString) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2JS13GetObjectZoneEP8JSObject"]
            pub fn GetObjectZone(obj: *mut root::JSObject) -> *mut root::JS::Zone;
            #[link_name = "\u{1}_ZN2JSL19GCThingIsMarkedGrayENS_9GCCellPtrE"]
            pub fn GCThingIsMarkedGray(thing: root::JS::GCCellPtr) -> bool;
            #[link_name = "\u{1}_ZN2JSL23GCThingIsMarkedGrayInCCENS_9GCCellPtrE"]
            pub fn GCThingIsMarkedGrayInCC(thing: root::JS::GCCellPtr) -> bool;
            #[link_name = "\u{1}_ZN2JS16GCThingTraceKindEPv"]
            pub fn GCThingTraceKind(
                thing: *mut ::std::os::raw::c_void,
            ) -> root::JS::TraceKind;
            #[link_name = "\u{1}_ZN2JS20EnableNurseryStringsEP9JSContext"]
            pub fn EnableNurseryStrings(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS21DisableNurseryStringsEP9JSContext"]
            pub fn DisableNurseryStrings(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS20EnableNurseryBigIntsEP9JSContext"]
            pub fn EnableNurseryBigInts(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS21DisableNurseryBigIntsEP9JSContext"]
            pub fn DisableNurseryBigInts(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS26IsIncrementalBarrierNeededEP9JSContext"]
            pub fn IsIncrementalBarrierNeeded(cx: *mut root::JSContext) -> bool;
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierEP8JSObject"]
            pub fn IncrementalPreWriteBarrier(obj: *mut root::JSObject);
            #[link_name = "\u{1}_ZN2JS26IncrementalPreWriteBarrierENS_9GCCellPtrE"]
            pub fn IncrementalPreWriteBarrier1(thing: root::JS::GCCellPtr);
            /** Unsets the gray bit for anything reachable from |thing|. |kind| should not be
 JS::TraceKind::Shape. |thing| should be non-null. The return value indicates
 if anything was unmarked.*/
            #[link_name = "\u{1}_ZN2JS28UnmarkGrayGCThingRecursivelyENS_9GCCellPtrE"]
            pub fn UnmarkGrayGCThingRecursively(thing: root::JS::GCCellPtr) -> bool;
            #[link_name = "\u{1}_ZN2JSL22ExposeObjectToActiveJSEP8JSObject"]
            pub fn ExposeObjectToActiveJS(obj: *mut root::JSObject);
            /// Returns a static string equivalent of |kind|.
            #[link_name = "\u{1}_ZN2JS18GCTraceKindToAsciiENS_9TraceKindE"]
            pub fn GCTraceKindToAscii(
                kind: root::JS::TraceKind,
            ) -> *const ::std::os::raw::c_char;
            /// Returns the base size in bytes of the GC thing of kind |kind|.
            #[link_name = "\u{1}_ZN2JS15GCTraceKindSizeENS_9TraceKindE"]
            pub fn GCTraceKindSize(kind: root::JS::TraceKind) -> usize;
            #[link_name = "\u{1}_ZN2JS14TracingContext11getEdgeNameEPKcPcm"]
            pub fn TracingContext_getEdgeName(
                this: *mut root::JS::TracingContext,
                name: *const ::std::os::raw::c_char,
                buffer: *mut ::std::os::raw::c_char,
                bufferSize: usize,
            );
            #[link_name = "\u{1}_ZN2JS14CallbackTracerC2EP9JSContextNS_10TracerKindENS_12TraceOptionsE"]
            pub fn CallbackTracer_CallbackTracer(
                this: *mut root::JS::CallbackTracer,
                cx: *mut root::JSContext,
                kind: root::JS::TracerKind,
                options: root::JS::TraceOptions,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6BigIntEPKc"]
            pub fn TraceRoot(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::BigInt,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPNS_6SymbolEPKc"]
            pub fn TraceRoot1(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JS::Symbol,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP6JSAtomPKc"]
            pub fn TraceRoot2(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSAtom,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP10JSFunctionPKc"]
            pub fn TraceRoot3(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSFunction,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP14JSLinearStringPKc"]
            pub fn TraceRoot4(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSLinearString,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSObjectPKc"]
            pub fn TraceRoot5(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSScriptPKc"]
            pub fn TraceRoot6(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSScript,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPP8JSStringPKc"]
            pub fn TraceRoot7(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::JSString,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_5ValueEPKc"]
            pub fn TraceRoot8(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPNS_11PropertyKeyEPKc"]
            pub fn TraceRoot9(
                trc: *mut root::JSTracer,
                edgep: *mut root::JS::PropertyKey,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js23AbstractGeneratorObjectEPKc"]
            pub fn TraceRoot10(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::AbstractGeneratorObject,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPPN2js10SavedFrameEPKc"]
            pub fn TraceRoot11(
                trc: *mut root::JSTracer,
                edgep: *mut *mut root::js::SavedFrame,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS9TraceRootEP8JSTracerPN2js4wasm6AnyRefEPKc"]
            pub fn TraceRoot12(
                trc: *mut root::JSTracer,
                edgep: *mut root::js::wasm::AnyRef,
                name: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS13TraceChildrenEP8JSTracerNS_9GCCellPtrE"]
            pub fn TraceChildren(trc: *mut root::JSTracer, thing: root::JS::GCCellPtr);
            #[link_name = "\u{1}_ZN2JS28GetProfilingCategoryPairInfoENS_21ProfilingCategoryPairE"]
            pub fn GetProfilingCategoryPairInfo(
                aCategoryPair: root::JS::ProfilingCategoryPair,
            ) -> *const root::JS::ProfilingCategoryPairInfo;
            #[link_name = "\u{1}_ZN2JS27SetProfilingThreadCallbacksEPFP14ProfilingStackPKcPvEPFvvE"]
            pub fn SetProfilingThreadCallbacks(
                registerThread: root::JS::RegisterThreadCallback,
                unregisterThread: root::JS::UnregisterThreadCallback,
            );
            #[link_name = "\u{1}_ZN2JS21GetCurrentRealmOrNullEP9JSContext"]
            pub fn GetCurrentRealmOrNull(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::Realm;
            #[link_name = "\u{1}_ZN2JS20GetObjectRealmOrNullEP8JSObject"]
            pub fn GetObjectRealmOrNull(
                obj: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
            #[link_name = "\u{1}_ZN2JS15GetRealmPrivateEPNS_5RealmE"]
            pub fn GetRealmPrivate(
                realm: *mut root::JS::Realm,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS15SetRealmPrivateEPNS_5RealmEPv"]
            pub fn SetRealmPrivate(
                realm: *mut root::JS::Realm,
                data: *mut ::std::os::raw::c_void,
            );
            #[link_name = "\u{1}_ZN2JS23SetDestroyRealmCallbackEP9JSContextPFvPNS_9GCContextEPNS_5RealmEE"]
            pub fn SetDestroyRealmCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DestroyRealmCallback,
            );
            #[link_name = "\u{1}_ZN2JS20SetRealmNameCallbackEP9JSContextPFvS1_PNS_5RealmEPcmRKNS_15AutoRequireNoGCEE"]
            pub fn SetRealmNameCallback(
                cx: *mut root::JSContext,
                callback: root::JS::RealmNameCallback,
            );
            #[link_name = "\u{1}_ZN2JS20GetRealmGlobalOrNullEPNS_5RealmE"]
            pub fn GetRealmGlobalOrNull(
                realm: *mut root::JS::Realm,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS24InitRealmStandardClassesEP9JSContext"]
            pub fn InitRealmStandardClasses(cx: *mut root::JSContext) -> bool;
            #[link_name = "\u{1}_ZN2JS27MaybeFreezeCtorAndPrototypeEP9JSContextNS_6HandleIP8JSObjectEES5_"]
            pub fn MaybeFreezeCtorAndPrototype(
                cx: *mut root::JSContext,
                ctor: root::JS::HandleObject,
                maybeProto: root::JS::HandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS23GetRealmObjectPrototypeEP9JSContext"]
            pub fn GetRealmObjectPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS29GetRealmObjectPrototypeHandleEP9JSContext"]
            pub fn GetRealmObjectPrototypeHandle(
                cx: *mut root::JSContext,
            ) -> root::JS::Handle<*mut root::JSObject>;
            #[link_name = "\u{1}_ZN2JS25GetRealmFunctionPrototypeEP9JSContext"]
            pub fn GetRealmFunctionPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS22GetRealmArrayPrototypeEP9JSContext"]
            pub fn GetRealmArrayPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS22GetRealmErrorPrototypeEP9JSContext"]
            pub fn GetRealmErrorPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS25GetRealmIteratorPrototypeEP9JSContext"]
            pub fn GetRealmIteratorPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS30GetRealmAsyncIteratorPrototypeEP9JSContext"]
            pub fn GetRealmAsyncIteratorPrototype(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS17GetRealmKeyObjectEP9JSContext"]
            pub fn GetRealmKeyObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS16GetFunctionRealmEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetFunctionRealm(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
            ) -> *mut root::JS::Realm;
            /** NB: This API is infallible; a nullptr return value does not indicate error.

 |target| must not be a cross-compartment wrapper because CCWs are not
 associated with a single realm.

 Entering a realm roots the realm and its global object until the matching
 JS::LeaveRealm() call.*/
            #[link_name = "\u{1}_ZN2JS10EnterRealmEP9JSContextP8JSObject"]
            pub fn EnterRealm(
                cx: *mut root::JSContext,
                target: *mut root::JSObject,
            ) -> *mut root::JS::Realm;
            #[link_name = "\u{1}_ZN2JS10LeaveRealmEP9JSContextPNS_5RealmE"]
            pub fn LeaveRealm(cx: *mut root::JSContext, oldRealm: *mut root::JS::Realm);
            /// Use the cx's current compartment's principals.
            #[link_name = "\u{1}_ZN2JS18FirstSubsumedFrameC1EP9JSContextb"]
            pub fn FirstSubsumedFrame_FirstSubsumedFrame(
                this: *mut root::JS::FirstSubsumedFrame,
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
            ) -> *mut ::std::os::raw::c_void;
            /** Capture the current call stack as a chain of SavedFrame JSObjects, and set
 |stackp| to the SavedFrame for the youngest stack frame, or nullptr if there
 are no JS frames on the stack.

 The |capture| parameter describes the portion of the JS stack to capture:

   * |JS::AllFrames|: Capture all frames on the stack.

   * |JS::MaxFrames|: Capture no more than |JS::MaxFrames::maxFrames| from the
      stack.

   * |JS::FirstSubsumedFrame|: Capture the first frame whose principals are
     subsumed by |JS::FirstSubsumedFrame::principals|. By default, do not
     consider self-hosted frames; this can be controlled via the
     |JS::FirstSubsumedFrame::ignoreSelfHosted| flag. Do not capture any async
     stack.*/
            #[link_name = "\u{1}_ZN2JS19CaptureCurrentStackEP9JSContextNS_13MutableHandleIP8JSObjectEEON7mozilla7VariantIJNS_9AllFramesENS_9MaxFramesENS_18FirstSubsumedFrameEEEE"]
            pub fn CaptureCurrentStack(
                cx: *mut root::JSContext,
                stackp: root::JS::MutableHandleObject,
                capture: *mut root::JS::StackCapture,
            ) -> bool;
            /** Returns true if capturing stack trace data to associate with an asynchronous
 operation is currently enabled for the current context realm.

 Users should check this state before capturing a stack that will be passed
 back to AutoSetAsyncStackForNewCalls later, in order to avoid capturing a
 stack for async use when we don't actually want to capture it.*/
            #[link_name = "\u{1}_ZN2JS34IsAsyncStackCaptureEnabledForRealmEP9JSContext"]
            pub fn IsAsyncStackCaptureEnabledForRealm(cx: *mut root::JSContext) -> bool;
            #[link_name = "\u{1}_ZN2JS14CopyAsyncStackEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEENS_13MutableHandleIS4_EERKN7mozilla5MaybeImEE"]
            pub fn CopyAsyncStack(
                cx: *mut root::JSContext,
                asyncStack: root::JS::HandleObject,
                asyncCause: root::JS::HandleString,
                stackp: root::JS::MutableHandleObject,
                maxFrameCount: *const root::mozilla::Maybe,
            ) -> bool;
            /** Given a SavedFrame JSObject stack, stringify it in the same format as
 Error.prototype.stack. The stringified stack out parameter is placed in the
 cx's compartment. Defaults to the empty string.

 The same notes above about SavedFrame accessors applies here as well: cx
 doesn't need to be in stack's compartment, and stack can be null, a
 SavedFrame object, or a wrapper (CCW or Xray) around a SavedFrame object.
 SavedFrames not subsumed by |principals| are skipped.

 Optional indent parameter specifies the number of white spaces to indent
 each line.*/
            #[link_name = "\u{1}_ZN2JS16BuildStackStringEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEEmN2js11StackFormatE"]
            pub fn BuildStackString(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                stack: root::JS::HandleObject,
                stringp: root::JS::MutableHandleString,
                indent: usize,
                stackFormat: root::js::StackFormat,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS26HeapObjectPostWriteBarrierEPP8JSObjectS1_S1_"]
            pub fn HeapObjectPostWriteBarrier(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2JS23HeapObjectWriteBarriersEPP8JSObjectS1_S1_"]
            pub fn HeapObjectWriteBarriers(
                objp: *mut *mut root::JSObject,
                prev: *mut root::JSObject,
                next: *mut root::JSObject,
            );
            #[link_name = "\u{1}_ZN2JS23HeapStringWriteBarriersEPP8JSStringS1_S1_"]
            pub fn HeapStringWriteBarriers(
                objp: *mut *mut root::JSString,
                prev: *mut root::JSString,
                next: *mut root::JSString,
            );
            #[link_name = "\u{1}_ZN2JS23HeapBigIntWriteBarriersEPPNS_6BigIntES1_S1_"]
            pub fn HeapBigIntWriteBarriers(
                bip: *mut *mut root::JS::BigInt,
                prev: *mut root::JS::BigInt,
                next: *mut root::JS::BigInt,
            );
            #[link_name = "\u{1}_ZN2JS23HeapScriptWriteBarriersEPP8JSScriptS1_S1_"]
            pub fn HeapScriptWriteBarriers(
                objp: *mut *mut root::JSScript,
                prev: *mut root::JSScript,
                next: *mut root::JSScript,
            );
            /** For generational GC, assert that an object is in the tenured generation as
 opposed to being in the nursery.*/
            #[link_name = "\u{1}_ZN2JS26AssertGCThingMustBeTenuredEP8JSObject"]
            pub fn AssertGCThingMustBeTenured(obj: *mut root::JSObject);
            #[link_name = "\u{1}_ZN2JS34AssertGCThingIsNotNurseryAllocableEPN2js2gc4CellE"]
            pub fn AssertGCThingIsNotNurseryAllocable(cell: *mut root::js::gc::Cell);
            #[link_name = "\u{1}_ZN2JSL15ObjectIsTenuredEP8JSObject"]
            pub fn ObjectIsTenured(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JSL15ObjectIsTenuredERKNS_4HeapIP8JSObjectEE"]
            pub fn ObjectIsTenured1(
                obj: *const root::JS::Heap<*mut root::JSObject>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL18ObjectIsMarkedGrayEP8JSObject"]
            pub fn ObjectIsMarkedGray(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JSL18ObjectIsMarkedGrayERKNS_4HeapIP8JSObjectEE"]
            pub fn ObjectIsMarkedGray1(
                obj: *const root::JS::Heap<*mut root::JSObject>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL18ObjectIsMarkedGrayERKNS_11TenuredHeapIP8JSObjectEE"]
            pub fn ObjectIsMarkedGray2(obj: *const root::JS::TenuredHeap) -> bool;
            #[link_name = "\u{1}_ZN2JS14RootingContext15traceStackRootsEP8JSTracer"]
            pub fn RootingContext_traceStackRoots(
                this: *mut root::JS::RootingContext,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2JS14RootingContext17traceAllGCRootersEP8JSTracer"]
            pub fn RootingContext_traceAllGCRooters(
                this: *mut root::JS::RootingContext,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2JS14RootingContext21traceWrapperGCRootersEP8JSTracer"]
            pub fn RootingContext_traceWrapperGCRooters(
                this: *mut root::JS::RootingContext,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2JS14RootingContext17traceGCRooterListEP8JSTracerPNS_12AutoGCRooterE"]
            pub fn RootingContext_traceGCRooterList(
                trc: *mut root::JSTracer,
                head: *mut root::JS::AutoGCRooter,
            );
            #[link_name = "\u{1}_ZN2JS14RootingContext16checkNoGCRootersEv"]
            pub fn RootingContext_checkNoGCRooters(this: *mut root::JS::RootingContext);
            #[link_name = "\u{1}_ZN2JS14RootingContextC1EPN2js7NurseryE"]
            pub fn RootingContext_RootingContext(
                this: *mut root::JS::RootingContext,
                nursery: *mut root::js::Nursery,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS12AutoGCRooter5traceEP8JSTracer"]
            pub fn AutoGCRooter_trace(
                this: *mut root::JS::AutoGCRooter,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEPNS_14RootingContextENS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot(
                cx: *mut root::JS::RootingContext,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
            #[link_name = "\u{1}_ZN2JS17AddPersistentRootEP9JSRuntimeNS_8RootKindEPN2js20PersistentRootedBaseE"]
            pub fn AddPersistentRoot1(
                rt: *mut root::JSRuntime,
                kind: root::JS::RootKind,
                root: *mut root::js::PersistentRootedBase,
            );
            /** Evaluate the given source buffer in the scope of the current global of cx,
 and return the completion value in |rval|.*/
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** As above, but providing an explicit scope chain.  envChain must not include
 the global object on it; that's implicit.  It needs to contain the other
 objects that should end up on the script's scope chain.*/
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Evaluate the provided UTF-8 data in the scope of the current global of |cx|,
 and return the completion value in |rval|.  If the data contains invalid
 UTF-8, an error is reported.*/
            #[link_name = "\u{1}_ZN2JS8EvaluateEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn Evaluate2(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Evaluate the UTF-8 contents of the file at the given path, and return the
 completion value in |rval|.  (The path itself is UTF-8 encoded, too.)  If
 the contents contain any malformed UTF-8, an error is reported.*/
            #[link_name = "\u{1}_ZN2JS16EvaluateUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKcNS_13MutableHandleINS_5ValueEEE"]
            pub fn EvaluateUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Compile the provided script using the given options.  Return the script on
 success, or return null on failure (usually with an error reported).*/
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn Compile(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSScript;
            /** Compile the provided script using the given options.  Return the script on
 success, or return null on failure (usually with an error reported).*/
            #[link_name = "\u{1}_ZN2JS7CompileEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn Compile1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSScript;
            /** Compile the UTF-8 contents of the given file into a script.  It is an error
 if the file contains invalid UTF-8.  Return the script on success, or return
 null on failure (usually with an error reported).*/
            #[link_name = "\u{1}_ZN2JS15CompileUtf8FileEP9JSContextRKNS_22ReadOnlyCompileOptionsEP8_IO_FILE"]
            pub fn CompileUtf8File(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                file: *mut root::FILE,
            ) -> *mut root::JSScript;
            /** Compile the UTF-8 contents of the file at the given path into a script.
 (The path itself is in the system encoding, not [necessarily] UTF-8.)  It
 is an error if the file's contents are invalid UTF-8.  Return the script on
 success, or return null on failure (usually with an error reported).*/
            #[link_name = "\u{1}_ZN2JS15CompileUtf8PathEP9JSContextRKNS_22ReadOnlyCompileOptionsEPKc"]
            pub fn CompileUtf8Path(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                filename: *const ::std::os::raw::c_char,
            ) -> *mut root::JSScript;
            /** Compile a function with envChain plus the global as its scope chain.
 envChain must contain objects in the current compartment of cx.  The actual
 scope chain used for the function will consist of With wrappers for those
 objects, followed by the current global of the compartment cx is in.  This
 global must not be explicitly included in the scope chain.*/
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIDsEE"]
            pub fn CompileFunction(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSFunction;
            /** Compile a function with envChain plus the global as its scope chain.
 envChain must contain objects in the current compartment of cx.  The actual
 scope chain used for the function will consist of With wrappers for those
 objects, followed by the current global of the compartment cx is in.  This
 global must not be explicitly included in the scope chain.*/
            #[link_name = "\u{1}_ZN2JS15CompileFunctionEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_RNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileFunction1(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSFunction;
            /** Identical to the CompileFunction overload above for UTF-8, but with
 Rust-friendly ergonomics.*/
            #[link_name = "\u{1}_ZN2JS19CompileFunctionUtf8EP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEERKNS_22ReadOnlyCompileOptionsEPKcjPKSE_SE_m"]
            pub fn CompileFunctionUtf8(
                cx: *mut root::JSContext,
                envChain: root::JS::HandleObjectVector,
                options: *const root::JS::ReadOnlyCompileOptions,
                name: *const ::std::os::raw::c_char,
                nargs: ::std::os::raw::c_uint,
                argnames: *const *const ::std::os::raw::c_char,
                utf8: *const ::std::os::raw::c_char,
                length: usize,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZN2JS22ExposeScriptToDebuggerEP9JSContextNS_6HandleIP8JSScriptEE"]
            pub fn ExposeScriptToDebugger(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
            );
            #[link_name = "\u{1}_ZN2JS19UpdateDebugMetadataEP9JSContextNS_6HandleIP8JSScriptEERKNS_18InstantiateOptionsENS2_INS_5ValueEEENS2_IP8JSStringEES5_S5_"]
            pub fn UpdateDebugMetadata(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                options: *const root::JS::InstantiateOptions,
                privateValue: root::JS::HandleValue,
                elementAttributeName: root::JS::HandleString,
                introScript: root::JS::HandleScript,
                scriptOrModule: root::JS::HandleScript,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS34LossyTwoByteCharsToNewLatin1CharsZEP9JSContextRKN7mozilla5RangeIKDsEE"]
            pub fn LossyTwoByteCharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                tbchars: *const root::mozilla::Range<u16>,
            ) -> root::JS::Latin1CharsZ;
            #[link_name = "\u{1}_ZN2JS17Utf8ToOneUcs4CharEPKhi"]
            pub fn Utf8ToOneUcs4Char(
                utf8Buffer: *const u8,
                utf8Length: ::std::os::raw::c_int,
            ) -> u32;
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
            #[link_name = "\u{1}_ZN2JS27UTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn UTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
            #[link_name = "\u{1}_ZN2JS32LossyUTF8CharsToNewTwoByteCharsZEP9JSContextRKNS_15ConstUTF8CharsZEPmm"]
            pub fn LossyUTF8CharsToNewTwoByteCharsZ1(
                cx: *mut root::JSContext,
                utf8: *const root::JS::ConstUTF8CharsZ,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::TwoByteCharsZ;
            #[link_name = "\u{1}_ZN2JS27GetDeflatedUTF8StringLengthEP14JSLinearString"]
            pub fn GetDeflatedUTF8StringLength(s: *mut root::JSLinearString) -> usize;
            #[link_name = "\u{1}_ZN2JS25DeflateStringToUTF8BufferEP14JSLinearStringN7mozilla4SpanIcLm4294967295EEE"]
            pub fn DeflateStringToUTF8Buffer(
                src: *mut root::JSLinearString,
                dst: [u32; 2usize],
            ) -> usize;
            #[link_name = "\u{1}_ZN2JS20FindSmallestEncodingERKNS_9UTF8CharsE"]
            pub fn FindSmallestEncoding(
                utf8: *const root::JS::UTF8Chars,
            ) -> root::JS::SmallestEncoding;
            #[link_name = "\u{1}_ZN2JS26UTF8CharsToNewLatin1CharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn UTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
            #[link_name = "\u{1}_ZN2JS31LossyUTF8CharsToNewLatin1CharsZEP9JSContextRKNS_9UTF8CharsEPmm"]
            pub fn LossyUTF8CharsToNewLatin1CharsZ(
                cx: *mut root::JSContext,
                utf8: *const root::JS::UTF8Chars,
                outlen: *mut usize,
                destArenaId: root::arena_id_t,
            ) -> root::JS::Latin1CharsZ;
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEPKc"]
            pub fn StringIsASCII(s: *const ::std::os::raw::c_char) -> bool;
            #[link_name = "\u{1}_ZN2JS13StringIsASCIIEN7mozilla4SpanIKcLm4294967295EEE"]
            pub fn StringIsASCII1(s: [u32; 2usize]) -> bool;
            /** Encode a narrow multibyte character string to a UTF-8 string.

 NOTE: Should only be used when interacting with POSIX/OS functions and not
       for encoding ASCII/Latin-1/etc. strings to UTF-8.*/
            #[link_name = "\u{1}_ZN2JS18EncodeNarrowToUtf8EP9JSContextPKc"]
            pub fn EncodeNarrowToUtf8(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueChars;
            /** Encode a wide string to a UTF-8 string.

 NOTE: Should only be used when interacting with Windows API functions.*/
            #[link_name = "\u{1}_ZN2JS16EncodeWideToUtf8EP9JSContextPKw"]
            pub fn EncodeWideToUtf8(
                cx: *mut root::JSContext,
                chars: *const u32,
            ) -> root::JS::UniqueChars;
            /** Encode a UTF-8 string to a narrow multibyte character string.

 NOTE: Should only be used when interacting with POSIX/OS functions and not
       for encoding UTF-8 to ASCII/Latin-1/etc. strings.*/
            #[link_name = "\u{1}_ZN2JS18EncodeUtf8ToNarrowEP9JSContextPKc"]
            pub fn EncodeUtf8ToNarrow(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueChars;
            /** Encode a UTF-8 string to a wide string.

 NOTE: Should only be used when interacting with Windows API functions.*/
            #[link_name = "\u{1}_ZN2JS16EncodeUtf8ToWideEP9JSContextPKc"]
            pub fn EncodeUtf8ToWide(
                cx: *mut root::JSContext,
                chars: *const ::std::os::raw::c_char,
            ) -> root::JS::UniqueWideChars;
            #[link_name = "\u{1}_ZN2JS24TransitiveCompileOptions24copyPODTransitiveOptionsERKS0_"]
            pub fn TransitiveCompileOptions_copyPODTransitiveOptions(
                this: *mut root::JS::TransitiveCompileOptions,
                rhs: *const root::JS::TransitiveCompileOptions,
            );
            #[link_name = "\u{1}_ZN2JS22ReadOnlyCompileOptions27copyPODNonTransitiveOptionsERKS0_"]
            pub fn ReadOnlyCompileOptions_copyPODNonTransitiveOptions(
                this: *mut root::JS::ReadOnlyCompileOptions,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            );
            /// Set this to a copy of |rhs|.  Return false on OOM.
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptions4copyEP9JSContextRKNS_22ReadOnlyCompileOptionsE"]
            pub fn OwningCompileOptions_copy(
                this: *mut root::JS::OwningCompileOptions,
                cx: *mut root::JSContext,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptions4copyEPN2js15FrontendContextERKNS_22ReadOnlyCompileOptionsE"]
            pub fn OwningCompileOptions_copy1(
                this: *mut root::JS::OwningCompileOptions,
                fc: *mut root::JS::FrontendContext,
                rhs: *const root::JS::ReadOnlyCompileOptions,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptions5stealEOS0_"]
            pub fn OwningCompileOptions_steal(
                this: *mut root::JS::OwningCompileOptions,
                rhs: *mut root::JS::OwningCompileOptions,
            );
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptions5stealEONS_19OwningDecodeOptionsE"]
            pub fn OwningCompileOptions_steal1(
                this: *mut root::JS::OwningCompileOptions,
                rhs: *mut root::JS::OwningDecodeOptions,
            );
            #[link_name = "\u{1}_ZNK2JS20OwningCompileOptions19sizeOfExcludingThisEPFmPKvE"]
            pub fn OwningCompileOptions_sizeOfExcludingThis(
                this: *const root::JS::OwningCompileOptions,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize;
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptionsC1EP9JSContext"]
            pub fn OwningCompileOptions_OwningCompileOptions(
                this: *mut root::JS::OwningCompileOptions,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS20OwningCompileOptionsD1Ev"]
            pub fn OwningCompileOptions_OwningCompileOptions_destructor(
                this: *mut root::JS::OwningCompileOptions,
            );
            #[link_name = "\u{1}_ZN2JS14CompileOptions27setIntroductionInfoToCallerEP9JSContextPKcNS_13MutableHandleIP8JSScriptEE"]
            pub fn CompileOptions_setIntroductionInfoToCaller(
                this: *mut root::JS::CompileOptions,
                cx: *mut root::JSContext,
                introductionType: *const ::std::os::raw::c_char,
                introductionScript: root::JS::MutableHandle<*mut root::JSScript>,
            ) -> *mut root::JS::CompileOptions;
            #[link_name = "\u{1}_ZN2JS14CompileOptionsC1EP9JSContext"]
            pub fn CompileOptions_CompileOptions(
                this: *mut root::JS::CompileOptions,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS19OwningDecodeOptions4copyEPN2js15FrontendContextERKNS_21ReadOnlyDecodeOptionsE"]
            pub fn OwningDecodeOptions_copy(
                this: *mut root::JS::OwningDecodeOptions,
                maybeFc: *mut root::JS::FrontendContext,
                rhs: *const root::JS::ReadOnlyDecodeOptions,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS19OwningDecodeOptions14infallibleCopyERKNS_21ReadOnlyDecodeOptionsE"]
            pub fn OwningDecodeOptions_infallibleCopy(
                this: *mut root::JS::OwningDecodeOptions,
                rhs: *const root::JS::ReadOnlyDecodeOptions,
            );
            #[link_name = "\u{1}_ZNK2JS19OwningDecodeOptions19sizeOfExcludingThisEPFmPKvE"]
            pub fn OwningDecodeOptions_sizeOfExcludingThis(
                this: *const root::JS::OwningDecodeOptions,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize;
            #[link_name = "\u{1}_ZN2JS19OwningDecodeOptionsD1Ev"]
            pub fn OwningDecodeOptions_OwningDecodeOptions_destructor(
                this: *mut root::JS::OwningDecodeOptions,
            );
            #[link_name = "\u{1}_ZN2JS14ContextOptions10setFuzzingEb"]
            pub fn ContextOptions_setFuzzing(
                this: *mut root::JS::ContextOptions,
                flag: bool,
            ) -> *mut root::JS::ContextOptions;
            #[link_name = "\u{1}_ZN2JS17ContextOptionsRefEP9JSContext"]
            pub fn ContextOptionsRef(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::ContextOptions;
            #[link_name = "\u{1}_ZN2JSL10GenericNaNEv"]
            pub fn GenericNaN() -> f64;
            #[link_name = "\u{1}_ZN2JSL8InfinityEv"]
            pub fn Infinity() -> f64;
            #[link_name = "\u{1}_ZN2JSL15CanonicalizeNaNEd"]
            pub fn CanonicalizeNaN(d: f64) -> f64;
            #[link_name = "\u{1}_ZNK2JS5Value4dumpEv"]
            pub fn Value_dump(this: *const root::JS::Value);
            #[link_name = "\u{1}_ZNK2JS5Value4dumpERN2js14GenericPrinterE"]
            pub fn Value_dump1(
                this: *const root::JS::Value,
                out: *mut root::js::GenericPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS5Value4dumpERN2js11JSONPrinterE"]
            pub fn Value_dump2(
                this: *const root::JS::Value,
                json: *mut root::js::JSONPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS5Value10dumpFieldsERN2js11JSONPrinterE"]
            pub fn Value_dumpFields(
                this: *const root::JS::Value,
                json: *mut root::js::JSONPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS5Value17dumpStringContentERN2js14GenericPrinterE"]
            pub fn Value_dumpStringContent(
                this: *const root::JS::Value,
                out: *mut root::js::GenericPrinter,
            );
            #[link_name = "\u{1}_ZN2JSL21ExposeValueToActiveJSERKNS_5ValueE"]
            pub fn ExposeValueToActiveJS(v: *const root::JS::Value);
            #[link_name = "\u{1}_ZN2JSL9NullValueEv"]
            pub fn NullValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL14UndefinedValueEv"]
            pub fn UndefinedValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL10Int32ValueEi"]
            pub fn Int32Value(i32_: i32) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11DoubleValueEd"]
            pub fn DoubleValue(dbl: f64) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL24CanonicalizedDoubleValueEd"]
            pub fn CanonicalizedDoubleValue(d: f64) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL8NaNValueEv"]
            pub fn NaNValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL13InfinityValueEv"]
            pub fn InfinityValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL12Float32ValueEf"]
            pub fn Float32Value(f: f32) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11StringValueEP8JSString"]
            pub fn StringValue(str_: *mut root::JSString) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11SymbolValueEPNS_6SymbolE"]
            pub fn SymbolValue(sym: *mut root::JS::Symbol) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11BigIntValueEPNS_6BigIntE"]
            pub fn BigIntValue(bi: *mut root::JS::BigInt) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL12BooleanValueEb"]
            pub fn BooleanValue(boo: bool) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL9TrueValueEv"]
            pub fn TrueValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL10FalseValueEv"]
            pub fn FalseValue() -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11ObjectValueER8JSObject"]
            pub fn ObjectValue(obj: *mut root::JSObject) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL10MagicValueE10JSWhyMagic"]
            pub fn MagicValue(why: root::JSWhyMagic) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL16MagicValueUint32Ej"]
            pub fn MagicValueUint32(payload: u32) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL11NumberValueEj"]
            pub fn NumberValue(i: u32) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL17ObjectOrNullValueEP8JSObject"]
            pub fn ObjectOrNullValue(obj: *mut root::JSObject) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL12PrivateValueEPv"]
            pub fn PrivateValue(ptr: *mut ::std::os::raw::c_void) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL12PrivateValueEm"]
            pub fn PrivateValue1(ptr: usize) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL18PrivateUint32ValueEj"]
            pub fn PrivateUint32Value(ui: u32) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JSL19PrivateGCThingValueEPN2js2gc4CellE"]
            pub fn PrivateGCThingValue(cell: *mut root::js::gc::Cell) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JS25HeapValuePostWriteBarrierEPNS_5ValueERKS0_S3_"]
            pub fn HeapValuePostWriteBarrier(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
            #[link_name = "\u{1}_ZN2JS22HeapValueWriteBarriersEPNS_5ValueERKS0_S3_"]
            pub fn HeapValueWriteBarriers(
                valuep: *mut root::JS::Value,
                prev: *const root::JS::Value,
                next: *const root::JS::Value,
            );
            #[link_name = "\u{1}_ZN2JS15NullHandleValueE"]
            pub static NullHandleValue: root::JS::HandleValue;
            #[link_name = "\u{1}_ZN2JS20UndefinedHandleValueE"]
            pub static UndefinedHandleValue: root::JS::HandleValue;
            #[link_name = "\u{1}_ZN2JS15TrueHandleValueE"]
            pub static TrueHandleValue: root::JS::HandleValue;
            #[link_name = "\u{1}_ZN2JS16FalseHandleValueE"]
            pub static FalseHandleValue: root::JS::HandleValue;
            #[link_name = "\u{1}_ZN2JS18NothingHandleValueE"]
            pub static NothingHandleValue: root::JS::Handle<root::mozilla::Maybe>;
            /** ES6 draft 20141224, 7.1.1, second algorithm.

 Most users shouldn't call this -- use JS::ToBoolean, ToNumber, or ToString
 instead.  This will typically only be called from custom convert hooks that
 wish to fall back to the ES6 default conversion behavior shared by most
 objects in JS, codified as OrdinaryToPrimitive.*/
            #[link_name = "\u{1}_ZN2JS19OrdinaryToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn OrdinaryToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                type_: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            /** Store in |out| the null-terminated, base-10 result of |ToString| applied to
 |d| per <https://tc39.es/ecma262/#sec-tostring-applied-to-the-number-type>.
 (This will produce "NaN", "-Infinity", or "Infinity" for non-finite |d|.)*/
            #[link_name = "\u{1}_ZN2JS14NumberToStringEdRA32_c"]
            pub fn NumberToString(d: f64, out: *mut [::std::os::raw::c_char; 32usize]);
            #[link_name = "\u{1}_ZN2JS8CallArgs20reportMoreArgsNeededEP9JSContextPKcjj"]
            pub fn CallArgs_reportMoreArgsNeeded(
                cx: *mut root::JSContext,
                fnname: *const ::std::os::raw::c_char,
                required: ::std::os::raw::c_uint,
                actual: ::std::os::raw::c_uint,
            );
            #[link_name = "\u{1}_ZNK2JS11PropertyKey13isPrivateNameEv"]
            pub fn PropertyKey_isPrivateName(this: *const root::JS::PropertyKey) -> bool;
            #[link_name = "\u{1}_ZNK2JS11PropertyKey17isWellKnownSymbolENS_10SymbolCodeE"]
            pub fn PropertyKey_isWellKnownSymbol(
                this: *const root::JS::PropertyKey,
                code: root::JS::SymbolCode,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS11PropertyKey16fromPinnedStringEP8JSString"]
            pub fn PropertyKey_fromPinnedString(
                str_: *mut root::JSString,
            ) -> root::JS::PropertyKey;
            #[link_name = "\u{1}_ZNK2JS11PropertyKey4dumpEv"]
            pub fn PropertyKey_dump(this: *const root::JS::PropertyKey);
            #[link_name = "\u{1}_ZNK2JS11PropertyKey4dumpERN2js14GenericPrinterE"]
            pub fn PropertyKey_dump1(
                this: *const root::JS::PropertyKey,
                out: *mut root::js::GenericPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS11PropertyKey4dumpERN2js11JSONPrinterE"]
            pub fn PropertyKey_dump2(
                this: *const root::JS::PropertyKey,
                json: *mut root::js::JSONPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS11PropertyKey10dumpFieldsERN2js11JSONPrinterE"]
            pub fn PropertyKey_dumpFields(
                this: *const root::JS::PropertyKey,
                json: *mut root::js::JSONPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS11PropertyKey16dumpPropertyNameERN2js14GenericPrinterE"]
            pub fn PropertyKey_dumpPropertyName(
                this: *const root::JS::PropertyKey,
                out: *mut root::js::GenericPrinter,
            );
            #[link_name = "\u{1}_ZNK2JS11PropertyKey17dumpStringContentERN2js14GenericPrinterE"]
            pub fn PropertyKey_dumpStringContent(
                this: *const root::JS::PropertyKey,
                out: *mut root::js::GenericPrinter,
            );
            #[link_name = "\u{1}_ZN2JS21VoidHandlePropertyKeyE"]
            pub static VoidHandlePropertyKey: root::JS::HandleId;
            /** Get one of the well-known symbols defined by ES6 as PropertyKey. This is
 equivalent to calling JS::GetWellKnownSymbol and then creating a PropertyKey.

 `which` must be in the range [0, WellKnownSymbolLimit).*/
            #[link_name = "\u{1}_ZN2JS21GetWellKnownSymbolKeyEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbolKey(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> root::JS::PropertyKey;
            /// Generate getter/setter id for given id, by adding "get " or "set " prefix.
            #[link_name = "\u{1}_ZN2JS10ToGetterIdEP9JSContextNS_6HandleINS_11PropertyKeyEEENS_13MutableHandleIS3_EE"]
            pub fn ToGetterId(
                cx: *mut root::JSContext,
                id: root::JS::Handle<root::JS::PropertyKey>,
                getterId: root::JS::MutableHandle<root::JS::PropertyKey>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS10ToSetterIdEP9JSContextNS_6HandleINS_11PropertyKeyEEENS_13MutableHandleIS3_EE"]
            pub fn ToSetterId(
                cx: *mut root::JSContext,
                id: root::JS::Handle<root::JS::PropertyKey>,
                setterId: root::JS::MutableHandle<root::JS::PropertyKey>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult20failCantRedefinePropEv"]
            pub fn ObjectOpResult_failCantRedefineProp(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult12failReadOnlyEv"]
            pub fn ObjectOpResult_failReadOnly(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult14failGetterOnlyEv"]
            pub fn ObjectOpResult_failGetterOnly(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult14failCantDeleteEv"]
            pub fn ObjectOpResult_failCantDelete(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult21failCantSetInterposedEv"]
            pub fn ObjectOpResult_failCantSetInterposed(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult27failCantDefineWindowElementEv"]
            pub fn ObjectOpResult_failCantDefineWindowElement(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult27failCantDeleteWindowElementEv"]
            pub fn ObjectOpResult_failCantDeleteWindowElement(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult33failCantDefineWindowNamedPropertyEv"]
            pub fn ObjectOpResult_failCantDefineWindowNamedProperty(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult33failCantDeleteWindowNamedPropertyEv"]
            pub fn ObjectOpResult_failCantDeleteWindowNamedProperty(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult25failCantPreventExtensionsEv"]
            pub fn ObjectOpResult_failCantPreventExtensions(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult16failCantSetProtoEv"]
            pub fn ObjectOpResult_failCantSetProto(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult17failNoNamedSetterEv"]
            pub fn ObjectOpResult_failNoNamedSetter(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult19failNoIndexedSetterEv"]
            pub fn ObjectOpResult_failNoIndexedSetter(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult21failNotDataDescriptorEv"]
            pub fn ObjectOpResult_failNotDataDescriptor(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult21failInvalidDescriptorEv"]
            pub fn ObjectOpResult_failInvalidDescriptor(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult35failCantDefineWindowNonConfigurableEv"]
            pub fn ObjectOpResult_failCantDefineWindowNonConfigurable(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult18failBadArrayLengthEv"]
            pub fn ObjectOpResult_failBadArrayLength(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult12failBadIndexEv"]
            pub fn ObjectOpResult_failBadIndex(
                this: *mut root::JS::ObjectOpResult,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult11reportErrorEP9JSContextNS_6HandleIP8JSObjectEENS3_INS_11PropertyKeyEEE"]
            pub fn ObjectOpResult_reportError(
                this: *mut root::JS::ObjectOpResult,
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                id: root::JS::HandleId,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ObjectOpResult11reportErrorEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ObjectOpResult_reportError1(
                this: *mut root::JS::ObjectOpResult,
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions29setNewCompartmentInSystemZoneEv"]
            pub fn RealmCreationOptions_setNewCompartmentInSystemZone(
                this: *mut root::JS::RealmCreationOptions,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions31setNewCompartmentInExistingZoneEP8JSObject"]
            pub fn RealmCreationOptions_setNewCompartmentInExistingZone(
                this: *mut root::JS::RealmCreationOptions,
                obj: *mut root::JSObject,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions24setNewCompartmentAndZoneEv"]
            pub fn RealmCreationOptions_setNewCompartmentAndZone(
                this: *mut root::JS::RealmCreationOptions,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions22setExistingCompartmentEP8JSObject"]
            pub fn RealmCreationOptions_setExistingCompartment(
                this: *mut root::JS::RealmCreationOptions,
                obj: *mut root::JSObject,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions22setExistingCompartmentEPNS_11CompartmentE"]
            pub fn RealmCreationOptions_setExistingCompartment1(
                this: *mut root::JS::RealmCreationOptions,
                compartment: *mut root::JS::Compartment,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZNK2JS20RealmCreationOptions32getSharedMemoryAndAtomicsEnabledEv"]
            pub fn RealmCreationOptions_getSharedMemoryAndAtomicsEnabled(
                this: *const root::JS::RealmCreationOptions,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions32setSharedMemoryAndAtomicsEnabledEb"]
            pub fn RealmCreationOptions_setSharedMemoryAndAtomicsEnabled(
                this: *mut root::JS::RealmCreationOptions,
                flag: bool,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZNK2JS20RealmCreationOptions21getCoopAndCoepEnabledEv"]
            pub fn RealmCreationOptions_getCoopAndCoepEnabled(
                this: *const root::JS::RealmCreationOptions,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions21setCoopAndCoepEnabledEb"]
            pub fn RealmCreationOptions_setCoopAndCoepEnabled(
                this: *mut root::JS::RealmCreationOptions,
                flag: bool,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS20RealmCreationOptions14setLocaleCopyZEPKc"]
            pub fn RealmCreationOptions_setLocaleCopyZ(
                this: *mut root::JS::RealmCreationOptions,
                locale: *const ::std::os::raw::c_char,
            ) -> *mut root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEPNS_5RealmE"]
            pub fn RealmCreationOptionsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS23RealmCreationOptionsRefEP9JSContext"]
            pub fn RealmCreationOptionsRef1(
                cx: *mut root::JSContext,
            ) -> *const root::JS::RealmCreationOptions;
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEPNS_5RealmE"]
            pub fn RealmBehaviorsRef(
                realm: *mut root::JS::Realm,
            ) -> *const root::JS::RealmBehaviors;
            #[link_name = "\u{1}_ZN2JS17RealmBehaviorsRefEP9JSContext"]
            pub fn RealmBehaviorsRef1(
                cx: *mut root::JSContext,
            ) -> *const root::JS::RealmBehaviors;
            #[link_name = "\u{1}_ZN2JS15SetRealmNonLiveEPNS_5RealmE"]
            pub fn SetRealmNonLive(realm: *mut root::JS::Realm);
            #[link_name = "\u{1}_ZN2JS38SetRealmReduceTimerPrecisionCallerTypeEPNS_5RealmENS_18RTPCallerTypeTokenE"]
            pub fn SetRealmReduceTimerPrecisionCallerType(
                realm: *mut root::JS::Realm,
                type_: root::JS::RTPCallerTypeToken,
            );
            /** Re-query the system to determine the current time zone adjustment from UTC,
 including any component due to DST.  If the time zone has changed, this will
 cause all Date object non-UTC methods and formatting functions to produce
 appropriately adjusted results.

 Left to its own devices, SpiderMonkey itself may occasionally try to detect
 system time changes.  However, no particular frequency of checking is
 guaranteed.  Embedders unable to accept occasional inaccuracies should call
 this method in response to system time changes, or immediately before
 operations requiring instantaneous correctness, to guarantee correct
 behavior.*/
            #[link_name = "\u{1}_ZN2JS13ResetTimeZoneEv"]
            pub fn ResetTimeZone();
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextNS_11ClippedTimeE"]
            pub fn NewDateObject(
                cx: *mut root::JSContext,
                time: root::JS::ClippedTime,
            ) -> *mut root::JSObject;
            /** Create a new Date object for a year/month/day-of-month/hour/minute/second.

 The created date is initialized with the time value

   TimeClip(UTC(MakeDate(MakeDay(year, mon, mday),
                MakeTime(hour, min, sec, 0.0))))

 where each function/operation is as specified in ECMAScript.*/
            #[link_name = "\u{1}_ZN2JS13NewDateObjectEP9JSContextiiiiii"]
            pub fn NewDateObject1(
                cx: *mut root::JSContext,
                year: ::std::os::raw::c_int,
                mon: ::std::os::raw::c_int,
                mday: ::std::os::raw::c_int,
                hour: ::std::os::raw::c_int,
                min: ::std::os::raw::c_int,
                sec: ::std::os::raw::c_int,
            ) -> *mut root::JSObject;
            /** On success, returns true, setting |*isDate| to true if |obj| is a Date
 object or a wrapper around one, or to false if not.  Returns false on
 failure.

 This method returns true with |*isDate == false| when passed an ES6 proxy
 whose target is a Date, or when passed a revoked proxy.*/
            #[link_name = "\u{1}_ZN2JS12ObjectIsDateEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsDate(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isDate: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjj"]
            pub fn MakeDate(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
            ) -> f64;
            #[link_name = "\u{1}_ZN2JS8MakeDateEdjjd"]
            pub fn MakeDate1(
                year: f64,
                month: ::std::os::raw::c_uint,
                day: ::std::os::raw::c_uint,
                time: f64,
            ) -> f64;
            #[link_name = "\u{1}_ZN2JS12YearFromTimeEd"]
            pub fn YearFromTime(time: f64) -> f64;
            #[link_name = "\u{1}_ZN2JS13MonthFromTimeEd"]
            pub fn MonthFromTime(time: f64) -> f64;
            #[link_name = "\u{1}_ZN2JS11DayFromTimeEd"]
            pub fn DayFromTime(time: f64) -> f64;
            #[link_name = "\u{1}_ZN2JS11DayFromYearEd"]
            pub fn DayFromYear(year: f64) -> f64;
            #[link_name = "\u{1}_ZN2JS13DayWithinYearEdd"]
            pub fn DayWithinYear(time: f64, year: f64) -> f64;
            #[link_name = "\u{1}_ZN2JS41SetReduceMicrosecondTimePrecisionCallbackEPFddNS_18RTPCallerTypeTokenEP9JSContextE"]
            pub fn SetReduceMicrosecondTimePrecisionCallback(
                callback: root::JS::ReduceMicrosecondTimePrecisionCallback,
            );
            #[link_name = "\u{1}_ZN2JS41GetReduceMicrosecondTimePrecisionCallbackEv"]
            pub fn GetReduceMicrosecondTimePrecisionCallback() -> root::JS::ReduceMicrosecondTimePrecisionCallback;
            #[link_name = "\u{1}_ZN2JS21SetTimeResolutionUsecEjb"]
            pub fn SetTimeResolutionUsec(resolution: u32, jitter: bool);
            #[link_name = "\u{1}_ZN2JS14IsISOStyleDateEP9JSContextRKNS_11Latin1CharsE"]
            pub fn IsISOStyleDate(
                cx: *mut root::JSContext,
                str_: *const root::JS::Latin1Chars,
            ) -> bool;
            /** Store |v1 === v2| to |*equal| -- strict equality, which performs no
 conversions on |v1| or |v2| before comparing.

 This operation can fail only if an internal error occurs (e.g. OOM while
 linearizing a string value).*/
            #[link_name = "\u{1}_ZN2JS13StrictlyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn StrictlyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
            /** Store |v1 == v2| to |*equal| -- loose equality, which may perform
 user-modifiable conversions on |v1| or |v2|.

 This operation can fail if a user-modifiable conversion fails *or* if an
 internal error occurs. (e.g. OOM while linearizing a string value).*/
            #[link_name = "\u{1}_ZN2JS12LooselyEqualEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn LooselyEqual(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                equal: *mut bool,
            ) -> bool;
            /** Stores |SameValue(v1, v2)| to |*equal| -- using the SameValue operation
 defined in ECMAScript, initially exposed to script as |Object.is|.  SameValue
 behaves identically to strict equality, except that it equates two NaN values
 and does not equate differently-signed zeroes.  It performs no conversions on
 |v1| or |v2| before comparing.

 This operation can fail only if an internal error occurs (e.g. OOM while
 linearizing a string value).*/
            #[link_name = "\u{1}_ZN2JS9SameValueEP9JSContextNS_6HandleINS_5ValueEEES4_Pb"]
            pub fn SameValue(
                cx: *mut root::JSContext,
                v1: root::JS::Handle<root::JS::Value>,
                v2: root::JS::Handle<root::JS::Value>,
                same: *mut bool,
            ) -> bool;
            /** Implements |SameValueZero(v1, v2)| for Number values |v1| and |v2|.
 SameValueZero equates NaNs, equal nonzero values, and zeroes without respect
 to their signs.*/
            #[link_name = "\u{1}_ZN2JSL13SameValueZeroEdd"]
            pub fn SameValueZero(v1: f64, v2: f64) -> bool;
            #[must_use]
            /** Initialize the iterator.  If AllowNonIterable is passed then if getting
 the @@iterator property from iterable returns undefined init() will just
 return true instead of throwing.  Callers must then check
 valueIsIterable() before continuing with the iteration.*/
            #[link_name = "\u{1}_ZN2JS13ForOfIterator4initENS_6HandleINS_5ValueEEENS0_19NonIterableBehaviorE"]
            pub fn ForOfIterator_init(
                this: *mut root::JS::ForOfIterator,
                iterable: root::JS::Handle<root::JS::Value>,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool;
            #[must_use]
            /** Get the next value from the iterator.  If false *done is true
 after this call, do not examine val.*/
            #[link_name = "\u{1}_ZN2JS13ForOfIterator4nextENS_13MutableHandleINS_5ValueEEEPb"]
            pub fn ForOfIterator_next(
                this: *mut root::JS::ForOfIterator,
                val: root::JS::MutableHandle<root::JS::Value>,
                done: *mut bool,
            ) -> bool;
            /** Close the iterator.
 For the case that completion type is throw.*/
            #[link_name = "\u{1}_ZN2JS13ForOfIterator10closeThrowEv"]
            pub fn ForOfIterator_closeThrow(this: *mut root::JS::ForOfIterator);
            #[link_name = "\u{1}_ZN2JS18InitSelfHostedCodeEP9JSContextN7mozilla4SpanIKhLm4294967295EEEPFbS1_S5_E"]
            pub fn InitSelfHostedCode(
                cx: *mut root::JSContext,
                cache: root::JS::SelfHostedCache,
                writer: root::JS::SelfHostedWriter,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS17DisableJitBackendEv"]
            pub fn DisableJitBackend();
            /** An API akin to JS_Stringify but with the goal of not having observable
 side-effects when the stringification is performed.  This means it does not
 allow a replacer or a custom space and has the following constraints on its
 input:

 1) The input must be a plain object or array, not an abitrary value.
 2) Every value in the graph reached by the algorithm starting with this
    object must be one of the following: null, undefined, a string (NOT a
    string object!), a boolean, a finite number (i.e. no NaN or Infinity or
    -Infinity), a plain object with no accessor properties, or an Array with
    no holes.

 The actual behavior differs from JS_Stringify only in asserting the above and
 NOT attempting to get the "toJSON" property from things, since that could
 clearly have side-effects.*/
            #[link_name = "\u{1}_ZN2JS17ToJSONMaybeSafelyEP9JSContextNS_6HandleIP8JSObjectEEPFbPKDsjPvES8_"]
            pub fn ToJSONMaybeSafely(
                cx: *mut root::JSContext,
                input: root::JS::Handle<*mut root::JSObject>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
            /** Performs the JSON.stringify operation, as specified by ECMAScript, except
 writing stringified data by one call of |callback|, passing |data| as
 argument.

 In cases where JSON.stringify would return undefined, this function does not
 call |callback| at all.*/
            #[link_name = "\u{1}_ZN2JS6ToJSONEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEES4_PFbPKDsjPvESA_"]
            pub fn ToJSON(
                cx: *mut root::JSContext,
                value: root::JS::Handle<root::JS::Value>,
                replacer: root::JS::Handle<*mut root::JSObject>,
                space: root::JS::Handle<root::JS::Value>,
                callback: root::JSONWriteCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
            /// Returns true if the given text is valid JSON.
            #[link_name = "\u{1}_ZN2JS11IsValidJSONEPKhj"]
            pub fn IsValidJSON(chars: *const root::JS::Latin1Char, len: u32) -> bool;
            #[link_name = "\u{1}_ZN2JS11IsValidJSONEPKDsj"]
            pub fn IsValidJSON1(chars: *const u16, len: u32) -> bool;
            /** Performs the JSON.parse operation as specified by ECMAScript, and call
 callbacks defined by the handler.*/
            #[link_name = "\u{1}_ZN2JS20ParseJSONWithHandlerEPKhjPNS_16JSONParseHandlerE"]
            pub fn ParseJSONWithHandler(
                chars: *const root::JS::Latin1Char,
                len: u32,
                handler: *mut root::JS::JSONParseHandler,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20ParseJSONWithHandlerEPKDsjPNS_16JSONParseHandlerE"]
            pub fn ParseJSONWithHandler1(
                chars: *const u16,
                len: u32,
                handler: *mut root::JS::JSONParseHandler,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS16NotableClassInfoC1EPKcRKNS_9ClassInfoE"]
            pub fn NotableClassInfo_NotableClassInfo(
                this: *mut root::JS::NotableClassInfo,
                className: *const ::std::os::raw::c_char,
                info: *const root::JS::ClassInfo,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS17NotableStringInfoC1EP8JSStringRKNS_10StringInfoE"]
            pub fn NotableStringInfo_NotableStringInfo(
                this: *mut root::JS::NotableStringInfo,
                str_: *mut root::JSString,
                info: *const root::JS::StringInfo,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS23NotableScriptSourceInfoC1EPKcRKNS_16ScriptSourceInfoE"]
            pub fn NotableScriptSourceInfo_NotableScriptSourceInfo(
                this: *mut root::JS::NotableScriptSourceInfo,
                filename: *const ::std::os::raw::c_char,
                info: *const root::JS::ScriptSourceInfo,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS9ZoneStats11initStringsEv"]
            pub fn ZoneStats_initStrings(this: *mut root::JS::ZoneStats);
            #[link_name = "\u{1}_ZN2JS10RealmStats11initClassesEv"]
            pub fn RealmStats_initClasses(this: *mut root::JS::RealmStats);
            #[link_name = "\u{1}_ZN2JS18CollectGlobalStatsEPNS_11GlobalStatsE"]
            pub fn CollectGlobalStats(gStats: *mut root::JS::GlobalStats) -> bool;
            #[link_name = "\u{1}_ZN2JS19CollectRuntimeStatsEP9JSContextPNS_12RuntimeStatsEPNS_20ObjectPrivateVisitorEb"]
            pub fn CollectRuntimeStats(
                cx: *mut root::JSContext,
                rtStats: *mut root::JS::RuntimeStats,
                opv: *mut root::JS::ObjectPrivateVisitor,
                anonymize: bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS22SystemCompartmentCountEP9JSContext"]
            pub fn SystemCompartmentCount(cx: *mut root::JSContext) -> usize;
            #[link_name = "\u{1}_ZN2JS20UserCompartmentCountEP9JSContext"]
            pub fn UserCompartmentCount(cx: *mut root::JSContext) -> usize;
            #[link_name = "\u{1}_ZN2JS16SystemRealmCountEP9JSContext"]
            pub fn SystemRealmCount(cx: *mut root::JSContext) -> usize;
            #[link_name = "\u{1}_ZN2JS14UserRealmCountEP9JSContext"]
            pub fn UserRealmCount(cx: *mut root::JSContext) -> usize;
            #[link_name = "\u{1}_ZN2JS19PeakSizeOfTemporaryEPK9JSContext"]
            pub fn PeakSizeOfTemporary(cx: *const root::JSContext) -> usize;
            #[link_name = "\u{1}_ZN2JS12AddSizeOfTabEP9JSContextNS_6HandleIP8JSObjectEEPFmPKvEPNS_20ObjectPrivateVisitorEPNS_8TabSizesE"]
            pub fn AddSizeOfTab(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::TabSizes,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14AddServoSizeOfEP9JSContextPFmPKvEPNS_20ObjectPrivateVisitorEPNS_10ServoSizesE"]
            pub fn AddServoSizeOf(
                cx: *mut root::JSContext,
                mallocSizeOf: root::mozilla::MallocSizeOf,
                opv: *mut root::JS::ObjectPrivateVisitor,
                sizes: *mut root::JS::ServoSizes,
            ) -> bool;
            /// Get the HostResolveImportedModule hook for the runtime.
            #[link_name = "\u{1}_ZN2JS20GetModuleResolveHookEP9JSRuntime"]
            pub fn GetModuleResolveHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleResolveHook;
            /// Set the HostResolveImportedModule hook for the runtime to the given function.
            #[link_name = "\u{1}_ZN2JS20SetModuleResolveHookEP9JSRuntimePFP8JSObjectP9JSContextNS_6HandleINS_5ValueEEENS6_IS3_EEE"]
            pub fn SetModuleResolveHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleResolveHook,
            );
            /// Get the hook for populating the import.meta metadata object.
            #[link_name = "\u{1}_ZN2JS21GetModuleMetadataHookEP9JSRuntime"]
            pub fn GetModuleMetadataHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleMetadataHook;
            /** Set the hook for populating the import.meta metadata object to the given
 function.*/
            #[link_name = "\u{1}_ZN2JS21SetModuleMetadataHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEEE"]
            pub fn SetModuleMetadataHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleMetadataHook,
            );
            /// Get the HostImportModuleDynamically hook for the runtime.
            #[link_name = "\u{1}_ZN2JS26GetModuleDynamicImportHookEP9JSRuntime"]
            pub fn GetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
            ) -> root::JS::ModuleDynamicImportHook;
            /** Set the HostImportModuleDynamically hook for the runtime to the given
 function.

 If this hook is not set (or set to nullptr) then the JS engine will throw an
 exception if dynamic module import is attempted.*/
            #[link_name = "\u{1}_ZN2JS26SetModuleDynamicImportHookEP9JSRuntimePFbP9JSContextNS_6HandleINS_5ValueEEENS4_IP8JSObjectEES9_E"]
            pub fn SetModuleDynamicImportHook(
                rt: *mut root::JSRuntime,
                func: root::JS::ModuleDynamicImportHook,
            );
            /** This must be called after a dynamic import operation is complete.

 If |evaluationPromise| is rejected, the rejection reason will be used to
 complete the user's promise.*/
            #[link_name = "\u{1}_ZN2JS25FinishDynamicModuleImportEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES5_S5_"]
            pub fn FinishDynamicModuleImport(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                referencingPrivate: root::JS::Handle<root::JS::Value>,
                moduleRequest: root::JS::Handle<*mut root::JSObject>,
                promise: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
            /** Parse the given source buffer as a module in the scope of the current global
 of cx and return a source text module record.*/
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
            /** Parse the given source buffer as a module in the scope of the current global
 of cx and return a source text module record.  An error is reported if a
 UTF-8 encoding error is encountered.*/
            #[link_name = "\u{1}_ZN2JS13CompileModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModule1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> *mut root::JSObject;
            /** Parse the given source buffer as a JSON module in the scope of the current
 global of cx and return a synthetic module record.*/
            #[link_name = "\u{1}_ZN2JS17CompileJsonModuleEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileJsonModule(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> *mut root::JSObject;
            /// Set a private value associated with a source text module record.
            #[link_name = "\u{1}_ZN2JS16SetModulePrivateEP8JSObjectRKNS_5ValueE"]
            pub fn SetModulePrivate(
                module: *mut root::JSObject,
                value: *const root::JS::Value,
            );
            /** Clear the private value associated with a source text module record.

 This is used during unlinking and can be called on a gray module, skipping
 the usual checks.*/
            #[link_name = "\u{1}_ZN2JS18ClearModulePrivateEP8JSObject"]
            pub fn ClearModulePrivate(module: *mut root::JSObject);
            /// Get the private value associated with a source text module record.
            #[link_name = "\u{1}_ZN2JS16GetModulePrivateEP8JSObject"]
            pub fn GetModulePrivate(module: *mut root::JSObject) -> root::JS::Value;
            #[link_name = "\u{1}_ZN2JS10ModuleLinkEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ModuleLink(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS14ModuleEvaluateEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn ModuleEvaluate(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS30ThrowOnModuleEvaluationFailureEP9JSContextNS_6HandleIP8JSObjectEENS_20ModuleErrorBehaviourE"]
            pub fn ThrowOnModuleEvaluationFailure(
                cx: *mut root::JSContext,
                evaluationPromise: root::JS::Handle<*mut root::JSObject>,
                errorBehaviour: root::JS::ModuleErrorBehaviour,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS24GetRequestedModulesCountEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRequestedModulesCount(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> u32;
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSpecifierEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn GetRequestedModuleSpecifier(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                index: u32,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZN2JS27GetRequestedModuleSourcePosEP9JSContextNS_6HandleIP8JSObjectEEjPjPNS_21ColumnNumberOneOriginE"]
            pub fn GetRequestedModuleSourcePos(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
                index: u32,
                lineNumber: *mut u32,
                columnNumber: *mut root::JS::ColumnNumberOneOrigin,
            );
            #[link_name = "\u{1}_ZN2JS15GetModuleScriptENS_6HandleIP8JSObjectEE"]
            pub fn GetModuleScript(
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSScript;
            #[link_name = "\u{1}_ZN2JS19CreateModuleRequestEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn CreateModuleRequest(
                cx: *mut root::JSContext,
                specifierArg: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS25GetModuleRequestSpecifierEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleRequestSpecifier(
                cx: *mut root::JSContext,
                moduleRequestArg: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
            #[link_name = "\u{1}_ZN2JS15GetModuleObjectENS_6HandleIP8JSScriptEE"]
            pub fn GetModuleObject(
                moduleScript: root::JS::Handle<*mut root::JSScript>,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS18GetModuleNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleNamespace(
                cx: *mut root::JSContext,
                moduleRecord: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS21GetModuleForNamespaceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleForNamespace(
                cx: *mut root::JSContext,
                moduleNamespace: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS20GetModuleEnvironmentEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetModuleEnvironment(
                cx: *mut root::JSContext,
                moduleObj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS22ClearModuleEnvironmentEP8JSObject"]
            pub fn ClearModuleEnvironment(moduleObj: *mut root::JSObject);
            #[link_name = "\u{1}_ZN2JS14ModuleIsLinkedEP8JSObject"]
            pub fn ModuleIsLinked(moduleObj: *mut root::JSObject) -> bool;
            /** Determine the ECMAScript "class" -- Date, String, RegExp, and all the other
 builtin object types (described in ECMAScript in terms of an objecting having
 "an [[ArrayBufferData]] internal slot" or similar language for other kinds of
 object -- of the provided object.

 If this function is passed a wrapper that can be unwrapped, the determination
 is performed on that object.  If the wrapper can't be unwrapped, and it's not
 a wrapper that prefers to treat this operation as a failure, this function
 will indicate that the object is |js::ESClass::Other|.*/
            #[link_name = "\u{1}_ZN2JS15GetBuiltinClassEP9JSContextNS_6HandleIP8JSObjectEEPN2js7ESClassE"]
            pub fn GetBuiltinClass(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                cls: *mut root::js::ESClass,
            ) -> bool;
            /** Get the |JS::Compartment*| of an object.

 Note that the compartment of an object in this realm, that is a
 cross-compartment wrapper around an object from another realm, is the
 compartment of this realm.*/
            #[link_name = "\u{1}_ZN2JSL14GetCompartmentEP8JSObject"]
            pub fn GetCompartment(
                obj: *mut root::JSObject,
            ) -> *mut root::JS::Compartment;
            /** Tell SpiderMonkey to use `queue` to schedule promise reactions.

 SpiderMonkey does not take ownership of the queue; it is the embedding's
 responsibility to clean it up after the runtime is destroyed.*/
            #[link_name = "\u{1}_ZN2JS11SetJobQueueEP9JSContextPNS_8JobQueueE"]
            pub fn SetJobQueue(cx: *mut root::JSContext, queue: *mut root::JS::JobQueue);
            #[link_name = "\u{1}_ZN2JS32AutoDebuggerJobQueueInterruption4initEP9JSContext"]
            pub fn AutoDebuggerJobQueueInterruption_init(
                this: *mut root::JS::AutoDebuggerJobQueueInterruption,
                cx: *mut root::JSContext,
            ) -> bool;
            /** Drain the job queue. (In HTML terminology, perform a microtask checkpoint.)

 To make Debugger hook calls more like HTML tasks or ECMAScript jobs,
 Debugger promises that each hook begins execution with a clean microtask
 queue, and that a microtask checkpoint (queue drain) takes place after each
 hook returns, successfully or otherwise.

 To ensure these debugger-introduced microtask checkpoints serve only the
 hook's microtasks, and never affect the debuggee's, the Debugger API
 implementation uses only this method to perform the checkpoints, thereby
 statically ensuring that an AutoDebuggerJobQueueInterruption is in scope to
 protect the debuggee.

 SavedJobQueue implementations are required to assert that the queue is
 empty before restoring the debuggee's queue. If the Debugger API ever fails
 to perform a microtask checkpoint after calling a hook, that assertion will
 fail, catching the mistake.*/
            #[link_name = "\u{1}_ZN2JS32AutoDebuggerJobQueueInterruption7runJobsEv"]
            pub fn AutoDebuggerJobQueueInterruption_runJobs(
                this: *mut root::JS::AutoDebuggerJobQueueInterruption,
            );
            #[link_name = "\u{1}_ZN2JS32AutoDebuggerJobQueueInterruptionC1Ev"]
            pub fn AutoDebuggerJobQueueInterruption_AutoDebuggerJobQueueInterruption(
                this: *mut root::JS::AutoDebuggerJobQueueInterruption,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS32AutoDebuggerJobQueueInterruptionD1Ev"]
            pub fn AutoDebuggerJobQueueInterruption_AutoDebuggerJobQueueInterruption_destructor(
                this: *mut root::JS::AutoDebuggerJobQueueInterruption,
            );
            /** Sets the callback that's invoked whenever a Promise is rejected without
 a rejection handler, and when a Promise that was previously rejected
 without a handler gets a handler attached.*/
            #[link_name = "\u{1}_ZN2JS34SetPromiseRejectionTrackerCallbackEP9JSContextPFvS1_bNS_6HandleIP8JSObjectEENS_29PromiseRejectionHandlingStateEPvES7_"]
            pub fn SetPromiseRejectionTrackerCallback(
                cx: *mut root::JSContext,
                callback: root::JS::PromiseRejectionTrackerCallback,
                data: *mut ::std::os::raw::c_void,
            );
            /** Inform the runtime that the job queue is empty and the embedding is going to
 execute its last promise job. The runtime may now choose to skip creating
 promise jobs for asynchronous execution and instead continue execution
 synchronously. More specifically, this optimization is used to skip the
 standard job queuing behavior for `await` operations in async functions.

 This function may be called before executing the last job in the job queue.
 When it was called, JobQueueMayNotBeEmpty must be called in order to restore
 the default job queuing behavior before the embedding enqueues its next job
 into the job queue.*/
            #[link_name = "\u{1}_ZN2JS15JobQueueIsEmptyEP9JSContext"]
            pub fn JobQueueIsEmpty(cx: *mut root::JSContext);
            /** Inform the runtime that job queue is no longer empty. The runtime can now no
 longer skip creating promise jobs for asynchronous execution, because
 pending jobs in the job queue must be executed first to preserve the FIFO
 (first in - first out) property of the queue. This effectively undoes
 JobQueueIsEmpty and re-enables the standard job queuing behavior.

 This function must be called whenever enqueuing a job to the job queue when
 JobQueueIsEmpty was called previously.*/
            #[link_name = "\u{1}_ZN2JS21JobQueueMayNotBeEmptyEP9JSContext"]
            pub fn JobQueueMayNotBeEmpty(cx: *mut root::JSContext);
            /** Returns a new instance of the Promise builtin class in the current
 compartment, with the right slot layout.

 The `executor` can be a `nullptr`. In that case, the only way to resolve or
 reject the returned promise is via the `JS::ResolvePromise` and
 `JS::RejectPromise` JSAPI functions.*/
            #[link_name = "\u{1}_ZN2JS16NewPromiseObjectEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn NewPromiseObject(
                cx: *mut root::JSContext,
                executor: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns true if the given object is an unwrapped PromiseObject, false
 otherwise.*/
            #[link_name = "\u{1}_ZN2JS15IsPromiseObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsPromiseObject(obj: root::JS::HandleObject) -> bool;
            /// Returns the current compartment's original Promise constructor.
            #[link_name = "\u{1}_ZN2JS21GetPromiseConstructorEP9JSContext"]
            pub fn GetPromiseConstructor(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            /// Returns the current compartment's original Promise.prototype.
            #[link_name = "\u{1}_ZN2JS19GetPromisePrototypeEP9JSContext"]
            pub fn GetPromisePrototype(cx: *mut root::JSContext) -> *mut root::JSObject;
            /** Returns the given Promise's state as a JS::PromiseState enum value.

 Returns JS::PromiseState::Pending if the given object is a wrapper that
 can't safely be unwrapped.*/
            #[link_name = "\u{1}_ZN2JS15GetPromiseStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseState(
                promise: root::JS::HandleObject,
            ) -> root::JS::PromiseState;
            /// Returns the given Promise's process-unique ID.
            #[link_name = "\u{1}_ZN2JS12GetPromiseIDENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseID(promise: root::JS::HandleObject) -> u64;
            /** Returns the given Promise's result: either the resolution value for
 fulfilled promises, or the rejection reason for rejected ones.*/
            #[link_name = "\u{1}_ZN2JS16GetPromiseResultENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResult(promise: root::JS::HandleObject) -> root::JS::Value;
            /** Returns whether the given promise's rejection is already handled or not.

 The caller must check the given promise is rejected before checking it's
 handled or not.*/
            #[link_name = "\u{1}_ZN2JS19GetPromiseIsHandledENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseIsHandled(promise: root::JS::HandleObject) -> bool;
            #[link_name = "\u{1}_ZN2JS26SetSettledPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSettledPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
            #[must_use]
            #[link_name = "\u{1}_ZN2JS22SetAnyPromiseIsHandledEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetAnyPromiseIsHandled(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            ) -> bool;
            /** Returns a js::SavedFrame linked list of the stack that lead to the given
 Promise's allocation.*/
            #[link_name = "\u{1}_ZN2JS24GetPromiseAllocationSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseAllocationSite(
                promise: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS24GetPromiseResolutionSiteENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseResolutionSite(
                promise: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS25DumpPromiseAllocationSiteEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DumpPromiseAllocationSite(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            );
            #[link_name = "\u{1}_ZN2JS25DumpPromiseResolutionSiteEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn DumpPromiseResolutionSite(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
            );
            /** Calls the current compartment's original Promise.resolve on the original
 Promise constructor, with `resolutionValue` passed as an argument.*/
            #[link_name = "\u{1}_ZN2JS26CallOriginalPromiseResolveEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseResolve(
                cx: *mut root::JSContext,
                resolutionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
            /** Calls the current compartment's original Promise.reject on the original
 Promise constructor, with `resolutionValue` passed as an argument.*/
            #[link_name = "\u{1}_ZN2JS25CallOriginalPromiseRejectEP9JSContextNS_6HandleINS_5ValueEEE"]
            pub fn CallOriginalPromiseReject(
                cx: *mut root::JSContext,
                rejectionValue: root::JS::HandleValue,
            ) -> *mut root::JSObject;
            /** Resolves the given Promise with the given `resolutionValue`.

 Calls the `resolve` function that was passed to the executor function when
 the Promise was created.*/
            #[link_name = "\u{1}_ZN2JS14ResolvePromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ResolvePromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                resolutionValue: root::JS::HandleValue,
            ) -> bool;
            /** Rejects the given `promise` with the given `rejectionValue`.

 Calls the `reject` function that was passed to the executor function when
 the Promise was created.*/
            #[link_name = "\u{1}_ZN2JS13RejectPromiseEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn RejectPromise(
                cx: *mut root::JSContext,
                promiseObj: root::JS::HandleObject,
                rejectionValue: root::JS::HandleValue,
            ) -> bool;
            /** Create a Promise with the given fulfill/reject handlers, that will be
 fulfilled/rejected with the value/reason that the promise `promise` is
 fulfilled/rejected with.

 This function basically acts like `promise.then(onFulfilled, onRejected)`,
 except that its behavior is unaffected by changes to `Promise`,
 `Promise[Symbol.species]`, `Promise.prototype.then`, `promise.constructor`,
 `promise.then`, and so on.

 This function throws if `promise` is not a Promise from this or another
 realm.

 This function will assert if `onFulfilled` or `onRejected` is non-null and
 also not IsCallable.*/
            #[link_name = "\u{1}_ZN2JS23CallOriginalPromiseThenEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn CallOriginalPromiseThen(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Unforgeable, optimized version of the JS builtin Promise.prototype.then.

 Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to
 enqueue as reactions for that promise. In contrast to Promise.prototype.then,
 this doesn't create and return a new Promise instance.

 Throws a TypeError if `promise` isn't a Promise (or possibly a different
 error if it's a security wrapper or dead object proxy).*/
            #[link_name = "\u{1}_ZN2JS19AddPromiseReactionsEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactions(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
            /** Unforgeable, optimized version of the JS builtin Promise.prototype.then.

 Takes a Promise instance and nullable `onFulfilled`/`onRejected` callables to
 enqueue as reactions for that promise. In contrast to Promise.prototype.then,
 this doesn't create and return a new Promise instance.

 Throws a TypeError if `promise` isn't a Promise (or possibly a different
 error if it's a security wrapper or dead object proxy).

 If `onRejected` is null and `promise` is rejected, this function -- unlike
 the function above -- will not report an unhandled rejection.*/
            #[link_name = "\u{1}_ZN2JS45AddPromiseReactionsIgnoringUnhandledRejectionEP9JSContextNS_6HandleIP8JSObjectEES5_S5_"]
            pub fn AddPromiseReactionsIgnoringUnhandledRejection(
                cx: *mut root::JSContext,
                promise: root::JS::HandleObject,
                onFulfilled: root::JS::HandleObject,
                onRejected: root::JS::HandleObject,
            ) -> bool;
            /** Returns the given Promise's activation behavior state flag per above as a
 JS::PromiseUserInputEventHandlingState value.  All promises are created with
 the DontCare state by default.

 Returns JS::PromiseUserInputEventHandlingState::DontCare if the given object
 is a wrapper that can't safely be unwrapped.*/
            #[link_name = "\u{1}_ZN2JS37GetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEE"]
            pub fn GetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
            ) -> root::JS::PromiseUserInputEventHandlingState;
            /** Sets the given Promise's activation behavior state flag per above as a
 JS::PromiseUserInputEventHandlingState value.

 Returns false if the given object is a wrapper that can't safely be
 unwrapped.*/
            #[link_name = "\u{1}_ZN2JS37SetPromiseUserInputEventHandlingStateENS_6HandleIP8JSObjectEENS_34PromiseUserInputEventHandlingStateE"]
            pub fn SetPromiseUserInputEventHandlingState(
                promise: root::JS::HandleObject,
                state: root::JS::PromiseUserInputEventHandlingState,
            ) -> bool;
            /** Unforgeable version of the JS builtin Promise.all.

 Takes a HandleObjectVector of Promise objects and returns a promise that's
 resolved with an array of resolution values when all those promises have
 been resolved, or rejected with the rejection value of the first rejected
 promise.

 Asserts that all objects in the `promises` vector are, maybe wrapped,
 instances of `Promise` or a subclass of `Promise`.*/
            #[link_name = "\u{1}_ZN2JS20GetWaitForAllPromiseEP9JSContextNS_6HandleINS_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEE"]
            pub fn GetWaitForAllPromise(
                cx: *mut root::JSContext,
                promises: root::JS::HandleObjectVector,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS23InitDispatchToEventLoopEP9JSContextPFbPvPNS_12DispatchableEES2_"]
            pub fn InitDispatchToEventLoop(
                cx: *mut root::JSContext,
                callback: root::JS::DispatchToEventLoopCallback,
                closure: *mut ::std::os::raw::c_void,
            );
            /** When a JSRuntime is destroyed it implicitly cancels all async tasks in
 progress, releasing any roots held by the task. However, this is not soon
 enough for cycle collection, which needs to have roots dropped earlier so
 that the cycle collector can transitively remove roots for a future GC. For
 these and other cases, the set of pending async tasks can be canceled
 with this call earlier than JSRuntime destruction.*/
            #[link_name = "\u{1}_ZN2JS18ShutdownAsyncTasksEP9JSContext"]
            pub fn ShutdownAsyncTasks(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS18PropertyDescriptor5traceEP8JSTracer"]
            pub fn PropertyDescriptor_trace(
                this: *mut root::JS::PropertyDescriptor,
                trc: *mut root::JSTracer,
            );
            #[link_name = "\u{1}_ZN2JS28ToCompletePropertyDescriptorEP9JSContextNS_6HandleINS_5ValueEEENS_13MutableHandleINS_18PropertyDescriptorEEE"]
            pub fn ToCompletePropertyDescriptor(
                cx: *mut root::JSContext,
                descriptor: root::JS::Handle<root::JS::Value>,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS22FromPropertyDescriptorEP9JSContextNS_6HandleIN7mozilla5MaybeINS_18PropertyDescriptorEEEEENS_13MutableHandleINS_5ValueEEE"]
            pub fn FromPropertyDescriptor(
                cx: *mut root::JSContext,
                desc: root::JS::Handle<root::mozilla::Maybe>,
                vp: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Create a new Symbol with the given description. This function never returns
 a Symbol that is in the Runtime-wide symbol registry.

 If description is null, the new Symbol's [[Description]] attribute is
 undefined.*/
            #[link_name = "\u{1}_ZN2JS9NewSymbolEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn NewSymbol(
                cx: *mut root::JSContext,
                description: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
            /** Symbol.for as specified in ES6.

 Get a Symbol with the description 'key' from the Runtime-wide symbol
 registry. If there is not already a Symbol with that description in the
 registry, a new Symbol is created and registered. 'key' must not be null.*/
            #[link_name = "\u{1}_ZN2JS12GetSymbolForEP9JSContextNS_6HandleIP8JSStringEE"]
            pub fn GetSymbolFor(
                cx: *mut root::JSContext,
                key: root::JS::Handle<*mut root::JSString>,
            ) -> *mut root::JS::Symbol;
            /** Get the [[Description]] attribute of the given symbol.

 This function is infallible. If it returns null, that means the symbol's
 [[Description]] is undefined.*/
            #[link_name = "\u{1}_ZN2JS20GetSymbolDescriptionENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolDescription(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> *mut root::JSString;
            /** Return the SymbolCode telling what sort of symbol `symbol` is.

 A symbol's SymbolCode never changes once it is created.*/
            #[link_name = "\u{1}_ZN2JS13GetSymbolCodeENS_6HandleIPNS_6SymbolEEE"]
            pub fn GetSymbolCode(
                symbol: root::JS::Handle<*mut root::JS::Symbol>,
            ) -> root::JS::SymbolCode;
            /** Get one of the well-known symbols defined by ES6. A single set of well-known
 symbols is shared by all compartments in a JSRuntime.

 `which` must be in the range [0, WellKnownSymbolLimit).*/
            #[link_name = "\u{1}_ZN2JS18GetWellKnownSymbolEP9JSContextNS_10SymbolCodeE"]
            pub fn GetWellKnownSymbol(
                cx: *mut root::JSContext,
                which: root::JS::SymbolCode,
            ) -> *mut root::JS::Symbol;
            /// Create an Array from the current realm with the given contents.
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextRKNS_16HandleValueArrayE"]
            pub fn NewArrayObject(
                cx: *mut root::JSContext,
                contents: *const root::JS::HandleValueArray,
            ) -> *mut root::JSObject;
            /** Create an Array from the current realm with the given length and allocate
 memory for all its elements.  (The elements nonetheless will not exist as
 properties on the returned array until values have been assigned to them.)*/
            #[link_name = "\u{1}_ZN2JS14NewArrayObjectEP9JSContextm"]
            pub fn NewArrayObject1(
                cx: *mut root::JSContext,
                length: usize,
            ) -> *mut root::JSObject;
            /** Determine whether |value| is an Array object or a wrapper around one.  (An
 ES6 proxy whose target is an Array object, e.g.
 |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is
 not considered to be an Array.)

 On success set |*isArray| accordingly and return true; on failure return
 false.*/
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleINS_5ValueEEEPb"]
            pub fn IsArrayObject(
                cx: *mut root::JSContext,
                value: root::JS::Handle<root::JS::Value>,
                isArray: *mut bool,
            ) -> bool;
            /** Determine whether |obj| is an Array object or a wrapper around one.  (An
 ES6 proxy whose target is an Array object, e.g.
 |var target = [], handler = {}; Proxy.revocable(target, handler).proxy|, is
 not considered to be an Array.)

 On success set |*isArray| accordingly and return true; on failure return
 false.*/
            #[link_name = "\u{1}_ZN2JS13IsArrayObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArrayObject1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
            /** Store |*lengthp = ToLength(obj.length)| and return true on success, else
 return false.

 If the length does not fit in |uint32_t|, an exception is reported and false
 is returned.

 |ToLength| converts its input to an integer usable to index an
 array-like object.

 If |obj| is an Array, this overall operation is the same as getting
 |obj.length|.*/
            #[link_name = "\u{1}_ZN2JS14GetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEPj"]
            pub fn GetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                lengthp: *mut u32,
            ) -> bool;
            /** Perform |obj.length = length| as if in strict mode code, with a fast path for
 the case where |obj| is an Array.

 This operation is exactly and only assigning to a "length" property.  In
 general, it can invoke an existing "length" setter, throw if the property is
 non-writable, or do anything else a property-set operation might do.*/
            #[link_name = "\u{1}_ZN2JS14SetArrayLengthEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn SetArrayLength(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                length: u32,
            ) -> bool;
            /** ES6 7.2.2.

 Returns false on failure, otherwise returns true and sets |*isArray|
 indicating whether the object passes ECMAScript's IsArray test.  This is the
 same test performed by |Array.isArray|.

 This is NOT the same as asking whether |obj| is an Array or a wrapper around
 one.  If |obj| is a proxy created by |Proxy.revocable()| and has been
 revoked, or if |obj| is a proxy whose target (at any number of hops) is a
 revoked proxy, this method throws a TypeError and returns false.*/
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsArray(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isArray: *mut bool,
            ) -> bool;
            /** Identical to IsArray above, but the nature of the object (if successfully
 determined) is communicated via |*answer|.  In particular this method
 returns true and sets |*answer = IsArrayAnswer::RevokedProxy| when called on
 a revoked proxy.

 Most users will want the overload above, not this one.*/
            #[link_name = "\u{1}_ZN2JS7IsArrayEP9JSContextNS_6HandleIP8JSObjectEEPNS_13IsArrayAnswerE"]
            pub fn IsArray1(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                answer: *mut root::JS::IsArrayAnswer,
            ) -> bool;
            /// Create a new RegExp for the given Latin-1-encoded bytes and flags.
            #[link_name = "\u{1}_ZN2JS15NewRegExpObjectEP9JSContextPKcmNS_11RegExpFlagsE"]
            pub fn NewRegExpObject(
                cx: *mut root::JSContext,
                bytes: *const ::std::os::raw::c_char,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
            /// Create a new RegExp for the given source and flags.
            #[link_name = "\u{1}_ZN2JS17NewUCRegExpObjectEP9JSContextPKDsmNS_11RegExpFlagsE"]
            pub fn NewUCRegExpObject(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS14SetRegExpInputEP9JSContextNS_6HandleIP8JSObjectEENS2_IP8JSStringEE"]
            pub fn SetRegExpInput(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                input: root::JS::Handle<*mut root::JSString>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS18ClearRegExpStaticsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ClearRegExpStatics(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> bool;
            /** Execute a regexp on a given input, starting from |indexp|.
 Returns false on OOM or over-recursion.

 On no match, |rval| is set to Null.
 On a match, |indexp| and the RegExp statics are updated.
 Then, if |test| is true, |rval| is set to true.
 Otherwise, |rval| is set to a match result object.*/
            #[link_name = "\u{1}_ZN2JS13ExecuteRegExpEP9JSContextNS_6HandleIP8JSObjectEES5_PKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Execute a regexp on a given input, starting from |indexp|.
 This is the same as ExecuteRegExp, except it does not update the RegExp
 statics and can be called without a global object.*/
            #[link_name = "\u{1}_ZN2JS22ExecuteRegExpNoStaticsEP9JSContextNS_6HandleIP8JSObjectEEPKDsmPmbNS_13MutableHandleINS_5ValueEEE"]
            pub fn ExecuteRegExpNoStatics(
                cx: *mut root::JSContext,
                reobj: root::JS::Handle<*mut root::JSObject>,
                chars: *const u16,
                length: usize,
                indexp: *mut usize,
                test: bool,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** On success, returns true, setting |*isRegExp| to true if |obj| is a RegExp
 object or a wrapper around one, or to false if not.  Returns false on
 failure.

 This method returns true with |*isRegExp == false| when passed an ES6 proxy
 whose target is a RegExp, or when passed a revoked proxy.*/
            #[link_name = "\u{1}_ZN2JS14ObjectIsRegExpEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ObjectIsRegExp(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
                isRegExp: *mut bool,
            ) -> bool;
            /** Given a RegExp object (or a wrapper around one), return the set of all
 JS::RegExpFlag::* for it.*/
            #[link_name = "\u{1}_ZN2JS14GetRegExpFlagsEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpFlags(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> root::JS::RegExpFlags;
            /** Return the source text for a RegExp object (or a wrapper around one), or null
 on failure.*/
            #[link_name = "\u{1}_ZN2JS15GetRegExpSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn GetRegExpSource(
                cx: *mut root::JSContext,
                obj: root::JS::Handle<*mut root::JSObject>,
            ) -> *mut root::JSString;
            /** Check whether the given source is a valid regexp. If the regexp parses
 successfully, returns true and sets |error| to undefined. If the regexp
 has a syntax error, returns true, sets |error| to that error object, and
 clears the exception. Returns false on OOM or over-recursion.*/
            #[link_name = "\u{1}_ZN2JS17CheckRegExpSyntaxEP9JSContextPKDsmNS_11RegExpFlagsENS_13MutableHandleINS_5ValueEEE"]
            pub fn CheckRegExpSyntax(
                cx: *mut root::JSContext,
                chars: *const u16,
                length: usize,
                flags: root::JS::RegExpFlags,
                error: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Given a SavedFrame JSObject, get its source property. Defaults to the empty
 string.*/
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameSourceEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSource(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourcep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame JSObject, get an ID identifying its ScriptSource.
 Defaults to 0.*/
            #[link_name = "\u{1}_ZN2JS21GetSavedFrameSourceIdEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameSourceId(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                sourceIdp: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame JSObject, get its line property (1-origin).
 Defaults to 0.*/
            #[link_name = "\u{1}_ZN2JS17GetSavedFrameLineEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPjNS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameLine(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                linep: *mut u32,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /// Given a SavedFrame JSObject, get its column property. Defaults to 0.
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameColumnEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEEPNS_27TaggedColumnNumberOneOriginENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameColumn(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                columnp: *mut root::JS::TaggedColumnNumberOneOrigin,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame JSObject, get its functionDisplayName string, or nullptr
 if SpiderMonkey was unable to infer a name for the captured frame's
 function. Defaults to nullptr.*/
            #[link_name = "\u{1}_ZN2JS32GetSavedFrameFunctionDisplayNameEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameFunctionDisplayName(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                namep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /// Given a SavedFrame JSObject, get its asyncCause string. Defaults to nullptr.
            #[link_name = "\u{1}_ZN2JS23GetSavedFrameAsyncCauseEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIP8JSStringEENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncCause(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncCausep: root::JS::MutableHandle<*mut root::JSString>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame JSObject, get its asyncParent SavedFrame object or nullptr
 if there is no asyncParent. The `asyncParentp` out parameter is _NOT_
 guaranteed to be in the cx's compartment. Defaults to nullptr.*/
            #[link_name = "\u{1}_ZN2JS24GetSavedFrameAsyncParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameAsyncParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                asyncParentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame JSObject, get its parent SavedFrame object or nullptr if
 it is the oldest frame in the stack. The `parentp` out parameter is _NOT_
 guaranteed to be in the cx's compartment. Defaults to nullptr.*/
            #[link_name = "\u{1}_ZN2JS19GetSavedFrameParentEP9JSContextP12JSPrincipalsNS_6HandleIP8JSObjectEENS_13MutableHandleIS6_EENS_20SavedFrameSelfHostedE"]
            pub fn GetSavedFrameParent(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                savedFrame: root::JS::Handle<*mut root::JSObject>,
                parentp: root::JS::MutableHandle<*mut root::JSObject>,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> root::JS::SavedFrameResult;
            /** Given a SavedFrame object, convert it and its transitive parents to plain
 objects. Because SavedFrame objects store their properties on the prototype,
 they cannot be usefully stringified to JSON. Assigning their properties to
 plain objects allow those objects to be stringified and the saved frame stack
 can be encoded as a string.*/
            #[link_name = "\u{1}_ZN2JS30ConvertSavedFrameToPlainObjectEP9JSContextNS_6HandleIP8JSObjectEENS_20SavedFrameSelfHostedE"]
            pub fn ConvertSavedFrameToPlainObject(
                cx: *mut root::JSContext,
                savedFrame: root::JS::HandleObject,
                selfHosted: root::JS::SavedFrameSelfHosted,
            ) -> *mut root::JSObject;
            /** Create a new SharedArrayBuffer with the given byte length.  This
 may only be called if
 JS::RealmCreationOptionsRef(cx).getSharedMemoryAndAtomicsEnabled() is
 true.*/
            #[link_name = "\u{1}_ZN2JS20NewSharedArrayBufferEP9JSContextm"]
            pub fn NewSharedArrayBuffer(
                cx: *mut root::JSContext,
                nbytes: usize,
            ) -> *mut root::JSObject;
            /** Check whether obj supports the JS::GetSharedArrayBuffer* APIs.  Note that
 this may return false if a security wrapper is encountered that denies the
 unwrapping. If this test succeeds, then it is safe to call the various
 accessor JSAPI calls defined below.*/
            #[link_name = "\u{1}_ZN2JS25IsSharedArrayBufferObjectEP8JSObject"]
            pub fn IsSharedArrayBufferObject(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS23UnwrapSharedArrayBufferEP8JSObject"]
            pub fn UnwrapSharedArrayBuffer(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS30GetSharedArrayBufferByteLengthEP8JSObject"]
            pub fn GetSharedArrayBufferByteLength(obj: *mut root::JSObject) -> usize;
            #[link_name = "\u{1}_ZN2JS24GetSharedArrayBufferDataEP8JSObjectPbRKNS_15AutoRequireNoGCE"]
            pub fn GetSharedArrayBufferData(
                obj: *mut root::JSObject,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> *mut u8;
            #[link_name = "\u{1}_ZN2JS33GetSharedArrayBufferLengthAndDataEP8JSObjectPmPbPPh"]
            pub fn GetSharedArrayBufferLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            /** Returns true if there are any live SharedArrayBuffer objects, including those
 for wasm memories, associated with the context.  This is conservative,
 because it does not run GC.  Some dead objects may not have been collected
 yet and thus will be thought live.*/
            #[link_name = "\u{1}_ZN2JS25ContainsSharedArrayBufferEP9JSContext"]
            pub fn ContainsSharedArrayBuffer(cx: *mut root::JSContext) -> bool;
            /** Return the isShared flag of a ArrayBufferView subtypes, which denotes whether
 the underlying buffer is a SharedArrayBuffer.

 |obj| must have passed a JS_IsArrayBufferViewObject test, or somehow
 be known that it would pass such a test: it is a ArrayBufferView subtypes or
 a wrapper of a ArrayBufferView subtypes, and the unwrapping will succeed.*/
            #[link_name = "\u{1}_ZN2JS23IsArrayBufferViewSharedEP8JSObject"]
            pub fn IsArrayBufferViewShared(obj: *mut root::JSObject) -> bool;
            /** Returns a new instance of the ReadableStream builtin class in the current
 compartment, configured as a default stream.
 If a |proto| is passed, that gets set as the instance's [[Prototype]]
 instead of the original value of |ReadableStream.prototype|.*/
            #[link_name = "\u{1}_ZN2JS30NewReadableDefaultStreamObjectEP9JSContextNS_6HandleIP8JSObjectEENS2_IP10JSFunctionEEdS5_"]
            pub fn NewReadableDefaultStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: root::JS::HandleObject,
                size: root::JS::HandleFunction,
                highWaterMark: f64,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns a new instance of the ReadableStream builtin class in the current
 compartment.

 The instance is a byte stream backed by an embedding-provided underlying
 source, using the virtual methods of `underlyingSource` as callbacks. The
 embedding must ensure that `*underlyingSource` lives as long as the new
 stream object. The JS engine will call the finalize() method when the stream
 object is destroyed.

 `nsISupportsObject_alreadyAddreffed` is an optional pointer that can be used
 to make the new stream participate in Gecko's cycle collection. Here are the
 rules for using this parameter properly:

 -   `*underlyingSource` must not be a cycle-collected object. (It would lead
     to memory leaks as the cycle collector would not be able to collect
     cycles containing that object.)

 -   `*underlyingSource` must not contain nsCOMPtrs that point to cycle-
     collected objects. (Same reason.)

 -   `*underlyingSource` may contain a pointer to a single cycle-collected
     object.

 -   The pointer may be stored in `*underlyingSource` as a raw pointer.

 -   The pointer to the nsISupports interface of the same object must be
     passed as the `nsISupportsObject_alreadyAddreffed` parameter to this
     function. (This is how the cycle collector knows about it, so omitting
     this would again cause leaks.)

 If `proto` is non-null, it is used as the instance's [[Prototype]] instead
 of the original value of `ReadableStream.prototype`.*/
            #[link_name = "\u{1}_ZN2JS37NewReadableExternalSourceStreamObjectEP9JSContextPNS_30ReadableStreamUnderlyingSourceEPvNS_6HandleIP8JSObjectEE"]
            pub fn NewReadableExternalSourceStreamObject(
                cx: *mut root::JSContext,
                underlyingSource: *mut root::JS::ReadableStreamUnderlyingSource,
                nsISupportsObject_alreadyAddreffed: *mut ::std::os::raw::c_void,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns the embedding-provided underlying source of the given |stream|.

 Can be used to optimize operations if both the underlying source and the
 intended sink are embedding-provided. In that case it might be
 preferrable to pipe data directly from source to sink without interacting
 with the stream at all.

 Locks the stream until ReadableStreamReleaseExternalUnderlyingSource is
 called.

 Throws an exception if the stream is locked, i.e. if a reader has been
 acquired for the stream, or if ReadableStreamGetExternalUnderlyingSource
 has been used previously without releasing the external source again.

 Throws an exception if the stream isn't readable, i.e if it is errored or
 closed. This is different from ReadableStreamGetReader because we don't
 have a Promise to resolve/reject, which a reader provides.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.

 Asserts that the stream has an embedding-provided underlying source.*/
            #[link_name = "\u{1}_ZN2JS41ReadableStreamGetExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEEPPNS_30ReadableStreamUnderlyingSourceE"]
            pub fn ReadableStreamGetExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                source: *mut *mut root::JS::ReadableStreamUnderlyingSource,
            ) -> bool;
            /** Releases the embedding-provided underlying source of the given |stream|,
 returning the stream into an unlocked state.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.

 Checks if the stream was locked through
 ReadableStreamGetExternalUnderlyingSource and throws an error if not.

 Checks if the stream has an embedding-provided underlying source and
 throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS45ReadableStreamReleaseExternalUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReleaseExternalUnderlyingSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
            /** Update the amount of data available at the underlying source of the given
 |stream|.

 Can only be used for streams with an embedding-provided underlying source.
 The JS engine will use the given value to satisfy read requests for the
 stream by invoking the writeIntoReadRequestBuffer method.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS43ReadableStreamUpdateDataAvailableFromSourceEP9JSContextNS_6HandleIP8JSObjectEEj"]
            pub fn ReadableStreamUpdateDataAvailableFromSource(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                availableData: u32,
            ) -> bool;
            /** Break the cycle between this object and the
 nsISupportsObject_alreadyAddreffed passed in
 NewReadableExternalSourceStreamObject().*/
            #[link_name = "\u{1}_ZN2JS29ReadableStreamReleaseCCObjectEP8JSObject"]
            pub fn ReadableStreamReleaseCCObject(stream: *mut root::JSObject);
            /** Returns true if the given object is a ReadableStream object or an
 unwrappable wrapper for one, false otherwise.*/
            #[link_name = "\u{1}_ZN2JS16IsReadableStreamEP8JSObject"]
            pub fn IsReadableStream(obj: *mut root::JSObject) -> bool;
            /** Returns true if the given object is a ReadableStreamBYOBReader object
 or an unwrappable wrapper for one, false otherwise.*/
            #[link_name = "\u{1}_ZN2JS26IsReadableStreamBYOBReaderEP8JSObject"]
            pub fn IsReadableStreamBYOBReader(obj: *mut root::JSObject) -> bool;
            /** Returns true if the given object is a ReadableStreamDefaultReader or
 ReadableStreamBYOBReader object or an unwrappable wrapper for one, false
 otherwise.*/
            #[link_name = "\u{1}_ZN2JS22IsReadableStreamReaderEP8JSObject"]
            pub fn IsReadableStreamReader(obj: *mut root::JSObject) -> bool;
            /** Returns true if the given object is a ReadableStreamDefaultReader object
 or an unwrappable wrapper for one, false otherwise.*/
            #[link_name = "\u{1}_ZN2JS29IsReadableStreamDefaultReaderEP8JSObject"]
            pub fn IsReadableStreamDefaultReader(obj: *mut root::JSObject) -> bool;
            /** Returns true if the given object is a ReadableStreamDefaultController or
 ReadableByteStreamController object or an unwrappable wrapper for one,
 false otherwise.*/
            #[link_name = "\u{1}_ZN2JS26IsReadableStreamControllerEP8JSObject"]
            pub fn IsReadableStreamController(obj: *mut root::JSObject) -> bool;
            /** Returns the stream's ReadableStreamMode. If the mode is |Byte| or
 |ExternalSource|, it's possible to acquire a BYOB reader for more optimized
 operations.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS21ReadableStreamGetModeEP9JSContextNS_6HandleIP8JSObjectEEPNS_18ReadableStreamModeE"]
            pub fn ReadableStreamGetMode(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: *mut root::JS::ReadableStreamMode,
            ) -> bool;
            /** Returns the stream's stored error.

 Asserts that |stream| is a ReadableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS28ReadableStreamGetStoredErrorEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamGetStoredError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> root::JS::Value;
            /** Returns true if the given ReadableStream is readable, false if not.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS24ReadableStreamIsReadableEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsReadable(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
            /** Returns true if the given ReadableStream is locked, false if not.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS22ReadableStreamIsLockedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsLocked(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
            /** Returns true if the given ReadableStream is disturbed, false if not.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS25ReadableStreamIsDisturbedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsDisturbed(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
            /** Returns true if the given ReadableStream is errored, false if not.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS23ReadableStreamIsErroredEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamIsErrored(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
            /** Cancels the given ReadableStream with the given reason and returns a
 Promise resolved according to the result.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS20ReadableStreamCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamCancel(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> *mut root::JSObject;
            /** Creates a reader of the type specified by the mode option and locks the
 stream to the new reader.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not. The returned object will always be
 created in the current cx compartment.*/
            #[link_name = "\u{1}_ZN2JS23ReadableStreamGetReaderEP9JSContextNS_6HandleIP8JSObjectEENS_24ReadableStreamReaderModeE"]
            pub fn ReadableStreamGetReader(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                mode: root::JS::ReadableStreamReaderMode,
            ) -> *mut root::JSObject;
            /** Returns the controller associated with the given ReadableStream.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS27ReadableStreamGetControllerEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamGetController(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns the underlying source associated with the given
 ReadableStreamController.

 Checks if |controller| is a ReadableStreamController object or an
 unwrappable wrapper for one and throws an error if not. The returned
 object will always be created in the current cx compartment.

 Note: this is different from ReadableStreamGetExternalUnderlyingSource in
 that it only works for ReadableStreams with a mode of Default or Byte,
 returns a Value, and doesn't lock the stream.*/
            #[link_name = "\u{1}_ZN2JS43ReadableStreamControllerGetUnderlyingSourceEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn ReadableStreamControllerGetUnderlyingSource(
                cx: *mut root::JSContext,
                controller: root::JS::HandleObject,
                source: root::JS::MutableHandleValue,
            ) -> bool;
            /** Results in true if the stream associated with the given controller
 is readable, and the closeRequested flag on the controller is false,
 and throws an error and returns false if not.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS46CheckReadableStreamControllerCanCloseOrEnqueueEP9JSContextNS_6HandleIP8JSObjectEEPKc"]
            pub fn CheckReadableStreamControllerCanCloseOrEnqueue(
                cx: *mut root::JSContext,
                controller: root::JS::HandleObject,
                action: *const ::std::os::raw::c_char,
            ) -> bool;
            /** The WHATWG Streams spec algorithm ReadableStreamControllerShouldCallPull.

 Asserts that |controller| is a ReadableStreamController object or an
 unwrappable wrapper for one.*/
            #[link_name = "\u{1}_ZN2JS38ReadableStreamControllerShouldCallPullEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamControllerShouldCallPull(
                cx: *mut root::JSContext,
                controller: root::JS::HandleObject,
            ) -> bool;
            /** Tees the given ReadableStream and stores the two resulting streams in
 outparams. Returns false if the operation fails, e.g. because the stream is
 locked.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not. The returned objects will always be
 created in the current cx compartment.*/
            #[link_name = "\u{1}_ZN2JS17ReadableStreamTeeEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleIS4_EES7_"]
            pub fn ReadableStreamTee(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                branch1Stream: root::JS::MutableHandleObject,
                branch2Stream: root::JS::MutableHandleObject,
            ) -> bool;
            /** Retrieves the desired combined size of additional chunks to fill the given
 ReadableStream's queue. Stores the result in |value| and sets |hasValue| to
 true on success, returns false on failure.

 If the stream is errored, the call will succeed but no value will be stored
 in |value| and |hasValue| will be set to false.

 Note: This is semantically equivalent to the |desiredSize| getter on
 the stream controller's prototype in JS. We expose it with the stream
 itself as a target for simplicity.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS28ReadableStreamGetDesiredSizeEP9JSContextP8JSObjectPbPd"]
            pub fn ReadableStreamGetDesiredSize(
                cx: *mut root::JSContext,
                stream: *mut root::JSObject,
                hasValue: *mut bool,
                value: *mut f64,
            ) -> bool;
            /** Close the given ReadableStream. This is equivalent to `controller.close()`
 in JS.

 This can fail with or without an exception pending under a variety of
 circumstances. On failure, the stream may or may not be closed, and
 downstream consumers may or may not have been notified.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS19ReadableStreamCloseEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamClose(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
            /** Returns true if the given ReadableStream reader is closed, false otherwise.

 checks |reader| is a ReadableStreamDefaultReader or
 ReadableStreamBYOBReader object or an unwrappable wrapper for one and
 throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS28ReadableStreamReaderIsClosedEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn ReadableStreamReaderIsClosed(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                result: *mut bool,
            ) -> bool;
            /** Enqueues the given chunk in the given ReadableStream.

 Throws a TypeError and returns false if the enqueing operation fails.

 Note: This is semantically equivalent to the |enqueue| method on
 the stream controller's prototype in JS. We expose it with the stream
 itself as a target for simplicity.

 If the ReadableStream has an underlying byte source, the given chunk must
 be a typed array or a DataView. Consider using
 ReadableByteStreamEnqueueBuffer.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS21ReadableStreamEnqueueEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamEnqueue(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                chunk: root::JS::HandleValue,
            ) -> bool;
            /** Errors the given ReadableStream, causing all future interactions to fail
 with the given error value.

 Throws a TypeError and returns false if the erroring operation fails.

 Note: This is semantically equivalent to the |error| method on
 the stream controller's prototype in JS. We expose it with the stream
 itself as a target for simplicity.

 Checks if |stream| is a ReadableStream object or an unwrappable wrapper
 for one and throws an error if not.*/
            #[link_name = "\u{1}_ZN2JS19ReadableStreamErrorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                error: root::JS::HandleValue,
            ) -> bool;
            /** C++ equivalent of `reader.cancel(reason)`
 (both <https://streams.spec.whatwg.org/#default-reader-cancel> and
 <https://streams.spec.whatwg.org/#byob-reader-cancel>).

 `reader` must be a stream reader created using `JS::ReadableStreamGetReader`
 or an unwrappable wrapper for one. (This function is meant to support using
 C++ to read from streams. It's not meant to allow C++ code to operate on
 readers created by scripts.)*/
            #[link_name = "\u{1}_ZN2JS26ReadableStreamReaderCancelEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn ReadableStreamReaderCancel(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                reason: root::JS::HandleValue,
            ) -> bool;
            /** C++ equivalent of `reader.releaseLock()`
 (both <https://streams.spec.whatwg.org/#default-reader-release-lock> and
 <https://streams.spec.whatwg.org/#byob-reader-release-lock>).

 `reader` must be a stream reader created using `JS::ReadableStreamGetReader`
 or an unwrappable wrapper for one.*/
            #[link_name = "\u{1}_ZN2JS31ReadableStreamReaderReleaseLockEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamReaderReleaseLock(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> bool;
            /** C++ equivalent of the `reader.read()` method on byob readers
 (<https://streams.spec.whatwg.org/#default-reader-read>).

 The result is a new Promise object, or null on OOM.

 `reader` must be the result of calling `JS::ReadableStreamGetReader` with
 `ReadableStreamReaderMode::Default` mode, or an unwrappable wrapper for such
 a reader.*/
            #[link_name = "\u{1}_ZN2JS28ReadableStreamBYOBReaderReadEP9JSContextNS_6HandleIP8JSObjectEES5_"]
            pub fn ReadableStreamBYOBReaderRead(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
                view: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** C++ equivalent of the `reader.read()` method on default readers
 (<https://streams.spec.whatwg.org/#default-reader-read>).

 The result is a new Promise object, or null on OOM.

 `reader` must be the result of calling `JS::ReadableStreamGetReader` with
 `ReadableStreamReaderMode::Default` mode, or an unwrappable wrapper for such
 a reader.*/
            #[link_name = "\u{1}_ZN2JS31ReadableStreamDefaultReaderReadEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ReadableStreamDefaultReaderRead(
                cx: *mut root::JSContext,
                reader: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns a new instance of the WritableStream builtin class in the current
 compartment, configured as a default stream.
 If a |proto| is passed, that gets set as the instance's [[Prototype]]
 instead of the original value of |WritableStream.prototype|.*/
            #[link_name = "\u{1}_ZN2JS30NewWritableDefaultStreamObjectEP9JSContextNS_6HandleIP8JSObjectEENS2_IP10JSFunctionEEdS5_"]
            pub fn NewWritableDefaultStreamObject(
                cx: *mut root::JSContext,
                underlyingSink: root::JS::HandleObject,
                size: root::JS::HandleFunction,
                highWaterMark: f64,
                proto: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns true if the given object is a WritableStream object or an
 unwrappable wrapper for one, false otherwise.*/
            #[link_name = "\u{1}_ZN2JS16IsWritableStreamEP8JSObject"]
            pub fn IsWritableStream(obj: *mut root::JSObject) -> bool;
            /** Returns the given WritableStream's state.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS22WritableStreamGetStateEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamGetState(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> root::JS::WritableStreamState;
            /** Returns true if the given WritableStream is locked, false if not.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS22WritableStreamIsLockedEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamIsLocked(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> bool;
            /** Returns true if the given object is a WritableStreamDefaultWriter or
 WritableStreamBYOBWriter object or an unwrappable wrapper for one, false
 otherwise.*/
            #[link_name = "\u{1}_ZN2JS22IsWritableStreamWriterEP8JSObject"]
            pub fn IsWritableStreamWriter(obj: *mut root::JSObject) -> bool;
            /** Creates a WritableStreamDefaultWriter and locks the stream to the new
 writer.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one. The returned object will always be created in the
 current cx compartment.*/
            #[link_name = "\u{1}_ZN2JS23WritableStreamGetWriterEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamGetWriter(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns the controller associated with the given WritableStream.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS27WritableStreamGetControllerEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamGetController(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** Returns the underlying sink associated with the given
 WritableStreamDefaultController.

 Asserts that |controller| is a WritableStreamDefaultController object or an
 unwrappable wrapper for one.*/
            #[link_name = "\u{1}_ZN2JS41WritableStreamControllerGetUnderlyingSinkEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamControllerGetUnderlyingSink(
                cx: *mut root::JSContext,
                controller: root::JS::HandleObject,
            ) -> root::JS::Value;
            /** Errors the given WritableStream, causing all future interactions to fail
 with the given error value.

 Throws a TypeError and returns false if the erroring operation fails.

 Note: This is semantically equivalent to the |error| method on
 the stream controller's prototype in JS. We expose it with the stream
 itself as a target for simplicity.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS19WritableStreamErrorEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn WritableStreamError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
                error: root::JS::HandleValue,
            ) -> bool;
            /** Returns the stream's stored error.

 Asserts that |stream| is a WritableStream object or an unwrappable wrapper
 for one.*/
            #[link_name = "\u{1}_ZN2JS28WritableStreamGetStoredErrorEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn WritableStreamGetStoredError(
                cx: *mut root::JSContext,
                stream: root::JS::HandleObject,
            ) -> root::JS::Value;
            /** Dictate embedder-specific details necessary to implement certain aspects of
 the |ReadableStream.prototype.pipeTo| function.  This should be performed
 exactly once, for a single context associated with a |JSRuntime|.

 The |ReadableStream.prototype.pipeTo| function accepts a |signal| argument
 that may be used to abort the piping operation.  This argument must be either
 |undefined| (in other words, the piping operation can't be aborted) or an
 |AbortSignal| instance (that may be aborted using the signal's associated
 |AbortController|).  |AbortSignal| is defined by WebIDL and the DOM in the
 web embedding.  Therefore, embedders must use this function to specify how
 such objects can be recognized and how to perform various essential actions
 upon them.

 The provided |isAborted| function will be called with an unwrapped
 |AbortSignal| instance, while that instance's realm has been entered.

 If this function isn't called, and a situation arises where an "is this an
 |AbortSignal|?" question must be asked, that question will simply be answered
 "no".*/
            #[link_name = "\u{1}_ZN2JS18InitPipeToHandlingEPK7JSClassPFbP8JSObjectEP9JSContext"]
            pub fn InitPipeToHandling(
                abortSignalClass: *const root::JSClass,
                isAborted: root::JS::AbortSignalIsAborted,
                cx: *mut root::JSContext,
            );
            /** Report a warning represented by the sprintf-like conversion of ASCII format
 filled from trailing ASCII arguments.

 Return true iff the warning was successfully reported without reporting an
 error (or being upgraded into one).*/
            #[link_name = "\u{1}_ZN2JS9WarnASCIIEP9JSContextPKcz"]
            pub fn WarnASCII(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
            /** Report a warning represented by the sprintf-like conversion of Latin-1 format
 filled from trailing Latin-1 arguments.

 Return true iff the warning was successfully reported without reporting an
 error (or being upgraded into one).*/
            #[link_name = "\u{1}_ZN2JS10WarnLatin1EP9JSContextPKcz"]
            pub fn WarnLatin1(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
            /** Report a warning represented by the sprintf-like conversion of UTF-8 format
 filled from trailing UTF-8 arguments.

 Return true iff the warning was successfully reported without reporting an
 error (or being upgraded into one).*/
            #[link_name = "\u{1}_ZN2JS8WarnUTF8EP9JSContextPKcz"]
            pub fn WarnUTF8(
                cx: *mut root::JSContext,
                format: *const ::std::os::raw::c_char,
                ...
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS18GetWarningReporterEP9JSContext"]
            pub fn GetWarningReporter(
                cx: *mut root::JSContext,
            ) -> root::JS::WarningReporter;
            #[link_name = "\u{1}_ZN2JS18SetWarningReporterEP9JSContextPFvS1_P13JSErrorReportE"]
            pub fn SetWarningReporter(
                cx: *mut root::JSContext,
                reporter: root::JS::WarningReporter,
            ) -> root::JS::WarningReporter;
            #[link_name = "\u{1}_ZN2JS18IsWasmModuleObjectENS_6HandleIP8JSObjectEE"]
            pub fn IsWasmModuleObject(obj: root::JS::HandleObject) -> bool;
            #[link_name = "\u{1}_ZN2JS13GetWasmModuleENS_6HandleIP8JSObjectEE"]
            pub fn GetWasmModule(
                obj: root::JS::HandleObject,
            ) -> root::RefPtr<root::JS::WasmModule>;
            #[link_name = "\u{1}_ZN2JS25FinishIncrementalEncodingEP9JSContextNS_6HandleIP8JSScriptEERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn FinishIncrementalEncoding(
                cx: *mut root::JSContext,
                script: root::JS::Handle<*mut root::JSScript>,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS25FinishIncrementalEncodingEP9JSContextNS_6HandleIP8JSObjectEERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn FinishIncrementalEncoding1(
                cx: *mut root::JSContext,
                module: root::JS::Handle<*mut root::JSObject>,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS24AbortIncrementalEncodingENS_6HandleIP8JSScriptEE"]
            pub fn AbortIncrementalEncoding(
                script: root::JS::Handle<*mut root::JSScript>,
            );
            #[link_name = "\u{1}_ZN2JS24AbortIncrementalEncodingENS_6HandleIP8JSObjectEE"]
            pub fn AbortIncrementalEncoding1(
                module: root::JS::Handle<*mut root::JSObject>,
            );
            #[link_name = "\u{1}_ZN2JS24CheckCompileOptionsMatchERKNS_22ReadOnlyCompileOptionsEP8JSScript"]
            pub fn CheckCompileOptionsMatch(
                options: *const root::JS::ReadOnlyCompileOptions,
                script: *mut root::JSScript,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS20InstantiationStorageD1Ev"]
            pub fn InstantiationStorage_InstantiationStorage_destructor(
                this: *mut root::JS::InstantiationStorage,
            );
            #[link_name = "\u{1}_ZN2JS13StencilAddRefEPN2js8frontend18CompilationStencilE"]
            pub fn StencilAddRef(stencil: *mut root::JS::Stencil);
            #[link_name = "\u{1}_ZN2JS14StencilReleaseEPN2js8frontend18CompilationStencilE"]
            pub fn StencilRelease(stencil: *mut root::JS::Stencil);
            #[link_name = "\u{1}_ZN2JS17StencilIsBorrowedEPN2js8frontend18CompilationStencilE"]
            pub fn StencilIsBorrowed(stencil: *mut root::JS::Stencil) -> bool;
            #[link_name = "\u{1}_ZN2JS13SizeOfStencilEPN2js8frontend18CompilationStencilEPFmPKvE"]
            pub fn SizeOfStencil(
                stencil: *mut root::JS::Stencil,
                mallocSizeOf: root::mozilla::MallocSizeOf,
            ) -> usize;
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileGlobalScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
            #[link_name = "\u{1}_ZN2JS28CompileGlobalScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileGlobalScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIN7mozilla8Utf8UnitEEE"]
            pub fn CompileModuleScriptToStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<root::mozilla::Utf8Unit>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
            #[link_name = "\u{1}_ZN2JS28CompileModuleScriptToStencilEP9JSContextRKNS_22ReadOnlyCompileOptionsERNS_10SourceTextIDsEE"]
            pub fn CompileModuleScriptToStencil1(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyCompileOptions,
                srcBuf: *mut root::JS::SourceText<u16>,
            ) -> root::already_AddRefed<root::JS::Stencil>;
            #[link_name = "\u{1}_ZN2JS24InstantiateGlobalStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend18CompilationStencilEPNS_20InstantiationStorageE"]
            pub fn InstantiateGlobalStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSScript;
            #[link_name = "\u{1}_ZN2JS24InstantiateModuleStencilEP9JSContextRKNS_18InstantiateOptionsEPN2js8frontend18CompilationStencilEPNS_20InstantiationStorageE"]
            pub fn InstantiateModuleStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::InstantiateOptions,
                stencil: *mut root::JS::Stencil,
                storage: *mut root::JS::InstantiationStorage,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS13EncodeStencilEP9JSContextPN2js8frontend18CompilationStencilERN7mozilla6VectorIhLm0ENS6_17MallocAllocPolicyEEE"]
            pub fn EncodeStencil(
                cx: *mut root::JSContext,
                stencil: *mut root::JS::Stencil,
                buffer: *mut root::JS::TranscodeBuffer,
            ) -> root::JS::TranscodeResult;
            #[link_name = "\u{1}_ZN2JS13DecodeStencilEP9JSContextRKNS_21ReadOnlyDecodeOptionsERKN7mozilla5RangeIKhEEPPN2js8frontend18CompilationStencilE"]
            pub fn DecodeStencil(
                cx: *mut root::JSContext,
                options: *const root::JS::ReadOnlyDecodeOptions,
                range: *const root::JS::TranscodeRange,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> root::JS::TranscodeResult;
            #[link_name = "\u{1}_ZN2JS13DecodeStencilEPN2js15FrontendContextERKNS_21ReadOnlyDecodeOptionsERKN7mozilla5RangeIKhEEPPNS0_8frontend18CompilationStencilE"]
            pub fn DecodeStencil1(
                fc: *mut root::JS::FrontendContext,
                options: *const root::JS::ReadOnlyDecodeOptions,
                range: *const root::JS::TranscodeRange,
                stencilOut: *mut *mut root::JS::Stencil,
            ) -> root::JS::TranscodeResult;
            #[link_name = "\u{1}_ZN2JS24StartIncrementalEncodingEP9JSContextO6RefPtrIN2js8frontend18CompilationStencilEE"]
            pub fn StartIncrementalEncoding(
                cx: *mut root::JSContext,
                stencil: *mut root::RefPtr<root::JS::Stencil>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS22IsLargeArrayBufferViewEP8JSObject"]
            pub fn IsLargeArrayBufferView(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS26IsResizableArrayBufferViewEP8JSObject"]
            pub fn IsResizableArrayBufferView(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS26PinArrayBufferOrViewLengthEP8JSObjectb"]
            pub fn PinArrayBufferOrViewLength(
                obj: *mut root::JSObject,
                pin: bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS32EnsureNonInlineArrayBufferOrViewEP9JSContextP8JSObject"]
            pub fn EnsureNonInlineArrayBufferOrView(
                cx: *mut root::JSContext,
                obj: *mut root::JSObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS17ArrayBufferOrView6unwrapEP8JSObject"]
            pub fn ArrayBufferOrView_unwrap(
                maybeWrapped: *mut root::JSObject,
            ) -> root::JS::ArrayBufferOrView;
            #[link_name = "\u{1}_ZNK2JS17ArrayBufferOrView10isDetachedEv"]
            pub fn ArrayBufferOrView_isDetached(
                this: *const root::JS::ArrayBufferOrView,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2JS17ArrayBufferOrView11isResizableEv"]
            pub fn ArrayBufferOrView_isResizable(
                this: *const root::JS::ArrayBufferOrView,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer24FixedLengthUnsharedClassE"]
            pub static ArrayBuffer_FixedLengthUnsharedClass: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer22ResizableUnsharedClassE"]
            pub static ArrayBuffer_ResizableUnsharedClass: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer22FixedLengthSharedClassE"]
            pub static ArrayBuffer_FixedLengthSharedClass: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer19GrowableSharedClassE"]
            pub static ArrayBuffer_GrowableSharedClass: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer6unwrapEP8JSObject"]
            pub fn ArrayBuffer_unwrap(
                maybeWrapped: *mut root::JSObject,
            ) -> root::JS::ArrayBuffer;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer6createEP9JSContextm"]
            pub fn ArrayBuffer_create(
                cx: *mut root::JSContext,
                nbytes: usize,
            ) -> root::JS::ArrayBuffer;
            #[link_name = "\u{1}_ZN2JS11ArrayBuffer7getDataEPbRKNS_15AutoRequireNoGCE"]
            pub fn ArrayBuffer_getData(
                this: *mut root::JS::ArrayBuffer,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> [u32; 2usize];
            #[link_name = "\u{1}_ZNK2JS15ArrayBufferView10isDetachedEv"]
            pub fn ArrayBufferView_isDetached(
                this: *const root::JS::ArrayBufferView,
            ) -> bool;
            #[link_name = "\u{1}_ZNK2JS15ArrayBufferView11isResizableEv"]
            pub fn ArrayBufferView_isResizable(
                this: *const root::JS::ArrayBufferView,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS15ArrayBufferView7getDataEPbRKNS_15AutoRequireNoGCE"]
            pub fn ArrayBufferView_getData(
                this: *mut root::JS::ArrayBufferView,
                isSharedMemory: *mut bool,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> [u32; 2usize];
            #[link_name = "\u{1}_ZN2JS15ArrayBufferView13getByteLengthERKNS_15AutoRequireNoGCE"]
            pub fn ArrayBufferView_getByteLength(
                this: *mut root::JS::ArrayBufferView,
                arg1: *const root::JS::AutoRequireNoGC,
            ) -> usize;
            #[link_name = "\u{1}_ZN2JS8DataView19FixedLengthClassPtrE"]
            pub static DataView_FixedLengthClassPtr: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS8DataView17ResizableClassPtrE"]
            pub static DataView_ResizableClassPtr: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS15TypedArray_base18fixedLengthClassesE"]
            pub static TypedArray_base_fixedLengthClasses: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS15TypedArray_base16resizableClassesE"]
            pub static TypedArray_base_resizableClasses: *const root::JSClass;
            #[link_name = "\u{1}_ZN2JS15TypedArray_base10fromObjectEP8JSObject"]
            pub fn TypedArray_base_fromObject(
                unwrapped: *mut root::JSObject,
            ) -> root::JS::TypedArray_base;
            #[link_name = "\u{1}Scalar"]
            pub static TypedArray_Scalar: root::JS::Scalar::Type;
            #[link_name = "\u{1}create"]
            pub fn TypedArray_create(cx: *mut root::JSContext, nelements: usize) -> u8;
            #[link_name = "\u{1}fromArray"]
            pub fn TypedArray_fromArray(
                cx: *mut root::JSContext,
                other: root::JS::HandleObject,
            ) -> u8;
            #[link_name = "\u{1}fromBuffer"]
            pub fn TypedArray_fromBuffer(
                cx: *mut root::JSContext,
                arrayBuffer: root::JS::HandleObject,
                byteOffset: usize,
                length: i64,
            ) -> u8;
            #[link_name = "\u{1}getData"]
            pub fn TypedArray_getData(
                this: *mut u8,
                isSharedMemory: *mut bool,
                nogc: *const root::JS::AutoRequireNoGC,
            ) -> u8;
            #[link_name = "\u{1}_ZN2JS22SetDOMProxyInformationEPKvPFNS_21DOMProxyShadowsResultEP9JSContextNS_6HandleIP8JSObjectEENS5_INS_11PropertyKeyEEEES1_"]
            pub fn SetDOMProxyInformation(
                domProxyHandlerFamily: *const ::std::os::raw::c_void,
                domProxyShadowsCheck: root::JS::DOMProxyShadowsCheck,
                domRemoteProxyHandlerFamily: *const ::std::os::raw::c_void,
            );
            /** Return true if the given object is callable. In ES6 terms, an object is
 callable if it has a [[Call]] internal method.

 Implements: ES6 7.2.3 IsCallable(argument).

 Functions are callable. A scripted proxy or wrapper is callable if its
 target is callable. Most other objects aren't callable.*/
            #[link_name = "\u{1}_ZN2JS10IsCallableEP8JSObject"]
            pub fn IsCallable(obj: *mut root::JSObject) -> bool;
            /** Return true if the given object is a constructor. In ES6 terms, an object is
 a constructor if it has a [[Construct]] internal method. The expression
 `new obj()` throws a TypeError if obj is not a constructor.

 Implements: ES6 7.2.4 IsConstructor(argument).

 JS functions and classes are constructors. Arrow functions and most builtin
 functions are not. A scripted proxy or wrapper is a constructor if its
 target is a constructor.*/
            #[link_name = "\u{1}_ZN2JS13IsConstructorEP8JSObject"]
            pub fn IsConstructor(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JSL4CallEP9JSContextNS_6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS_16HandleValueArrayENS_13MutableHandleINS_5ValueEEE"]
            pub fn Call(
                cx: *mut root::JSContext,
                thisObj: root::JS::Handle<*mut root::JSObject>,
                fun: root::JS::Handle<*mut root::JSFunction>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL4CallEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
            pub fn Call1(
                cx: *mut root::JSContext,
                thisObj: root::JS::Handle<*mut root::JSObject>,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL4CallEP9JSContextNS_6HandleIP8JSObjectEEPKcRKNS_16HandleValueArrayENS_13MutableHandleINS_5ValueEEE"]
            pub fn Call2(
                cx: *mut root::JSContext,
                thisObj: root::JS::Handle<*mut root::JSObject>,
                name: *const ::std::os::raw::c_char,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS4CallEP9JSContextNS_6HandleINS_5ValueEEES4_RKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
            pub fn Call3(
                cx: *mut root::JSContext,
                thisv: root::JS::Handle<root::JS::Value>,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL4CallEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS3_EE"]
            pub fn Call4(
                cx: *mut root::JSContext,
                thisv: root::JS::Handle<root::JS::Value>,
                funObj: root::JS::Handle<*mut root::JSObject>,
                args: *const root::JS::HandleValueArray,
                rval: root::JS::MutableHandle<root::JS::Value>,
            ) -> bool;
            /** Invoke a constructor. This is the C++ equivalent of
 `rval = Reflect.construct(fun, args, newTarget)`.

 Construct() takes a `newTarget` argument that most callers don't need.
 Consider using the four-argument Construct signature instead. (But if you're
 implementing a subclass or a proxy handler's construct() method, this is the
 right function to call.)

 Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]).
 Use this function to invoke the [[Construct]] internal method.*/
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEENS2_IP8JSObjectEERKNS_16HandleValueArrayENS_13MutableHandleIS6_EE"]
            pub fn Construct(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                newTarget: root::JS::Handle<*mut root::JSObject>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
            /** Invoke a constructor. This is the C++ equivalent of
 `rval = new fun(...args)`.

 Implements: ES6 7.3.13 Construct(F, [argumentsList], [newTarget]), when
 newTarget is omitted.*/
            #[link_name = "\u{1}_ZN2JS9ConstructEP9JSContextNS_6HandleINS_5ValueEEERKNS_16HandleValueArrayENS_13MutableHandleIP8JSObjectEE"]
            pub fn Construct1(
                cx: *mut root::JSContext,
                fun: root::JS::Handle<root::JS::Value>,
                args: *const root::JS::HandleValueArray,
                objp: root::JS::MutableHandle<*mut root::JSObject>,
            ) -> bool;
            /** Asserts (in debug and release builds) that `obj` belongs to the current
 thread's context.*/
            #[link_name = "\u{1}_ZN2JS34AssertObjectBelongsToCurrentThreadEP8JSObject"]
            pub fn AssertObjectBelongsToCurrentThread(obj: *mut root::JSObject);
            #[link_name = "\u{1}_ZN2JS29SetFilenameValidationCallbackEPFbP9JSContextPKcE"]
            pub fn SetFilenameValidationCallback(
                cb: root::JS::FilenameValidationCallback,
            );
            #[link_name = "\u{1}_ZN2JS37SetHostEnsureCanAddPrivateElementHookEP9JSContextPFbS1_NS_6HandleINS_5ValueEEEE"]
            pub fn SetHostEnsureCanAddPrivateElementHook(
                cx: *mut root::JSContext,
                op: root::JS::EnsureCanAddPrivateElementOp,
            );
            /** Transition the cx to a mode where failures that would normally cause a false
 return value will instead crash with a diagnostic assertion.

 Return value: the former brittle mode setting.*/
            #[link_name = "\u{1}_ZN2JS14SetBrittleModeEP9JSContextb"]
            pub fn SetBrittleMode(cx: *mut root::JSContext, setting: bool) -> bool;
            #[link_name = "\u{1}_ZN2JS10TimeBudget18setDeadlineFromNowEv"]
            pub fn TimeBudget_setDeadlineFromNow(this: *mut root::JS::TimeBudget);
            #[link_name = "\u{1}_ZNK2JS11SliceBudget8describeEPcm"]
            pub fn SliceBudget_describe(
                this: *const root::JS::SliceBudget,
                buffer: *mut ::std::os::raw::c_char,
                maxlen: usize,
            ) -> ::std::os::raw::c_int;
            #[link_name = "\u{1}_ZN2JS11SliceBudgetC1ENS_10TimeBudgetEPN7mozilla6AtomicIbLNS2_14MemoryOrderingE0EvEE"]
            pub fn SliceBudget_SliceBudget(
                this: *mut root::JS::SliceBudget,
                time: root::JS::TimeBudget,
                interrupt: *mut root::JS::SliceBudget_InterruptRequestFlag,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS11SliceBudgetC1ENS_10WorkBudgetE"]
            pub fn SliceBudget_SliceBudget1(
                this: *mut root::JS::SliceBudget,
                work: root::JS::WorkBudget,
            ) -> *mut ::std::os::raw::c_void;
            /// Get a statically allocated C string explaining the given GC reason.
            #[link_name = "\u{1}_ZN2JS15ExplainGCReasonENS_8GCReasonE"]
            pub fn ExplainGCReason(
                reason: root::JS::GCReason,
            ) -> *const ::std::os::raw::c_char;
            /// Return true if the GC reason is internal to the JS engine.
            #[link_name = "\u{1}_ZN2JS16InternalGCReasonENS_8GCReasonE"]
            pub fn InternalGCReason(reason: root::JS::GCReason) -> bool;
            /// Schedule the given zone to be collected as part of the next GC.
            #[link_name = "\u{1}_ZN2JS16PrepareZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn PrepareZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
            /// Schedule all zones to be collected in the next GC.
            #[link_name = "\u{1}_ZN2JS16PrepareForFullGCEP9JSContext"]
            pub fn PrepareForFullGC(cx: *mut root::JSContext);
            /** When performing an incremental GC, the zones that were selected for the
 previous incremental slice must be selected in subsequent slices as well.
 This function selects those slices automatically.*/
            #[link_name = "\u{1}_ZN2JS23PrepareForIncrementalGCEP9JSContext"]
            pub fn PrepareForIncrementalGC(cx: *mut root::JSContext);
            /** Returns true if any zone in the system has been scheduled for GC with one of
 the functions above or by the JS engine.*/
            #[link_name = "\u{1}_ZN2JS13IsGCScheduledEP9JSContext"]
            pub fn IsGCScheduled(cx: *mut root::JSContext) -> bool;
            /** Undoes the effect of the Prepare methods above. The given zone will not be
 collected in the next GC.*/
            #[link_name = "\u{1}_ZN2JS13SkipZoneForGCEP9JSContextPNS_4ZoneE"]
            pub fn SkipZoneForGC(cx: *mut root::JSContext, zone: *mut root::JS::Zone);
            /// Performs a non-incremental collection of all selected zones.
            #[link_name = "\u{1}_ZN2JS16NonIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonE"]
            pub fn NonIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
            );
            /** Begin an incremental collection and perform one slice worth of work. When
 this function returns, the collection may not be complete.
 IncrementalGCSlice() must be called repeatedly until
 !IsIncrementalGCInProgress(cx).

 Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
       shorter than the requested interval.*/
            #[link_name = "\u{1}_ZN2JS18StartIncrementalGCEP9JSContextNS_9GCOptionsENS_8GCReasonERKNS_11SliceBudgetE"]
            pub fn StartIncrementalGC(
                cx: *mut root::JSContext,
                options: root::JS::GCOptions,
                reason: root::JS::GCReason,
                budget: *const root::JS::SliceBudget,
            );
            /** Perform a slice of an ongoing incremental collection. When this function
 returns, the collection may not be complete. It must be called repeatedly
 until !IsIncrementalGCInProgress(cx).

 Note: SpiderMonkey's GC is not realtime. Slices in practice may be longer or
       shorter than the requested interval.*/
            #[link_name = "\u{1}_ZN2JS18IncrementalGCSliceEP9JSContextNS_8GCReasonERKNS_11SliceBudgetE"]
            pub fn IncrementalGCSlice(
                cx: *mut root::JSContext,
                reason: root::JS::GCReason,
                budget: *const root::JS::SliceBudget,
            );
            /** Return whether an incremental GC has work to do on the foreground thread and
 would make progress if a slice was run now. If this returns false then the GC
 is waiting for background threads to finish their work and a slice started
 now would return immediately.*/
            #[link_name = "\u{1}_ZN2JS30IncrementalGCHasForegroundWorkEP9JSContext"]
            pub fn IncrementalGCHasForegroundWork(cx: *mut root::JSContext) -> bool;
            /** If IsIncrementalGCInProgress(cx), this call finishes the ongoing collection
 by performing an arbitrarily long slice. If !IsIncrementalGCInProgress(cx),
 this is equivalent to NonIncrementalGC. When this function returns,
 IsIncrementalGCInProgress(cx) will always be false.*/
            #[link_name = "\u{1}_ZN2JS19FinishIncrementalGCEP9JSContextNS_8GCReasonE"]
            pub fn FinishIncrementalGC(
                cx: *mut root::JSContext,
                reason: root::JS::GCReason,
            );
            /** If IsIncrementalGCInProgress(cx), this call aborts the ongoing collection and
 performs whatever work needs to be done to return the collector to its idle
 state. This may take an arbitrarily long time. When this function returns,
 IsIncrementalGCInProgress(cx) will always be false.*/
            #[link_name = "\u{1}_ZN2JS18AbortIncrementalGCEP9JSContext"]
            pub fn AbortIncrementalGC(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZNK2JS13GCDescription18formatSliceMessageEP9JSContext"]
            pub fn GCDescription_formatSliceMessage(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> *mut u16;
            #[link_name = "\u{1}_ZNK2JS13GCDescription20formatSummaryMessageEP9JSContext"]
            pub fn GCDescription_formatSummaryMessage(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> *mut u16;
            #[link_name = "\u{1}_ZNK2JS13GCDescription9startTimeEP9JSContext"]
            pub fn GCDescription_startTime(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp;
            #[link_name = "\u{1}_ZNK2JS13GCDescription7endTimeEP9JSContext"]
            pub fn GCDescription_endTime(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp;
            #[link_name = "\u{1}_ZNK2JS13GCDescription14lastSliceStartEP9JSContext"]
            pub fn GCDescription_lastSliceStart(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp;
            #[link_name = "\u{1}_ZNK2JS13GCDescription12lastSliceEndEP9JSContext"]
            pub fn GCDescription_lastSliceEnd(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::mozilla::TimeStamp;
            #[link_name = "\u{1}_ZNK2JS13GCDescription19sliceToJSONProfilerEP9JSContext"]
            pub fn GCDescription_sliceToJSONProfiler(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::JS::UniqueChars;
            #[link_name = "\u{1}_ZNK2JS13GCDescription18formatJSONProfilerEP9JSContext"]
            pub fn GCDescription_formatJSONProfiler(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::JS::UniqueChars;
            #[link_name = "\u{1}_ZNK2JS13GCDescription9toGCEventEP9JSContext"]
            pub fn GCDescription_toGCEvent(
                this: *const root::JS::GCDescription,
                cx: *mut root::JSContext,
            ) -> root::JS::dbg::GarbageCollectionEvent_Ptr;
            #[link_name = "\u{1}_ZN2JS13MinorGcToJSONEP9JSContext"]
            pub fn MinorGcToJSON(cx: *mut root::JSContext) -> root::JS::UniqueChars;
            /** The GC slice callback is called at the beginning and end of each slice. This
 callback may be used for GC notifications as well as to perform additional
 marking.*/
            #[link_name = "\u{1}_ZN2JS18SetGCSliceCallbackEP9JSContextPFvS1_NS_10GCProgressERKNS_13GCDescriptionEE"]
            pub fn SetGCSliceCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCSliceCallback,
            ) -> root::JS::GCSliceCallback;
            /** Add and remove nursery collection callbacks for the given runtime. These will
 be called at the start and end of every nursery collection.*/
            #[link_name = "\u{1}_ZN2JS30AddGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEPvES4_"]
            pub fn AddGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
                data: *mut ::std::os::raw::c_void,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS33RemoveGCNurseryCollectionCallbackEP9JSContextPFvS1_NS_17GCNurseryProgressENS_8GCReasonEPvES4_"]
            pub fn RemoveGCNurseryCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::GCNurseryCollectionCallback,
                data: *mut ::std::os::raw::c_void,
            );
            /** The purge gray callback is called after any COMPARTMENT_REVIVED GC in which
 the majority of compartments have been marked gray.*/
            #[link_name = "\u{1}_ZN2JS28SetDoCycleCollectionCallbackEP9JSContextPFvS1_E"]
            pub fn SetDoCycleCollectionCallback(
                cx: *mut root::JSContext,
                callback: root::JS::DoCycleCollectionCallback,
            ) -> root::JS::DoCycleCollectionCallback;
            /** Called when generating a GC slice budget. It allows the embedding to control
 the duration of slices and potentially check an interrupt flag as well. For
 internally triggered GCs, the given millis parameter is the JS engine's
 internal scheduling decision, which the embedding can choose to ignore.
 (Otherwise, it will be the value that was passed to eg
 JS::IncrementalGCSlice()).*/
            #[link_name = "\u{1}_ZN2JS30SetCreateGCSliceBudgetCallbackEP9JSContextPFNS_11SliceBudgetENS_8GCReasonExE"]
            pub fn SetCreateGCSliceBudgetCallback(
                cx: *mut root::JSContext,
                cb: root::JS::CreateSliceBudgetCallback,
            );
            /** Incremental GC defaults to enabled, but may be disabled for testing or in
 embeddings that have not yet implemented barriers on their native classes.
 There is not currently a way to re-enable incremental GC once it has been
 disabled on the runtime.*/
            #[link_name = "\u{1}_ZN2JS20DisableIncrementalGCEP9JSContext"]
            pub fn DisableIncrementalGC(cx: *mut root::JSContext);
            /** Returns true if incremental GC is enabled. Simply having incremental GC
 enabled is not sufficient to ensure incremental collections are happening.
 See the comment "Incremental GC" above for reasons why incremental GC may be
 suppressed. Inspection of the "nonincremental reason" field of the
 GCDescription returned by GCSliceCallback may help narrow down the cause if
 collections are not happening incrementally when expected.*/
            #[link_name = "\u{1}_ZN2JS22IsIncrementalGCEnabledEP9JSContext"]
            pub fn IsIncrementalGCEnabled(cx: *mut root::JSContext) -> bool;
            /** Returns true while an incremental GC is ongoing, both when actively
 collecting and between slices.*/
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSContext"]
            pub fn IsIncrementalGCInProgress(cx: *mut root::JSContext) -> bool;
            /** Returns true while an incremental GC is ongoing, both when actively
 collecting and between slices.*/
            #[link_name = "\u{1}_ZN2JS25IsIncrementalGCInProgressEP9JSRuntime"]
            pub fn IsIncrementalGCInProgress1(rt: *mut root::JSRuntime) -> bool;
            /// Returns true if the most recent GC ran incrementally.
            #[link_name = "\u{1}_ZN2JS16WasIncrementalGCEP9JSRuntime"]
            pub fn WasIncrementalGC(rt: *mut root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2JS25AutoDisableGenerationalGCC1EP9JSContext"]
            pub fn AutoDisableGenerationalGC_AutoDisableGenerationalGC(
                this: *mut root::JS::AutoDisableGenerationalGC,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS25AutoDisableGenerationalGCD1Ev"]
            pub fn AutoDisableGenerationalGC_AutoDisableGenerationalGC_destructor(
                this: *mut root::JS::AutoDisableGenerationalGC,
            );
            /** Returns true if generational allocation and collection is currently enabled
 on the given runtime.*/
            #[link_name = "\u{1}_ZN2JS23IsGenerationalGCEnabledEP9JSRuntime"]
            pub fn IsGenerationalGCEnabled(rt: *mut root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2JS20AutoAssertGCCallbackC1Ev"]
            pub fn AutoAssertGCCallback_AutoAssertGCCallback(
                this: *mut root::JS::AutoAssertGCCallback,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS17SetLowMemoryStateEP9JSContextb"]
            pub fn SetLowMemoryState(cx: *mut root::JSContext, newState: bool);
            #[link_name = "\u{1}_ZN2JS20NotifyGCRootsRemovedEP9JSContext"]
            pub fn NotifyGCRootsRemoved(cx: *mut root::JSContext);
            /** Check whether the nursery should be eagerly collected, this is before it is
 full.

 The idea is that this can be called when the host environment has some idle
 time which it can use to for GC activity.

 Returns GCReason::NO_REASON to indicate no collection is desired.*/
            #[link_name = "\u{1}_ZN2JS16WantEagerMinorGCEP9JSRuntime"]
            pub fn WantEagerMinorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
            #[link_name = "\u{1}_ZN2JS16WantEagerMajorGCEP9JSRuntime"]
            pub fn WantEagerMajorGC(rt: *mut root::JSRuntime) -> root::JS::GCReason;
            /** Check whether the nursery should be eagerly collected as per WantEagerMajorGC
 above, and if so run a collection.

 The idea is that this can be called when the host environment has some idle
 time which it can use to for GC activity.*/
            #[link_name = "\u{1}_ZN2JS25MaybeRunNurseryCollectionEP9JSRuntimeNS_8GCReasonE"]
            pub fn MaybeRunNurseryCollection(
                rt: *mut root::JSRuntime,
                reason: root::JS::GCReason,
            );
            #[link_name = "\u{1}_ZN2JS20RunNurseryCollectionEP9JSRuntimeNS_8GCReasonEN7mozilla16BaseTimeDurationINS3_27TimeDurationValueCalculatorEEE"]
            pub fn RunNurseryCollection(
                rt: *mut root::JSRuntime,
                reason: root::JS::GCReason,
                aSinceLastMinorGC: root::mozilla::TimeDuration,
            );
            #[link_name = "\u{1}_ZN2JS42SetHostCleanupFinalizationRegistryCallbackEP9JSContextPFvP10JSFunctionP8JSObjectPvES6_"]
            pub fn SetHostCleanupFinalizationRegistryCallback(
                cx: *mut root::JSContext,
                cb: root::JSHostCleanupFinalizationRegistryCallback,
                data: *mut ::std::os::raw::c_void,
            );
            /** Clear kept alive objects in JS WeakRef.
 https://tc39.es/proposal-weakrefs/#sec-clear-kept-objects*/
            #[link_name = "\u{1}_ZN2JS16ClearKeptObjectsEP9JSContext"]
            pub fn ClearKeptObjects(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS21AtomsZoneIsCollectingEP9JSRuntime"]
            pub fn AtomsZoneIsCollecting(runtime: *mut root::JSRuntime) -> bool;
            #[link_name = "\u{1}_ZN2JS11IsAtomsZoneEPNS_4ZoneE"]
            pub fn IsAtomsZone(zone: *mut root::JS::Zone) -> bool;
            #[link_name = "\u{1}_ZN2JS13GetGCZealBitsEP9JSContextPjS2_S2_"]
            pub fn GetGCZealBits(
                cx: *mut root::JSContext,
                zealBits: *mut u32,
                frequency: *mut u32,
                nextScheduled: *mut u32,
            );
            #[link_name = "\u{1}_ZN2JS9SetGCZealEP9JSContexthj"]
            pub fn SetGCZeal(cx: *mut root::JSContext, zeal: u8, frequency: u32);
            #[link_name = "\u{1}_ZN2JS11UnsetGCZealEP9JSContexth"]
            pub fn UnsetGCZeal(cx: *mut root::JSContext, zeal: u8);
            #[link_name = "\u{1}_ZN2JS10ScheduleGCEP9JSContextj"]
            pub fn ScheduleGC(cx: *mut root::JSContext, count: u32);
            /** Generate a JSErrorReport from the provided thrown value.

 If the value is a (possibly wrapped) Error object, the JSErrorReport will
 be exactly initialized from the Error object's information, without
 observable side effects. (The Error object's JSErrorReport is reused, if
 it has one.)

 Otherwise various attempts are made to derive JSErrorReport information
 from |exnStack| and from the current execution state.  This process is
 *definitely* inconsistent with any standard, and particulars of the
 behavior implemented here generally shouldn't be relied upon.

 If the value of |sniffingBehavior| is |WithSideEffects|, some of these
 attempts *may* invoke user-configurable behavior when the exception is an
 object: converting it to a string, detecting and getting its properties,
 accessing its prototype chain, and others are possible.  Users *must*
 tolerate |ErrorReportBuilder::init| potentially having arbitrary effects.
 Any exceptions thrown by these operations will be caught and silently
 ignored, and "default" values will be substituted into the JSErrorReport.

 But if the value of |sniffingBehavior| is |NoSideEffects|, these attempts
 *will not* invoke any observable side effects.  The JSErrorReport will
 simply contain fewer, less precise details.

 Unlike some functions involved in error handling, this function adheres
 to the usual JSAPI return value error behavior.*/
            #[link_name = "\u{1}_ZN2JS18ErrorReportBuilder4initEP9JSContextRKNS_14ExceptionStackENS0_16SniffingBehaviorE"]
            pub fn ErrorReportBuilder_init(
                this: *mut root::JS::ErrorReportBuilder,
                cx: *mut root::JSContext,
                exnStack: *const root::JS::ExceptionStack,
                sniffingBehavior: root::JS::ErrorReportBuilder_SniffingBehavior,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS18ErrorReportBuilderC1EP9JSContext"]
            pub fn ErrorReportBuilder_ErrorReportBuilder(
                this: *mut root::JS::ErrorReportBuilder,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS18ErrorReportBuilderD1Ev"]
            pub fn ErrorReportBuilder_ErrorReportBuilder_destructor(
                this: *mut root::JS::ErrorReportBuilder,
            );
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILEP13JSErrorReportb"]
            pub fn PrintError(
                file: *mut root::FILE,
                report: *mut root::JSErrorReport,
                reportWarnings: bool,
            );
            #[link_name = "\u{1}_ZN2JS10PrintErrorEP8_IO_FILERKNS_18ErrorReportBuilderEb"]
            pub fn PrintError1(
                file: *mut root::FILE,
                builder: *const root::JS::ErrorReportBuilder,
                reportWarnings: bool,
            );
            #[link_name = "\u{1}_ZN2JS11CreateErrorEP9JSContext9JSExnTypeNS_6HandleIP8JSObjectEENS3_IP8JSStringEEjNS_21ColumnNumberOneOriginEP13JSErrorReportS9_NS3_IN7mozilla5MaybeINS_5ValueEEEEENS_13MutableHandleISF_EE"]
            pub fn CreateError(
                cx: *mut root::JSContext,
                type_: root::JSExnType,
                stack: root::JS::HandleObject,
                fileName: root::JS::HandleString,
                lineNumber: u32,
                column: root::JS::ColumnNumberOneOrigin,
                report: *mut root::JSErrorReport,
                message: root::JS::HandleString,
                cause: root::JS::Handle<root::mozilla::Maybe>,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JSL26IsCatchableExceptionStatusENS_15ExceptionStatusE"]
            pub fn IsCatchableExceptionStatus(status: root::JS::ExceptionStatus) -> bool;
            #[link_name = "\u{1}_ZN2JS22AutoSaveExceptionState4dropEv"]
            pub fn AutoSaveExceptionState_drop(
                this: *mut root::JS::AutoSaveExceptionState,
            );
            #[link_name = "\u{1}_ZN2JS22AutoSaveExceptionState7restoreEv"]
            pub fn AutoSaveExceptionState_restore(
                this: *mut root::JS::AutoSaveExceptionState,
            );
            #[link_name = "\u{1}_ZN2JS22AutoSaveExceptionStateC1EP9JSContext"]
            pub fn AutoSaveExceptionState_AutoSaveExceptionState(
                this: *mut root::JS::AutoSaveExceptionState,
                cx: *mut root::JSContext,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS22AutoSaveExceptionStateD1Ev"]
            pub fn AutoSaveExceptionState_AutoSaveExceptionState_destructor(
                this: *mut root::JS::AutoSaveExceptionState,
            );
            #[link_name = "\u{1}_ZN2JS24GetPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn GetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS26StealPendingExceptionStackEP9JSContextPNS_14ExceptionStackE"]
            pub fn StealPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *mut root::JS::ExceptionStack,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS24SetPendingExceptionStackEP9JSContextRKNS_14ExceptionStackE"]
            pub fn SetPendingExceptionStack(
                cx: *mut root::JSContext,
                exceptionStack: *const root::JS::ExceptionStack,
            );
            /** If the given object is an exception object (or an unwrappable
 cross-compartment wrapper for one), return the stack for that exception, if
 any.  Will return null if the given object is not an exception object
 (including if it's null or a security wrapper that can't be unwrapped) or if
 the exception has no stack.*/
            #[link_name = "\u{1}_ZN2JS20ExceptionStackOrNullENS_6HandleIP8JSObjectEE"]
            pub fn ExceptionStackOrNull(
                obj: root::JS::HandleObject,
            ) -> *mut root::JSObject;
            /** If the given object is an exception object, return the error cause for that
 exception, if any, or mozilla::Nothing.*/
            #[link_name = "\u{1}_ZN2JS17GetExceptionCauseEP8JSObject"]
            pub fn GetExceptionCause(exc: *mut root::JSObject) -> root::mozilla::Maybe;
            /** Get the current realm's global. Returns nullptr if no realm has been
 entered.*/
            #[link_name = "\u{1}_ZN2JS19CurrentGlobalOrNullEP9JSContext"]
            pub fn CurrentGlobalOrNull(cx: *mut root::JSContext) -> *mut root::JSObject;
            /** Get the global object associated with an object's realm. The object must not
 be a cross-compartment wrapper (because CCWs are shared by all realms in the
 compartment).*/
            #[link_name = "\u{1}_ZN2JS21GetNonCCWObjectGlobalEP8JSObject"]
            pub fn GetNonCCWObjectGlobal(
                obj: *mut root::JSObject,
            ) -> *mut root::JSObject;
            /** This allows easily constructing a global object without having to deal with
 JSClassOps, forgetting to add JS_GlobalObjectTraceHook, or forgetting to call
 JS::InitRealmStandardClasses(). Example:

     const JSClass globalClass = { "MyGlobal", JSCLASS_GLOBAL_FLAGS,
         &JS::DefaultGlobalClassOps };
     JS_NewGlobalObject(cx, &globalClass, ...);*/
            #[link_name = "\u{1}_ZN2JS21DefaultGlobalClassOpsE"]
            pub static DefaultGlobalClassOps: root::JSClassOps;
            #[link_name = "\u{1}_ZN2JS12NewMapObjectEP9JSContext"]
            pub fn NewMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS7MapSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
            #[link_name = "\u{1}_ZN2JS6MapGetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn MapGet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS6MapHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS6MapSetEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapSet(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS9MapDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn MapDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS8MapClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn MapClear(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS7MapKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS9MapValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS10MapEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn MapEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS10MapForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn MapForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS12NewSetObjectEP9JSContext"]
            pub fn NewSetObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS7SetSizeEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetSize(cx: *mut root::JSContext, obj: root::JS::HandleObject) -> u32;
            #[link_name = "\u{1}_ZN2JS6SetHasEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetHas(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS9SetDeleteEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn SetDelete(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                rval: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS6SetAddEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEE"]
            pub fn SetAdd(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                key: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS8SetClearEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn SetClear(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS7SetKeysEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetKeys(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS9SetValuesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetValues(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS10SetEntriesEP9JSContextNS_6HandleIP8JSObjectEENS_13MutableHandleINS_5ValueEEE"]
            pub fn SetEntries(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                rval: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS10SetForEachEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetForEach(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                callbackFn: root::JS::HandleValue,
                thisVal: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS40SetProcessLargeAllocationFailureCallbackEPFvvE"]
            pub fn SetProcessLargeAllocationFailureCallback(
                afc: root::JS::LargeAllocationFailureCallback,
            );
            #[link_name = "\u{1}_ZN2JS22SetOutOfMemoryCallbackEP9JSContextPFvS1_PvES2_"]
            pub fn SetOutOfMemoryCallback(
                cx: *mut root::JSContext,
                cb: root::JS::OutOfMemoryCallback,
                data: *mut ::std::os::raw::c_void,
            );
            /** Advise the GC of external memory owned by a JSObject. This is used to
 determine when to collect zones. Calls must be matched by calls to
 RemoveAssociatedMemory() when the memory is deallocated or no longer owned by
 the object.*/
            #[link_name = "\u{1}_ZN2JS19AddAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn AddAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
            /** Advise the GC that external memory reported by JS::AddAssociatedMemory() is
 no longer owned by a JSObject. Calls must match those to
 AddAssociatedMemory().*/
            #[link_name = "\u{1}_ZN2JS22RemoveAssociatedMemoryEP8JSObjectmNS_9MemoryUseE"]
            pub fn RemoveAssociatedMemory(
                obj: *mut root::JSObject,
                nbytes: usize,
                use_: root::JS::MemoryUse,
            );
            /** This function calls |realmCallback| on every realm. Beware that there is no
 guarantee that the realm will survive after the callback returns. Also,
 barriers are disabled via the TraceSession.*/
            #[link_name = "\u{1}_ZN2JS13IterateRealmsEP9JSContextPvPFvS1_S2_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealms(
                cx: *mut root::JSContext,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
            /// Like IterateRealms, but only call the callback for realms using |principals|.
            #[link_name = "\u{1}_ZN2JS27IterateRealmsWithPrincipalsEP9JSContextP12JSPrincipalsPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsWithPrincipals(
                cx: *mut root::JSContext,
                principals: *mut root::JSPrincipals,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
            /// Like IterateRealms, but only iterates realms in |compartment|.
            #[link_name = "\u{1}_ZN2JS26IterateRealmsInCompartmentEP9JSContextPNS_11CompartmentEPvPFvS1_S4_PNS_5RealmERKNS_15AutoRequireNoGCEE"]
            pub fn IterateRealmsInCompartment(
                cx: *mut root::JSContext,
                compartment: *mut root::JS::Compartment,
                data: *mut ::std::os::raw::c_void,
                realmCallback: root::JS::IterateRealmCallback,
            );
            /** Set a private value associated with a script. Note that this value is shared
 by all nested scripts compiled from a single source file.*/
            #[link_name = "\u{1}_ZN2JS16SetScriptPrivateEP8JSScriptRKNS_5ValueE"]
            pub fn SetScriptPrivate(
                script: *mut root::JSScript,
                value: *const root::JS::Value,
            );
            /** Get the private value associated with a script. Note that this value is
 shared by all nested scripts compiled from a single source file.*/
            #[link_name = "\u{1}_ZN2JS16GetScriptPrivateEP8JSScript"]
            pub fn GetScriptPrivate(script: *mut root::JSScript) -> root::JS::Value;
            /** Return the private value associated with currently executing script or
 module, or undefined if there is no such script.*/
            #[link_name = "\u{1}_ZN2JS24GetScriptedCallerPrivateEP9JSContext"]
            pub fn GetScriptedCallerPrivate(cx: *mut root::JSContext) -> root::JS::Value;
            /// Set the script private finalize hook for the runtime to the given function.
            #[link_name = "\u{1}_ZN2JS30SetScriptPrivateReferenceHooksEP9JSRuntimePFvRKNS_5ValueEES6_"]
            pub fn SetScriptPrivateReferenceHooks(
                rt: *mut root::JSRuntime,
                addRefHook: root::JS::ScriptPrivateReferenceHook,
                releaseHook: root::JS::ScriptPrivateReferenceHook,
            );
            #[link_name = "\u{1}_ZN2JS25InitConsumeStreamCallbackEP9JSContextPFbS1_NS_6HandleIP8JSObjectEENS_8MimeTypeEPNS_14StreamConsumerEEPFvS1_mE"]
            pub fn InitConsumeStreamCallback(
                cx: *mut root::JSContext,
                consume: root::JS::ConsumeStreamCallback,
                report: root::JS::ReportStreamErrorCallback,
            );
            #[link_name = "\u{1}_ZN2JS11GetJSTimersEP9JSContext"]
            pub fn GetJSTimers(cx: *mut root::JSContext) -> root::JS::JSTimers;
            #[link_name = "\u{1}_ZN2JS15SetWaitCallbackEP9JSRuntimePFPvPhEPFvS2_Em"]
            pub fn SetWaitCallback(
                rt: *mut root::JSRuntime,
                beforeWait: root::JS::BeforeWaitCallback,
                afterWait: root::JS::AfterWaitCallback,
                requiredMemory: usize,
            );
            #[link_name = "\u{1}_ZN2JS16NewWeakMapObjectEP9JSContext"]
            pub fn NewWeakMapObject(cx: *mut root::JSContext) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN2JS15IsWeakMapObjectEP8JSObject"]
            pub fn IsWeakMapObject(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS15GetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEENS_13MutableHandleIS6_EE"]
            pub fn GetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::MutableHandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS15SetWeakMapEntryEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEES7_"]
            pub fn SetWeakMapEntry(
                cx: *mut root::JSContext,
                mapObj: root::JS::HandleObject,
                key: root::JS::HandleValue,
                val: root::JS::HandleValue,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS21InformalValueTypeNameERKNS_5ValueE"]
            pub fn InformalValueTypeName(
                v: *const root::JS::Value,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZN2JS24IdentifyStandardInstanceEP8JSObject"]
            pub fn IdentifyStandardInstance(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
            #[link_name = "\u{1}_ZN2JS25IdentifyStandardPrototypeEP8JSObject"]
            pub fn IdentifyStandardPrototype(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
            #[link_name = "\u{1}_ZN2JS35IdentifyStandardInstanceOrPrototypeEP8JSObject"]
            pub fn IdentifyStandardInstanceOrPrototype(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
            #[link_name = "\u{1}_ZN2JS27IdentifyStandardConstructorEP8JSObject"]
            pub fn IdentifyStandardConstructor(
                obj: *mut root::JSObject,
            ) -> root::JSProtoKey;
            #[link_name = "\u{1}_ZN2JS12ProtoKeyToIdEP9JSContext10JSProtoKeyNS_13MutableHandleINS_11PropertyKeyEEE"]
            pub fn ProtoKeyToId(
                cx: *mut root::JSContext,
                key: root::JSProtoKey,
                idp: root::JS::MutableHandleId,
            );
            /** Tell JS engine whether Profile Timeline Recording is enabled or not.
 If Profile Timeline Recording is enabled, data shown there like stack won't
 be optimized out.
 This is global state and not associated with specific runtime or context.*/
            #[link_name = "\u{1}_ZN2JS34SetProfileTimelineRecordingEnabledEb"]
            pub fn SetProfileTimelineRecordingEnabled(enabled: bool);
            #[link_name = "\u{1}_ZN2JS33IsProfileTimelineRecordingEnabledEv"]
            pub fn IsProfileTimelineRecordingEnabled() -> bool;
            /** Convert obj to a primitive value. On success, store the result in vp and
 return true.

 The hint argument must be JSTYPE_STRING, JSTYPE_NUMBER, or
 JSTYPE_UNDEFINED (no hint).

 Implements: ES6 7.1.1 ToPrimitive(input, [PreferredType]).*/
            #[link_name = "\u{1}_ZN2JS11ToPrimitiveEP9JSContextNS_6HandleIP8JSObjectEE6JSTypeNS_13MutableHandleINS_5ValueEEE"]
            pub fn ToPrimitive(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                hint: root::JSType,
                vp: root::JS::MutableHandleValue,
            ) -> bool;
            /** If args.get(0) is one of the strings "string", "number", or "default", set
 result to JSTYPE_STRING, JSTYPE_NUMBER, or JSTYPE_UNDEFINED accordingly and
 return true. Otherwise, return false with a TypeError pending.

 This can be useful in implementing a @@toPrimitive method.*/
            #[link_name = "\u{1}_ZN2JS26GetFirstArgumentAsTypeHintEP9JSContextRKNS_8CallArgsEP6JSType"]
            pub fn GetFirstArgumentAsTypeHint(
                cx: *mut root::JSContext,
                args: *const root::JS::CallArgs,
                result: *mut root::JSType,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS19OrdinaryHasInstanceEP9JSContextNS_6HandleIP8JSObjectEENS2_INS_5ValueEEEPb"]
            pub fn OrdinaryHasInstance(
                cx: *mut root::JSContext,
                objArg: root::JS::HandleObject,
                v: root::JS::HandleValue,
                bp: *mut bool,
            ) -> bool;
            /** On success, returns true, setting |*isMap| to true if |obj| is a Map object
 or a wrapper around one, or to false if not.  Returns false on failure.

 This method returns true with |*isMap == false| when passed an ES6 proxy
 whose target is a Map, or when passed a revoked proxy.*/
            #[link_name = "\u{1}_ZN2JS11IsMapObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsMapObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isMap: *mut bool,
            ) -> bool;
            /** On success, returns true, setting |*isSet| to true if |obj| is a Set object
 or a wrapper around one, or to false if not.  Returns false on failure.

 This method returns true with |*isSet == false| when passed an ES6 proxy
 whose target is a Set, or when passed a revoked proxy.*/
            #[link_name = "\u{1}_ZN2JS11IsSetObjectEP9JSContextNS_6HandleIP8JSObjectEEPb"]
            pub fn IsSetObject(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                isSet: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS21GetSelfHostedFunctionEP9JSContextPKcNS_6HandleINS_11PropertyKeyEEEj"]
            pub fn GetSelfHostedFunction(
                cx: *mut root::JSContext,
                selfHostedName: *const ::std::os::raw::c_char,
                id: root::JS::HandleId,
                nargs: ::std::os::raw::c_uint,
            ) -> *mut root::JSFunction;
            /** Create a new function based on the given JSFunctionSpec, *fs.
 id is the result of a successful call to
 `PropertySpecNameToId(cx, fs->name, &id)` or
`PropertySpecNameToPermanentId(cx, fs->name, &id)`.

 Unlike JS_DefineFunctions, this does not treat fs as an array.
 *fs must not be JS_FS_END.*/
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpecNS_6HandleINS_11PropertyKeyEEE"]
            pub fn NewFunctionFromSpec(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
                id: root::JS::HandleId,
            ) -> *mut root::JSFunction;
            /** Same as above, but without an id arg, for callers who don't have
 the id already.*/
            #[link_name = "\u{1}_ZN2JS19NewFunctionFromSpecEP9JSContextPK14JSFunctionSpec"]
            pub fn NewFunctionFromSpec1(
                cx: *mut root::JSContext,
                fs: *const root::JSFunctionSpec,
            ) -> *mut root::JSFunction;
            #[link_name = "\u{1}_ZN2JS28AutoSetAsyncStackForNewCallsC1EP9JSContextNS_6HandleIP8JSObjectEEPKcNS0_13AsyncCallKindE"]
            pub fn AutoSetAsyncStackForNewCalls_AutoSetAsyncStackForNewCalls(
                this: *mut root::JS::AutoSetAsyncStackForNewCalls,
                cx: *mut root::JSContext,
                stack: root::JS::HandleObject,
                asyncCause: *const ::std::os::raw::c_char,
                kind: root::JS::AutoSetAsyncStackForNewCalls_AsyncCallKind,
            ) -> *mut ::std::os::raw::c_void;
            #[link_name = "\u{1}_ZN2JS28AutoSetAsyncStackForNewCallsD1Ev"]
            pub fn AutoSetAsyncStackForNewCalls_AutoSetAsyncStackForNewCalls_destructor(
                this: *mut root::JS::AutoSetAsyncStackForNewCalls,
            );
            #[link_name = "\u{1}_ZN2JS24PropertySpecNameEqualsIdEN14JSPropertySpec4NameENS_6HandleINS_11PropertyKeyEEE"]
            pub fn PropertySpecNameEqualsId(
                name: root::JSPropertySpec_Name,
                id: root::JS::HandleId,
            ) -> bool;
            /** Create a jsid that does not need to be marked for GC.

 'name' is a JSPropertySpec::name or JSFunctionSpec::name value. The
 resulting jsid, on success, is either an interned string or a well-known
 symbol; either way it is immune to GC so there is no need to visit *idp
 during GC marking.*/
            #[link_name = "\u{1}_ZN2JS29PropertySpecNameToPermanentIdEP9JSContextN14JSPropertySpec4NameEPNS_11PropertyKeyE"]
            pub fn PropertySpecNameToPermanentId(
                cx: *mut root::JSContext,
                name: root::JSPropertySpec_Name,
                idp: *mut root::jsid,
            ) -> bool;
            #[link_name = "\u{1}_ZN2JS34DisableSpectreMitigationsAfterInitEv"]
            pub fn DisableSpectreMitigationsAfterInit();
            #[link_name = "\u{1}_ZN2JS12AutoFilename5resetEv"]
            pub fn AutoFilename_reset(this: *mut root::JS::AutoFilename);
            #[link_name = "\u{1}_ZN2JS12AutoFilename8setOwnedEON7mozilla9UniquePtrIA_cNS_10FreePolicyEEE"]
            pub fn AutoFilename_setOwned(
                this: *mut root::JS::AutoFilename,
                filename: *mut root::JS::UniqueChars,
            );
            #[link_name = "\u{1}_ZN2JS12AutoFilename10setUnownedEPKc"]
            pub fn AutoFilename_setUnowned(
                this: *mut root::JS::AutoFilename,
                filename: *const ::std::os::raw::c_char,
            );
            #[link_name = "\u{1}_ZN2JS12AutoFilename15setScriptSourceEPN2js12ScriptSourceE"]
            pub fn AutoFilename_setScriptSource(
                this: *mut root::JS::AutoFilename,
                ss: *mut root::js::ScriptSource,
            );
            #[link_name = "\u{1}_ZNK2JS12AutoFilename3getEv"]
            pub fn AutoFilename_get(
                this: *const root::JS::AutoFilename,
            ) -> *const ::std::os::raw::c_char;
            #[link_name = "\u{1}_ZN2JS23GetScriptedCallerGlobalEP9JSContext"]
            pub fn GetScriptedCallerGlobal(
                cx: *mut root::JSContext,
            ) -> *mut root::JSObject;
            /** Informs the JS engine that the scripted caller should be hidden. This can be
 used by the embedding to maintain an override of the scripted caller in its
 calculations, by hiding the scripted caller in the JS engine and pushing data
 onto a separate stack, which it inspects when DescribeScriptedCaller returns
 null.

 We maintain a counter on each activation record. Add() increments the counter
 of the topmost activation, and Remove() decrements it. The count may never
 drop below zero, and must always be exactly zero when the activation is
 popped from the stack.*/
            #[link_name = "\u{1}_ZN2JS18HideScriptedCallerEP9JSContext"]
            pub fn HideScriptedCaller(cx: *mut root::JSContext);
            #[link_name = "\u{1}_ZN2JS20UnhideScriptedCallerEP9JSContext"]
            pub fn UnhideScriptedCaller(cx: *mut root::JSContext);
            #[must_use]
            /** Attempt to disable Wasm's usage of reserving a large virtual memory
 allocation to avoid bounds checking overhead. This must be called before any
 Wasm module or memory is created in this process, or else this function will
 fail.*/
            #[link_name = "\u{1}_ZN2JS21DisableWasmHugeMemoryEv"]
            pub fn DisableWasmHugeMemory() -> bool;
            /** Return true iff the given object is either a SavedFrame object or wrapper
 around a SavedFrame object, and it is not the SavedFrame.prototype object.*/
            #[link_name = "\u{1}_ZN2JS24IsMaybeWrappedSavedFrameEP8JSObject"]
            pub fn IsMaybeWrappedSavedFrame(obj: *mut root::JSObject) -> bool;
            /** Return true iff the given object is a SavedFrame object and not the
 SavedFrame.prototype object.*/
            #[link_name = "\u{1}_ZN2JS21IsUnwrappedSavedFrameEP8JSObject"]
            pub fn IsUnwrappedSavedFrame(obj: *mut root::JSObject) -> bool;
            #[link_name = "\u{1}_ZN2JS29SetSupportDifferentialTestingEb"]
            pub fn SetSupportDifferentialTesting(value: bool);
            /** Set all of the uninitialized lexicals on an object to undefined. Return
 true if any lexicals were initialized and false otherwise.*/
            #[link_name = "\u{1}_ZN2JS26ForceLexicalInitializationEP9JSContextNS_6HandleIP8JSObjectEE"]
            pub fn ForceLexicalInitialization(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
            ) -> bool;
            /** Whether we are poisoning unused/released data for error detection. Governed
 by the JS_GC_ALLOW_EXTRA_POISONING #ifdef as well as the
 javascript.options.extra_gc_poisoning pref.*/
            #[link_name = "\u{1}_ZN2JS13IsGCPoisoningEv"]
            pub fn IsGCPoisoning() -> bool;
            #[link_name = "\u{1}_ZN2JS18GetRealmPrincipalsEPNS_5RealmE"]
            pub fn GetRealmPrincipals(
                realm: *mut root::JS::Realm,
            ) -> *mut root::JSPrincipals;
            #[link_name = "\u{1}_ZN2JS18SetRealmPrincipalsEPNS_5RealmEP12JSPrincipals"]
            pub fn SetRealmPrincipals(
                realm: *mut root::JS::Realm,
                principals: *mut root::JSPrincipals,
            );
            #[link_name = "\u{1}_ZN2JS18GetIsSecureContextEPNS_5RealmE"]
            pub fn GetIsSecureContext(realm: *mut root::JS::Realm) -> bool;
            #[link_name = "\u{1}_ZN2JS23GetDebuggerObservesWasmEPNS_5RealmE"]
            pub fn GetDebuggerObservesWasm(realm: *mut root::JS::Realm) -> bool;
        }
    }
    pub type jsid = root::JS::PropertyKey;
    pub type arena_id_t = usize;
    /** already_AddRefed cooperates with reference counting smart pointers to enable
 you to assign in a pointer _without_ |AddRef|ing it.  You might want to use
 this as a return type from a function that returns an already |AddRef|ed
 pointer.  Or, you might want to use this as a parameter type in a function
 that wants to force a transfer-of-ownership from a RefPtr in the caller (for
 example, if the function expects callers to pass in a newly-created object,
 which the function then takes ownership of).

 TODO Move already_AddRefed to namespace mozilla.  This has not yet been done
 because of the sheer number of usages of already_AddRefed.

 When should you use already_AddRefed<>?
 * Ensure a consumer takes ownership of a reference
 * Pass ownership without calling AddRef/Release (sometimes required in
   off-main-thread code)
 * The ref pointer type you're using doesn't support move construction

 Otherwise, use std::move(RefPtr/nsCOMPtr/etc).*/
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct already_AddRefed<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct nsISupports {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct RefPtr<T> {
        pub mRawPtr: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    pub type RefPtr_element_type<T> = T;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct RefPtr_Proxy {
        pub _address: u8,
    }
    pub type RefPtr_Proxy_member_function = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct RefPtr_ConstRemovingRefPtrTraits {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSLinearString {
        _unused: [u8; 0],
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSType {
        JSTYPE_UNDEFINED = 0,
        JSTYPE_OBJECT = 1,
        JSTYPE_FUNCTION = 2,
        JSTYPE_STRING = 3,
        JSTYPE_NUMBER = 4,
        JSTYPE_BOOLEAN = 5,
        JSTYPE_SYMBOL = 6,
        JSTYPE_BIGINT = 7,
        JSTYPE_LIMIT = 8,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSProtoKey {
        JSProto_Null = 0,
        JSProto_Object = 1,
        JSProto_Function = 2,
        JSProto_BoundFunction = 3,
        JSProto_Array = 4,
        JSProto_Boolean = 5,
        JSProto_JSON = 6,
        JSProto_Date = 7,
        JSProto_Math = 8,
        JSProto_Number = 9,
        JSProto_String = 10,
        JSProto_RegExp = 11,
        JSProto_Error = 12,
        JSProto_InternalError = 13,
        JSProto_AggregateError = 14,
        JSProto_EvalError = 15,
        JSProto_RangeError = 16,
        JSProto_ReferenceError = 17,
        JSProto_SyntaxError = 18,
        JSProto_TypeError = 19,
        JSProto_URIError = 20,
        JSProto_DebuggeeWouldRun = 21,
        JSProto_CompileError = 22,
        JSProto_LinkError = 23,
        JSProto_RuntimeError = 24,
        JSProto_ArrayBuffer = 25,
        JSProto_Int8Array = 26,
        JSProto_Uint8Array = 27,
        JSProto_Int16Array = 28,
        JSProto_Uint16Array = 29,
        JSProto_Int32Array = 30,
        JSProto_Uint32Array = 31,
        JSProto_Float32Array = 32,
        JSProto_Float64Array = 33,
        JSProto_Uint8ClampedArray = 34,
        JSProto_BigInt64Array = 35,
        JSProto_BigUint64Array = 36,
        JSProto_Float16Array = 37,
        JSProto_BigInt = 38,
        JSProto_Proxy = 39,
        JSProto_WeakMap = 40,
        JSProto_Map = 41,
        JSProto_Set = 42,
        JSProto_DataView = 43,
        JSProto_Symbol = 44,
        JSProto_ShadowRealm = 45,
        JSProto_SharedArrayBuffer = 46,
        JSProto_Intl = 47,
        JSProto_Collator = 48,
        JSProto_DateTimeFormat = 49,
        JSProto_DisplayNames = 50,
        JSProto_ListFormat = 51,
        JSProto_Locale = 52,
        JSProto_NumberFormat = 53,
        JSProto_PluralRules = 54,
        JSProto_RelativeTimeFormat = 55,
        JSProto_Segmenter = 56,
        JSProto_Reflect = 57,
        JSProto_WeakSet = 58,
        JSProto_TypedArray = 59,
        JSProto_Atomics = 60,
        JSProto_SavedFrame = 61,
        JSProto_Promise = 62,
        JSProto_AsyncFunction = 63,
        JSProto_GeneratorFunction = 64,
        JSProto_AsyncGeneratorFunction = 65,
        JSProto_WebAssembly = 66,
        JSProto_WasmModule = 67,
        JSProto_WasmInstance = 68,
        JSProto_WasmMemory = 69,
        JSProto_WasmTable = 70,
        JSProto_WasmGlobal = 71,
        JSProto_WasmTag = 72,
        JSProto_WasmFunction = 73,
        JSProto_WasmSuspending = 74,
        JSProto_WasmException = 75,
        JSProto_FinalizationRegistry = 76,
        JSProto_WeakRef = 77,
        JSProto_Iterator = 78,
        JSProto_AsyncIterator = 79,
        JSProto_Temporal = 80,
        JSProto_Calendar = 81,
        JSProto_Duration = 82,
        JSProto_Instant = 83,
        JSProto_PlainDate = 84,
        JSProto_PlainDateTime = 85,
        JSProto_PlainMonthDay = 86,
        JSProto_PlainYearMonth = 87,
        JSProto_PlainTime = 88,
        JSProto_TemporalNow = 89,
        JSProto_TimeZone = 90,
        JSProto_ZonedDateTime = 91,
        JSProto_LIMIT = 92,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneReader {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSStructuredCloneWriter {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSConstScalarSpec {
        pub _address: u8,
    }
    pub type JSConstDoubleSpec = root::JSConstScalarSpec;
    pub type JSConstIntegerSpec = root::JSConstScalarSpec;
    #[repr(C)]
    pub struct JSTracer__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSTracer {
        pub vtable_: *const JSTracer__bindgen_vtable,
        pub runtime_: *mut root::JSRuntime,
        pub kind_: root::JS::TracerKind,
        pub options_: root::JS::TraceOptions,
        pub context_: root::JS::TracingContext,
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct ProfilingStack {
        pub capacity: u32,
        pub frames: u32,
        pub stackPointer: u32,
    }
    impl ProfilingStack {
        #[inline]
        pub unsafe fn destruct(&mut self) {
            ProfilingStack_ProfilingStack_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    impl JSAutoRealm {
        #[inline]
        pub unsafe fn new(
            cx: *mut root::JSContext,
            target: *mut root::JSObject,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            JSAutoRealm_JSAutoRealm(__bindgen_tmp.as_mut_ptr(), cx, target);
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn new1(
            cx: *mut root::JSContext,
            target: *mut root::JSScript,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            JSAutoRealm_JSAutoRealm1(__bindgen_tmp.as_mut_ptr(), cx, target);
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            JSAutoRealm_JSAutoRealm_destructor(self)
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoNullableRealm {
        pub cx_: *mut root::JSContext,
        pub oldRealm_: *mut root::JS::Realm,
    }
    impl JSAutoNullableRealm {
        #[inline]
        pub unsafe fn new(
            cx: *mut root::JSContext,
            targetOrNull: *mut root::JSObject,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            JSAutoNullableRealm_JSAutoNullableRealm(
                __bindgen_tmp.as_mut_ptr(),
                cx,
                targetOrNull,
            );
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            JSAutoNullableRealm_JSAutoNullableRealm_destructor(self)
        }
    }
    #[repr(C)]
    pub struct JSPrincipals__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSPrincipals {
        pub vtable_: *const JSPrincipals__bindgen_vtable,
        pub refcount: u32,
        pub debugToken: u32,
    }
    impl JSPrincipals {
        #[inline]
        pub unsafe fn dump(&mut self) {
            JSPrincipals_dump(self)
        }
    }
    pub type JSSubsumesOp = ::std::option::Option<
        unsafe extern "C" fn(
            first: *mut root::JSPrincipals,
            second: *mut root::JSPrincipals,
        ) -> bool,
    >;
    pub type JSCSPEvalChecker = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            kind: root::JS::RuntimeCode,
            code: root::JS::HandleString,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSSecurityCallbacks {
        pub contentSecurityPolicyAllows: root::JSCSPEvalChecker,
        pub subsumes: root::JSSubsumesOp,
    }
    pub type JSDestroyPrincipalsOp = ::std::option::Option<
        unsafe extern "C" fn(principals: *mut root::JSPrincipals),
    >;
    pub type JSReadPrincipalsOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            reader: *mut root::JSStructuredCloneReader,
            outPrincipals: *mut *mut root::JSPrincipals,
        ) -> bool,
    >;
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueType {
        JSVAL_TYPE_DOUBLE = 0,
        JSVAL_TYPE_INT32 = 1,
        JSVAL_TYPE_BOOLEAN = 2,
        JSVAL_TYPE_UNDEFINED = 3,
        JSVAL_TYPE_NULL = 4,
        JSVAL_TYPE_MAGIC = 5,
        JSVAL_TYPE_STRING = 6,
        JSVAL_TYPE_SYMBOL = 7,
        JSVAL_TYPE_PRIVATE_GCTHING = 8,
        JSVAL_TYPE_BIGINT = 9,
        JSVAL_TYPE_OBJECT = 12,
        JSVAL_TYPE_UNKNOWN = 32,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSValueTag {
        JSVAL_TAG_CLEAR = 4294967168,
        JSVAL_TAG_INT32 = 4294967169,
        JSVAL_TAG_UNDEFINED = 4294967171,
        JSVAL_TAG_NULL = 4294967172,
        JSVAL_TAG_BOOLEAN = 4294967170,
        JSVAL_TAG_MAGIC = 4294967173,
        JSVAL_TAG_STRING = 4294967174,
        JSVAL_TAG_SYMBOL = 4294967175,
        JSVAL_TAG_PRIVATE_GCTHING = 4294967176,
        JSVAL_TAG_BIGINT = 4294967177,
        JSVAL_TAG_OBJECT = 4294967180,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSWhyMagic {
        /// a hole in a native object's elements
        JS_ELEMENTS_HOLE = 0,
        /// there is not a pending iterator value
        JS_NO_ITER_VALUE = 1,
        /// exception value thrown when closing a generator
        JS_GENERATOR_CLOSING = 2,
        /// used in debug builds to catch tracing errors
        JS_ARG_POISON = 3,
        /// an empty subnode in the AST serializer
        JS_SERIALIZE_NO_NODE = 4,
        /// magic value passed to natives to indicate construction
        JS_IS_CONSTRUCTING = 5,
        /// see class js::HashableValue
        JS_HASH_KEY_EMPTY = 6,
        /// error while running Ion code
        JS_ION_ERROR = 7,
        /// missing recover instruction result
        JS_ION_BAILOUT = 8,
        /// optimized out slot
        JS_OPTIMIZED_OUT = 9,
        /// uninitialized lexical bindings that produce ReferenceError on touch.
        JS_UNINITIALIZED_LEXICAL = 10,
        /// arguments object can't be created because environment is dead.
        JS_MISSING_ARGUMENTS = 11,
        /// exception value thrown when interrupting irregexp
        JS_INTERRUPT_REGEXP = 12,
        /// for local use
        JS_GENERIC_MAGIC = 13,
        /** Write records queued up in WritableStreamDefaultController.[[queue]] in the
 spec are either "close" (a String) or Record { [[chunk]]: chunk }, where
 chunk is an arbitrary user-provided (and therefore non-magic) value.
 Represent "close" the String as this magic value; represent Record records
 as the |chunk| value within each of them.*/
        JS_WRITABLESTREAM_CLOSE_RECORD = 14,
        /** The ReadableStream pipe-to operation concludes with a "finalize" operation
 that accepts an optional |error| argument.  In certain cases that optional
 |error| must be stored in a handler function, for use after a promise has
 settled.  We represent the argument not being provided, in those cases,
 using this magic value.*/
        JS_READABLESTREAM_PIPETO_FINALIZE_WITHOUT_ERROR = 15,
        /** When an error object is created without the error cause argument, we set
 the error's cause slot to this magic value.*/
        JS_ERROR_WITHOUT_CAUSE = 16,
        /** When an error object is created without the error cause argument, we set
 the error's cause slot to this magic value.*/
        JS_WHY_MAGIC_COUNT = 17,
    }
    pub type JSNative = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            argc: ::std::os::raw::c_uint,
            vp: *mut root::JS::Value,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct JSAtomState {
        _unused: [u8; 0],
    }
    /// Add a property named by id to obj.
    pub type JSAddPropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            v: root::JS::HandleValue,
        ) -> bool,
    >;
    /** Delete a property named by id in obj.

 If an error occurred, return false as per normal JSAPI error practice.

 If no error occurred, but the deletion attempt wasn't allowed (perhaps
 because the property was non-configurable), call result.fail() and
 return true.  This will cause |delete obj[id]| to evaluate to false in
 non-strict mode code, and to throw a TypeError in strict mode code.

 If no error occurred and the deletion wasn't disallowed (this is *not* the
 same as saying that a deletion actually occurred -- deleting a non-existent
 property, or an inherited property, is allowed -- it's just pointless),
 call result.succeed() and return true.*/
    pub type JSDeletePropertyOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool,
    >;
    /** The type of ObjectOps::enumerate. This callback overrides a portion of
 SpiderMonkey's default [[Enumerate]] internal method. When an ordinary object
 is enumerated, that object and each object on its prototype chain is tested
 for an enumerate op, and those ops are called in order. The properties each
 op adds to the 'properties' vector are added to the set of values the for-in
 loop will iterate over. All of this is nonstandard.

 An object is "enumerated" when it's the target of a for-in loop or
 JS_Enumerate(). The callback's job is to populate 'properties' with the
 object's property keys. If `enumerableOnly` is true, the callback should only
 add enumerable properties.*/
    pub type JSNewEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool,
    >;
    /** The old-style JSClass.enumerate op should define all lazy properties not
 yet reflected in obj.*/
    pub type JSEnumerateOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool,
    >;
    /** The type of ObjectOps::funToString.  This callback allows an object to
 provide a custom string to use when Function.prototype.toString is invoked on
 that object.  A null return value means OOM.*/
    pub type JSFunToStringOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isToSource: bool,
        ) -> *mut root::JSString,
    >;
    /** Resolve a lazy property named by id in obj by defining it directly in obj.
 Lazy properties are those reflected from some peer native property space
 (e.g., the DOM attributes for a given node reflected as obj) on demand.

 JS looks for a property in an object, and if not found, tries to resolve
 the given id. *resolvedp should be set to true iff the property was defined
 on |obj|.

 See JS::dbg::ShouldAvoidSideEffects in Debug.h if this function has any
 other side-effect than just resolving the property.*/
    pub type JSResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolvedp: *mut bool,
        ) -> bool,
    >;
    /** A class with a resolve hook can optionally have a mayResolve hook. This hook
 must have no side effects and must return true for a given id if the resolve
 hook may resolve this id. This is useful when we're doing a "pure" lookup: if
 mayResolve returns false, we know we don't have to call the effectful resolve
 hook.

 maybeObj, if non-null, is the object on which we're doing the lookup. This
 can be nullptr: during JIT compilation we sometimes know the Class but not
 the object.*/
    pub type JSMayResolveOp = ::std::option::Option<
        unsafe extern "C" fn(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool,
    >;
    /** Finalize obj, which the garbage collector has determined to be unreachable
 from other live objects or from GC roots.  Obviously, finalizers must never
 store a reference to obj.*/
    pub type JSFinalizeOp = ::std::option::Option<
        unsafe extern "C" fn(gcx: *mut root::JS::GCContext, obj: *mut root::JSObject),
    >;
    /** Function type for trace operation of the class called to enumerate all
 traceable things reachable from obj's private data structure. For each such
 thing, a trace implementation must call JS::TraceEdge on the thing's
 location.

 JSTraceOp implementation can assume that no other threads mutates object
 state. It must not change state of the object or corresponding native
 structures. The only exception for this rule is the case when the embedding
 needs a tight integration with GC. In that case the embedding can check if
 the traversal is a part of the marking phase through calling
 JS_IsGCMarkingTracer and apply a special code like emptying caches or
 marking its native structures.*/
    pub type JSTraceOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, obj: *mut root::JSObject),
    >;
    pub type JSObjectMovedOp = ::std::option::Option<
        unsafe extern "C" fn(obj: *mut root::JSObject, old: *mut root::JSObject) -> usize,
    >;
    pub const JSCLASS_DELAY_METADATA_BUILDER: u32 = 2;
    pub const JSCLASS_IS_WRAPPED_NATIVE: u32 = 4;
    pub const JSCLASS_SLOT0_IS_NSISUPPORTS: u32 = 8;
    pub const JSCLASS_IS_DOMJSCLASS: u32 = 16;
    pub const JSCLASS_HAS_XRAYED_CONSTRUCTOR: u32 = 32;
    pub const JSCLASS_EMULATES_UNDEFINED: u32 = 64;
    pub const JSCLASS_USERBIT1: u32 = 128;
    pub const JSCLASS_RESERVED_SLOTS_SHIFT: usize = 8;
    pub const JSCLASS_RESERVED_SLOTS_WIDTH: u32 = 8;
    pub const JSCLASS_RESERVED_SLOTS_MASK: u32 = 255;
    pub const JSCLASS_HIGH_FLAGS_SHIFT: u32 = 16;
    pub const JSCLASS_INTERNAL_FLAG1: u32 = 65536;
    pub const JSCLASS_IS_GLOBAL: u32 = 131072;
    pub const JSCLASS_INTERNAL_FLAG2: u32 = 262144;
    pub const JSCLASS_IS_PROXY: u32 = 524288;
    pub const JSCLASS_SKIP_NURSERY_FINALIZE: u32 = 1048576;
    pub const JSCLASS_USERBIT2: u32 = 2097152;
    pub const JSCLASS_USERBIT3: u32 = 4194304;
    pub const JSCLASS_BACKGROUND_FINALIZE: u32 = 8388608;
    pub const JSCLASS_FOREGROUND_FINALIZE: u32 = 16777216;
    pub const JSCLASS_GLOBAL_APPLICATION_SLOTS: u32 = 5;
    pub const JSCLASS_GLOBAL_SLOT_COUNT: u32 = 6;
    pub const JSCLASS_GLOBAL_FLAGS: u32 = 132608;
    pub const JSCLASS_CACHED_PROTO_SHIFT: u32 = 25;
    pub const JSCLASS_CACHED_PROTO_MASK: u32 = 127;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSClassOps {
        pub addProperty: root::JSAddPropertyOp,
        pub delProperty: root::JSDeletePropertyOp,
        pub enumerate: root::JSEnumerateOp,
        pub newEnumerate: root::JSNewEnumerateOp,
        pub resolve: root::JSResolveOp,
        pub mayResolve: root::JSMayResolveOp,
        pub finalize: root::JSFinalizeOp,
        pub call: root::JSNative,
        pub construct: root::JSNative,
        pub trace: root::JSTraceOp,
    }
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSClass {
        pub name: *const ::std::os::raw::c_char,
        pub flags: u32,
        pub cOps: *const root::JSClassOps,
        pub spec: *const root::js::ClassSpec,
        pub ext: *const root::js::ClassExtension,
        pub oOps: *const root::js::ObjectOps,
    }
    pub const JSClass_NON_NATIVE: u32 = 262144;
    /** MozRefCountType is Mozilla's reference count type.

 We use the same type to represent the refcount of RefCounted objects
 as well, in order to be able to use the leak detection facilities
 that are implemented by XPCOM.

 Note that this type is not in the mozilla namespace so that it is
 usable for both C and C++ code.*/
    pub type MozRefCountType = usize;
    pub type MozExternalRefCountType = u32;
    pub type JS_ICUAllocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUReallocFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            p: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type JS_ICUFreeFn = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_void,
            p: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSONWriteCallback = ::std::option::Option<
        unsafe extern "C" fn(
            buf: *const u16,
            len: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    /// The property is visible in for/in loops.
    pub const JSPROP_ENUMERATE: u8 = 1;
    /// The property is non-writable.  This flag is only valid for data properties.
    pub const JSPROP_READONLY: u8 = 2;
    /** The property is non-configurable: it can't be deleted, and if it's an
 accessor descriptor, its getter and setter can't be changed.*/
    pub const JSPROP_PERMANENT: u8 = 4;
    /** Resolve hooks and enumerate hooks must pass this flag when calling
 JS_Define* APIs to reify lazily-defined properties.

 JSPROP_RESOLVING is used only with property-defining APIs. It tells the
 engine to skip the resolve hook when performing the lookup at the beginning
 of property definition. This keeps the resolve hook from accidentally
 triggering itself: unchecked recursion.

 For enumerate hooks, triggering the resolve hook would be merely silly, not
 fatal, except in some cases involving non-configurable properties.*/
    pub const JSPROP_RESOLVING: ::std::os::raw::c_uint = 8;
    pub const JSPROP_FLAGS_MASK: ::std::os::raw::c_uint = 15;
    /** Wrapper to relace JSNative for JSPropertySpecs and JSFunctionSpecs. This will
 allow us to pass one JSJitInfo per function with the property/function spec,
 without additional field overhead.*/
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSNativeWrapper {
        pub op: root::JSNative,
        pub info: *const root::JSJitInfo,
    }
    /** Description of a property. JS_DefineProperties and JS_InitClass take arrays
 of these and define many properties at once. JS_PSG, JS_PSGS and JS_PS_END
 are helper macros for defining such arrays.*/
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec {
        pub name: root::JSPropertySpec_Name,
        pub attributes_: u8,
        pub kind_: root::JSPropertySpec_Kind,
        pub u: root::JSPropertySpec_AccessorsOrValue,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSPropertySpec_SelfHostedWrapper {
        pub unused: root::JSNative,
        pub funname: *const ::std::os::raw::c_char,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_ValueWrapper {
        pub type_: root::JSPropertySpec_ValueWrapper_Type,
        pub __bindgen_anon_1: root::JSPropertySpec_ValueWrapper__bindgen_ty_1,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_ValueWrapper_Type {
        String = 0,
        Int32 = 1,
        Double = 2,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_ValueWrapper__bindgen_ty_1 {
        pub string: *const ::std::os::raw::c_char,
        pub int32: i32,
        pub double_: f64,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Accessor {
        pub native: root::JSNativeWrapper,
        pub selfHosted: root::JSPropertySpec_SelfHostedWrapper,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_AccessorsOrValue {
        pub accessors: root::JSPropertySpec_AccessorsOrValue_Accessors,
        pub value: root::JSPropertySpec_ValueWrapper,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSPropertySpec_AccessorsOrValue_Accessors {
        pub getter: root::JSPropertySpec_Accessor,
        pub setter: root::JSPropertySpec_Accessor,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSPropertySpec_Name {
        pub string_: *const ::std::os::raw::c_char,
        pub symbol_: usize,
    }
    #[repr(u8)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSPropertySpec_Kind {
        Value = 0,
        SelfHostedAccessor = 1,
        NativeAccessor = 2,
    }
    impl JSPropertySpec {
        #[inline]
        pub unsafe fn getValue(
            &self,
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool {
            JSPropertySpec_getValue(self, cx, value)
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSFunctionSpec {
        pub name: root::JSFunctionSpec_Name,
        pub call: root::JSNativeWrapper,
        pub nargs: u16,
        pub flags: u16,
        pub selfHostedName: *const ::std::os::raw::c_char,
    }
    pub type JSFunctionSpec_Name = root::JSPropertySpec_Name;
    /** Read structured data from the reader r. This hook is used to read a value
 previously serialized by a call to the WriteStructuredCloneOp hook.

 tag and data are the pair of uint32_t values from the header. The callback
 may use the JS_Read* APIs to read any other relevant parts of the object
 from the reader r. closure is any value passed to the JS_ReadStructuredClone
 function.

 Return the new object on success, or raise an exception and return nullptr on
 error.*/
    pub type ReadStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            tag: u32,
            data: u32,
            closure: *mut ::std::os::raw::c_void,
        ) -> *mut root::JSObject,
    >;
    /** Structured data serialization hook. The engine can write primitive values,
 Objects, Arrays, Dates, RegExps, TypedArrays, ArrayBuffers, Sets, Maps,
 and SharedTypedArrays. Any other type of object requires application support.
 This callback must first use the JS_WriteUint32Pair API to write an object
 header, passing a value greater than JS_SCTAG_USER to the tag parameter.
 Then it can use the JS_Write* APIs to write any other relevant parts of
 the value v to the writer w. closure is any value passed to the
 JS_WriteStructuredClone function.

 Return true on success, false on error. On error, an exception should
 normally be set.*/
    pub type WriteStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    /** This is called when serialization or deserialization encounters an error.
 To follow HTML5, the application must throw a DATA_CLONE_ERR DOMException
 with error set to one of the JS_SCERR_* values.

 Note that if the .reportError field of the JSStructuredCloneCallbacks is
 set (to a function with this signature), then an exception will *not* be
 set on the JSContext when an error is encountered. The clone operation
 will still be aborted and will return false, however, so it is up to the
 embedding to do what it needs to for the error.

 Example: for the DOM, mozilla::dom::StructuredCloneHolder will save away
 the error message during its reportError callback. Then when the overall
 operation fails, it will clear any exception that might have been set
 from other ways to fail and pass the saved error message to
 ErrorResult::ThrowDataCloneError().*/
    pub type StructuredCloneErrorOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            errorid: u32,
            closure: *mut ::std::os::raw::c_void,
            errorMessage: *const ::std::os::raw::c_char,
        ),
    >;
    /** This is called when JS_ReadStructuredClone receives a transferable object
 not known to the engine. If this hook does not exist or returns false, the
 JS engine calls the reportError op if set, otherwise it throws a
 DATA_CLONE_ERR DOM Exception. This method is called before any other
 callback and must return a non-null object in returnObject on success.

 If this readTransfer() hook is called and produces an object, then the
 read() hook will *not* be called for the same object, since the main data
 will only contain a backreference to the already-read object.*/
    pub type ReadTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            r: *mut root::JSStructuredCloneReader,
            aCloneDataPolicy: *const root::JS::CloneDataPolicy,
            tag: u32,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
            returnObject: root::JS::MutableHandleObject,
        ) -> bool,
    >;
    /** Called when JS_WriteStructuredClone receives a transferable object not
 handled by the engine. If this hook does not exist or returns false, the JS
 engine will call the reportError hook or fall back to throwing a
 DATA_CLONE_ERR DOM Exception. This method is called before any other
 callback.

  tag: indicates what type of transferable this is. Must be greater than
       0xFFFF0201 (value of the internal SCTAG_TRANSFER_MAP_PENDING_ENTRY)

  ownership: see TransferableOwnership, above. Used to communicate any needed
       ownership info to the FreeTransferStructuredCloneOp.

  content, extraData: what the ReadTransferStructuredCloneOp will receive*/
    pub type TransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            closure: *mut ::std::os::raw::c_void,
            tag: *mut u32,
            ownership: *mut root::JS::TransferableOwnership,
            content: *mut *mut ::std::os::raw::c_void,
            extraData: *mut u64,
        ) -> bool,
    >;
    /** Called when freeing a transferable handled by the embedding. Note that it
 should never trigger a garbage collection (and will assert in a
 debug build if it does.)

 This callback will be used to release ownership in three situations:

 1. During serialization: an object is Transferred from, then an error is
    encountered later and the incomplete serialization is discarded.

 2. During deserialization: before an object is Transferred to, an error
    is encountered and the incompletely deserialized clone is discarded.

 3. Serialized data that includes Transferring is never deserialized (eg when
    the receiver disappears before reading in the message), and the clone data
 is destroyed.
*/
    pub type FreeTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            tag: u32,
            ownership: root::JS::TransferableOwnership,
            content: *mut ::std::os::raw::c_void,
            extraData: u64,
            closure: *mut ::std::os::raw::c_void,
        ),
    >;
    /** Called when the transferring objects are checked. If this function returns
 false, the serialization ends throwing a DataCloneError exception.*/
    pub type CanTransferStructuredCloneOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            sameProcessScopeRequired: *mut bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    /** Called when a SharedArrayBuffer (including one owned by a Wasm memory object)
 has been processed in context `cx` by structured cloning.  If `receiving` is
 true then the SAB has been received from a channel and a new SAB object has
 been created; if false then an existing SAB has been serialized onto a
 channel.

 If the callback returns false then the clone operation (read or write) will
 signal a failure.*/
    pub type SharedArrayBufferClonedOp = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            receiving: bool,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSStructuredCloneCallbacks {
        pub read: root::ReadStructuredCloneOp,
        pub write: root::WriteStructuredCloneOp,
        pub reportError: root::StructuredCloneErrorOp,
        pub readTransfer: root::ReadTransferStructuredCloneOp,
        pub writeTransfer: root::TransferStructuredCloneOp,
        pub freeTransfer: root::FreeTransferStructuredCloneOp,
        pub canTransfer: root::CanTransferStructuredCloneOp,
        pub sabCloned: root::SharedArrayBufferClonedOp,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum OwnTransferablePolicy {
        /** The buffer owns any Transferables that it might contain, and should
 properly release them upon destruction.*/
        OwnsTransferablesIfAny = 0,
        /** Do not free any Transferables within this buffer when deleting it. This
 is used to mark a clone buffer as containing data from another process,
 and so it can't legitimately contain pointers. If the buffer claims to
 have transferables, it's a bug or an attack. This is also used for
 abandon(), where a buffer still contains raw data but the ownership has
 been given over to some other entity.*/
        IgnoreTransferablesIfAny = 1,
        /** A buffer that cannot contain Transferables at all. This usually means
 the buffer is empty (not yet filled in, or having been cleared).*/
        NoTransferables = 2,
    }
    /** JSStructuredCloneData represents structured clone data together with the
 information needed to read/write/transfer/free the records within it, in the
 form of a set of callbacks.*/
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSStructuredCloneData {
        pub bufList_: root::JSStructuredCloneData_BufferList,
        pub scope_: root::JS::StructuredCloneScope,
        pub callbacks_: *const root::JSStructuredCloneCallbacks,
        pub closure_: *mut ::std::os::raw::c_void,
        pub ownTransferables_: root::OwnTransferablePolicy,
        pub refsHeld_: root::js::SharedArrayRawBufferRefs,
    }
    pub type JSStructuredCloneData_BufferList = [u32; 11usize];
    pub type JSStructuredCloneData_Iterator = root::IterImpl;
    pub const JSStructuredCloneData_kStandardCapacity: usize = 4096;
    impl JSStructuredCloneData {
        #[inline]
        pub unsafe fn discardTransferables(&mut self) {
            JSStructuredCloneData_discardTransferables(self)
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            JSStructuredCloneData_JSStructuredCloneData_destructor(self)
        }
    }
    /** The C-style API calls to read and write structured clones are fragile --
 they rely on the caller to properly handle ownership of the clone data, and
 the handling of the input data as well as the interpretation of the contents
 of the clone buffer are dependent on the callbacks passed in. If you
 serialize and deserialize with different callbacks, the results are
 questionable.

 JSAutoStructuredCloneBuffer wraps things up in an RAII class for data
 management, and uses the same callbacks for both writing and reading
 (serializing and deserializing).*/
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSAutoStructuredCloneBuffer {
        pub data_: root::JSStructuredCloneData,
        pub version_: u32,
    }
    impl JSAutoStructuredCloneBuffer {
        #[inline]
        pub unsafe fn clear(&mut self) {
            JSAutoStructuredCloneBuffer_clear(self)
        }
        #[inline]
        pub unsafe fn adopt(
            &mut self,
            data: *mut root::JSStructuredCloneData,
            version: u32,
            callbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) {
            JSAutoStructuredCloneBuffer_adopt(self, data, version, callbacks, closure)
        }
        #[inline]
        pub unsafe fn giveTo(&mut self, data: *mut root::JSStructuredCloneData) {
            JSAutoStructuredCloneBuffer_giveTo(self, data)
        }
        #[inline]
        pub unsafe fn read(
            &mut self,
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool {
            JSAutoStructuredCloneBuffer_read(
                self,
                cx,
                vp,
                cloneDataPolicy,
                optionalCallbacks,
                closure,
            )
        }
        #[inline]
        pub unsafe fn write(
            &mut self,
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool {
            JSAutoStructuredCloneBuffer_write(self, cx, v, optionalCallbacks, closure)
        }
        #[inline]
        pub unsafe fn write1(
            &mut self,
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            transferable: root::JS::HandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool {
            JSAutoStructuredCloneBuffer_write1(
                self,
                cx,
                v,
                transferable,
                cloneDataPolicy,
                optionalCallbacks,
                closure,
            )
        }
        #[inline]
        pub unsafe fn new(other: *mut root::JSAutoStructuredCloneBuffer) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            JSAutoStructuredCloneBuffer_JSAutoStructuredCloneBuffer(
                __bindgen_tmp.as_mut_ptr(),
                other,
            );
            __bindgen_tmp.assume_init()
        }
    }
    /** A class, expected to be passed by value, which represents the CallArgs for a
 JSJitGetterOp.*/
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitGetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    /** A class, expected to be passed by value, which represents the CallArgs for a
 JSJitSetterOp.*/
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitSetterCallArgs {
        pub _base: root::JS::MutableHandle<root::JS::Value>,
    }
    pub type JSJitMethodCallArgs_Base = [u32; 3usize];
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitMethodCallArgsTraits {
        pub _address: u8,
    }
    pub const JSJitMethodCallArgsTraits_offsetOfArgv: usize = 0;
    pub const JSJitMethodCallArgsTraits_offsetOfArgc: usize = 4;
    pub type JSJitGetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitGetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitSetterOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: root::JSJitSetterCallArgs,
        ) -> bool,
    >;
    pub type JSJitMethodOp = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::Handle<*mut root::JSObject>,
            arg3: *mut ::std::os::raw::c_void,
            arg4: *const root::JSJitMethodCallArgs,
        ) -> bool,
    >;
    /** This struct contains metadata passed from the DOM to the JS Engine for JIT
 optimizations on DOM property accessors.

 Eventually, this should be made available to general JSAPI users as *not*
 experimental and *not* a friend API, but we're not ready to do so yet.*/
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSJitInfo {
        pub __bindgen_anon_1: root::JSJitInfo__bindgen_ty_1,
        pub __bindgen_anon_2: root::JSJitInfo__bindgen_ty_2,
        pub __bindgen_anon_3: root::JSJitInfo__bindgen_ty_3,
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_OpType {
        Getter = 0,
        Setter = 1,
        Method = 2,
        StaticMethod = 3,
        InlinableNative = 4,
        TrampolineNative = 5,
        IgnoresReturnValueNative = 6,
        OpTypeCount = 7,
    }
    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_ArgType {
        String = 1,
        Integer = 2,
        Double = 4,
        Boolean = 8,
        Object = 16,
        Null = 32,
        Numeric = 6,
        Primitive = 47,
        ObjectOrNull = 48,
        Any = 63,
        ArgTypeListEnd = -2147483648,
    }
    #[repr(u32)]
    /** An enum that describes what this getter/setter/method aliases.  This
 determines what things can be hoisted past this call, and if this
 call is movable what it can be hoisted past.*/
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitInfo_AliasSet {
        /** Alias nothing: a constant value, getting it can't affect any other
 values, nothing can affect it.*/
        AliasNone = 0,
        /** Alias things that can modify the DOM but nothing else.  Doing the
 call can't affect the behavior of any other function.*/
        AliasDOMSets = 1,
        /** Alias the world.  Calling this can change arbitrary values anywhere
 in the system.  Most things fall in this bucket.*/
        AliasEverything = 2,
        /// Must be last.
        AliasSetCount = 3,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_1 {
        pub getter: root::JSJitGetterOp,
        pub setter: root::JSJitSetterOp,
        pub method: root::JSJitMethodOp,
        /// A DOM static method, used for Promise wrappers
        pub staticMethod: root::JSNative,
        pub ignoresReturnValueMethod: root::JSNative,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_2 {
        pub protoID: u16,
        pub inlinableNative: root::js::jit::InlinableNative,
        pub trampolineNative: root::js::jit::TrampolineNative,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union JSJitInfo__bindgen_ty_3 {
        pub depth: u16,
        pub nativeOp: u16,
    }
    pub const JSJitInfo_OpTypeBits: usize = 4;
    pub const JSJitInfo_AliasSetBits: usize = 4;
    pub const JSJitInfo_ReturnTypeBits: usize = 8;
    pub const JSJitInfo_SlotIndexBits: usize = 10;
    pub const JSJitInfo_maxSlotIndex: usize = 1023;
    impl JSJitInfo {
        #[inline]
        pub fn type_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_type_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn aliasSet_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_aliasSet_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(4usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn returnType_(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_returnType_(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn isInfallible(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isInfallible(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isMovable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isMovable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(17usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isEliminatable(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isEliminatable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isAlwaysInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isAlwaysInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(19usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isLazilyCachedInSlot(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isLazilyCachedInSlot(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(20usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isTypedMethod(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_isTypedMethod(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(21usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn slotIndex(&self) -> u32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
        }
        #[inline]
        pub fn set_slotIndex(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(22usize, 10u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            type_: u32,
            aliasSet_: u32,
            returnType_: u32,
            isInfallible: u32,
            isMovable: u32,
            isEliminatable: u32,
            isAlwaysInSlot: u32,
            isLazilyCachedInSlot: u32,
            isTypedMethod: u32,
            slotIndex: u32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit
                .set(
                    0usize,
                    4u8,
                    {
                        let type_: u32 = unsafe { ::std::mem::transmute(type_) };
                        type_ as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    4usize,
                    4u8,
                    {
                        let aliasSet_: u32 = unsafe { ::std::mem::transmute(aliasSet_) };
                        aliasSet_ as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    8usize,
                    8u8,
                    {
                        let returnType_: u32 = unsafe {
                            ::std::mem::transmute(returnType_)
                        };
                        returnType_ as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    16usize,
                    1u8,
                    {
                        let isInfallible: u32 = unsafe {
                            ::std::mem::transmute(isInfallible)
                        };
                        isInfallible as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    17usize,
                    1u8,
                    {
                        let isMovable: u32 = unsafe { ::std::mem::transmute(isMovable) };
                        isMovable as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    18usize,
                    1u8,
                    {
                        let isEliminatable: u32 = unsafe {
                            ::std::mem::transmute(isEliminatable)
                        };
                        isEliminatable as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    19usize,
                    1u8,
                    {
                        let isAlwaysInSlot: u32 = unsafe {
                            ::std::mem::transmute(isAlwaysInSlot)
                        };
                        isAlwaysInSlot as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    20usize,
                    1u8,
                    {
                        let isLazilyCachedInSlot: u32 = unsafe {
                            ::std::mem::transmute(isLazilyCachedInSlot)
                        };
                        isLazilyCachedInSlot as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    21usize,
                    1u8,
                    {
                        let isTypedMethod: u32 = unsafe {
                            ::std::mem::transmute(isTypedMethod)
                        };
                        isTypedMethod as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    22usize,
                    10u8,
                    {
                        let slotIndex: u32 = unsafe { ::std::mem::transmute(slotIndex) };
                        slotIndex as u64
                    },
                );
            __bindgen_bitfield_unit
        }
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct JSTypedMethodJitInfo {
        pub base: root::JSJitInfo,
        pub argTypes: *const root::JSJitInfo_ArgType,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSErrNum {
        JSMSG_NOT_AN_ERROR = 0,
        JSMSG_NOT_DEFINED = 1,
        JSMSG_MORE_ARGS_NEEDED = 2,
        JSMSG_INCOMPATIBLE_PROTO = 3,
        JSMSG_INCOMPATIBLE_PROTO2 = 4,
        JSMSG_NO_CONSTRUCTOR = 5,
        JSMSG_BAD_SORT_ARG = 6,
        JSMSG_BAD_TOSORTED_ARG = 7,
        JSMSG_BAD_TYPEDARRAY_SORT_ARG = 8,
        JSMSG_READ_ONLY = 9,
        JSMSG_CANT_DELETE = 10,
        JSMSG_CANT_TRUNCATE_ARRAY = 11,
        JSMSG_NOT_FUNCTION = 12,
        JSMSG_PROPERTY_NOT_CALLABLE = 13,
        JSMSG_NOT_CONSTRUCTOR = 14,
        JSMSG_BOGUS_CONSTRUCTOR = 15,
        JSMSG_CANT_CONVERT_TO = 16,
        JSMSG_TOPRIMITIVE_NOT_CALLABLE = 17,
        JSMSG_TOPRIMITIVE_RETURNED_OBJECT = 18,
        JSMSG_NO_PROPERTIES = 19,
        JSMSG_PROPERTY_FAIL = 20,
        JSMSG_PROPERTY_FAIL_EXPR = 21,
        JSMSG_BAD_REGEXP_FLAG = 22,
        JSMSG_INVALID_DATA_VIEW_LENGTH = 23,
        JSMSG_OFFSET_LARGER_THAN_FILESIZE = 24,
        JSMSG_OFFSET_OUT_OF_BUFFER = 25,
        JSMSG_OFFSET_OUT_OF_DATAVIEW = 26,
        JSMSG_SPREAD_TOO_LARGE = 27,
        JSMSG_BAD_WEAKMAP_KEY = 28,
        JSMSG_WEAKMAP_KEY_CANT_BE_HELD_WEAKLY = 29,
        JSMSG_WEAKSET_VAL_CANT_BE_HELD_WEAKLY = 30,
        JSMSG_WEAKMAP_KEY_MUST_BE_AN_OBJECT = 31,
        JSMSG_WEAKSET_VAL_MUST_BE_AN_OBJECT = 32,
        JSMSG_BAD_GETTER_OR_SETTER = 33,
        JSMSG_BAD_ARRAY_LENGTH = 34,
        JSMSG_SOURCE_ARRAY_TOO_LONG = 35,
        JSMSG_PREV_DECLARATION = 36,
        JSMSG_REDECLARED_VAR = 37,
        JSMSG_MISMATCHED_PLACEMENT = 38,
        JSMSG_UNDECLARED_VAR = 39,
        JSMSG_GET_MISSING_PRIVATE = 40,
        JSMSG_SET_MISSING_PRIVATE = 41,
        JSMSG_GETTER_ONLY = 42,
        JSMSG_PRIVATE_SETTER_ONLY = 43,
        JSMSG_OVERWRITING_ACCESSOR = 44,
        JSMSG_INVALID_MAP_ITERABLE = 45,
        JSMSG_NESTING_GENERATOR = 46,
        JSMSG_INCOMPATIBLE_METHOD = 47,
        JSMSG_BAD_SURROGATE_CHAR = 48,
        JSMSG_UTF8_CHAR_TOO_LARGE = 49,
        JSMSG_MALFORMED_UTF8_CHAR = 50,
        JSMSG_BUILTIN_CTOR_NO_NEW = 51,
        JSMSG_EMPTY_ARRAY_REDUCE = 52,
        JSMSG_EMPTY_ITERATOR_REDUCE = 53,
        JSMSG_UNEXPECTED_TYPE = 54,
        JSMSG_MISSING_FUN_ARG = 55,
        JSMSG_OBJECT_REQUIRED = 56,
        JSMSG_OBJECT_REQUIRED_ARG = 57,
        JSMSG_OBJECT_REQUIRED_PROP_DESC = 58,
        JSMSG_OBJECT_REQUIRED_RET_OWNKEYS = 59,
        JSMSG_WRONG_TYPE_ARG = 60,
        JSMSG_SET_NON_OBJECT_RECEIVER = 61,
        JSMSG_INVALID_DESCRIPTOR = 62,
        JSMSG_OBJECT_NOT_EXTENSIBLE = 63,
        JSMSG_CANT_DEFINE_PROP_OBJECT_NOT_EXTENSIBLE = 64,
        JSMSG_CANT_REDEFINE_PROP = 65,
        JSMSG_CANT_REDEFINE_ARRAY_LENGTH = 66,
        JSMSG_CANT_DEFINE_PAST_ARRAY_LENGTH = 67,
        JSMSG_BAD_GET_SET_FIELD = 68,
        JSMSG_THROW_TYPE_ERROR = 69,
        JSMSG_NOT_EXPECTED_TYPE = 70,
        JSMSG_NOT_ITERABLE = 71,
        JSMSG_ALREADY_HAS_PRAGMA = 72,
        JSMSG_GET_ITER_RETURNED_PRIMITIVE = 73,
        JSMSG_ITER_METHOD_RETURNED_PRIMITIVE = 74,
        JSMSG_CANT_SET_PROTO = 75,
        JSMSG_CANT_SET_PROTO_OF = 76,
        JSMSG_CANT_SET_PROTO_CYCLE = 77,
        JSMSG_INVALID_ARG_TYPE = 78,
        JSMSG_TERMINATED = 79,
        JSMSG_CANT_CALL_CLASS_CONSTRUCTOR = 80,
        JSMSG_UNINITIALIZED_THIS = 81,
        JSMSG_BAD_DERIVED_RETURN = 82,
        JSMSG_BAD_HERITAGE = 83,
        JSMSG_NOT_OBJORNULL = 84,
        JSMSG_CONSTRUCTOR_DISABLED = 85,
        JSMSG_NO_DISPOSE_IN_USING = 86,
        JSMSG_DISPOSABLE_NOT_OBJ = 87,
        JSMSG_JSON_BAD_PARSE = 88,
        JSMSG_JSON_CYCLIC_VALUE = 89,
        JSMSG_JSON_RAW_EMPTY = 90,
        JSMSG_JSON_RAW_ARRAY_OR_OBJECT = 91,
        JSMSG_JSON_RAW_WHITESPACE = 92,
        JSMSG_ASSIGN_TO_CALL = 93,
        JSMSG_ASSIGN_TO_PRIVATE_METHOD = 94,
        JSMSG_BAD_INSTANCEOF_RHS = 95,
        JSMSG_BAD_PROTOTYPE = 96,
        JSMSG_IN_NOT_OBJECT = 97,
        JSMSG_IN_STRING = 98,
        JSMSG_TOO_MANY_CON_SPREADARGS = 99,
        JSMSG_TOO_MANY_FUN_SPREADARGS = 100,
        JSMSG_UNINITIALIZED_LEXICAL = 101,
        JSMSG_BAD_CONST_ASSIGN = 102,
        JSMSG_CANT_DECLARE_GLOBAL_BINDING = 103,
        JSMSG_INVALID_DATE = 104,
        JSMSG_BAD_TOISOSTRING_PROP = 105,
        JSMSG_BAD_URI = 106,
        JSMSG_INVALID_NORMALIZE_FORM = 107,
        JSMSG_NEGATIVE_REPETITION_COUNT = 108,
        JSMSG_NOT_A_CODEPOINT = 109,
        JSMSG_RESULTING_STRING_TOO_LARGE = 110,
        JSMSG_FLAGS_UNDEFINED_OR_NULL = 111,
        JSMSG_REQUIRES_GLOBAL_REGEXP = 112,
        JSMSG_BAD_RADIX = 113,
        JSMSG_PRECISION_RANGE = 114,
        JSMSG_BAD_APPLY_ARGS = 115,
        JSMSG_DEPRECATED_USAGE = 116,
        JSMSG_NO_REST_NAME = 117,
        JSMSG_PARAMETER_AFTER_REST = 118,
        JSMSG_TOO_MANY_ARGUMENTS = 119,
        JSMSG_CSP_BLOCKED_EVAL = 120,
        JSMSG_CSP_BLOCKED_FUNCTION = 121,
        JSMSG_CSP_BLOCKED_WASM = 122,
        JSMSG_CSP_BLOCKED_SHADOWREALM = 123,
        JSMSG_ACCESSOR_DEF_DENIED = 124,
        JSMSG_DEAD_OBJECT = 125,
        JSMSG_OBJECT_ACCESS_DENIED = 126,
        JSMSG_PROPERTY_ACCESS_DENIED = 127,
        JSMSG_CANT_CLONE_OBJECT = 128,
        JSMSG_CANT_OPEN = 129,
        JSMSG_SUPPORT_NOT_ENABLED = 130,
        JSMSG_USER_DEFINED_ERROR = 131,
        JSMSG_ALLOC_OVERFLOW = 132,
        JSMSG_BAD_BYTECODE = 133,
        JSMSG_BUFFER_TOO_SMALL = 134,
        JSMSG_BYTECODE_TOO_BIG = 135,
        JSMSG_NEED_DIET = 136,
        JSMSG_OUT_OF_MEMORY = 137,
        JSMSG_OVER_RECURSED = 138,
        JSMSG_TOO_DEEP = 139,
        JSMSG_UNCAUGHT_EXCEPTION = 140,
        JSMSG_UNKNOWN_FORMAT = 141,
        JSMSG_UNSAFE_FILENAME = 142,
        JSMSG_ACCESSOR_WRONG_ARGS = 143,
        JSMSG_ARRAY_INIT_TOO_BIG = 144,
        JSMSG_AS_AFTER_IMPORT_STAR = 145,
        JSMSG_AS_AFTER_RESERVED_WORD = 146,
        JSMSG_AS_AFTER_STRING = 147,
        JSMSG_AWAIT_IN_PARAMETER = 148,
        JSMSG_AWAIT_OUTSIDE_ASYNC = 149,
        JSMSG_AWAIT_OUTSIDE_ASYNC_OR_MODULE = 150,
        JSMSG_TOP_LEVEL_AWAIT_NOT_SUPPORTED = 151,
        JSMSG_BAD_ARROW_ARGS = 152,
        JSMSG_BAD_COALESCE_MIXING = 153,
        JSMSG_BAD_CONST_DECL = 154,
        JSMSG_BAD_CONTINUE = 155,
        JSMSG_BAD_DESTRUCT_ASS = 156,
        JSMSG_BAD_DESTRUCT_TARGET = 157,
        JSMSG_BAD_DESTRUCT_PARENS = 158,
        JSMSG_BAD_DESTRUCT_DECL = 159,
        JSMSG_BAD_DUP_ARGS = 160,
        JSMSG_BAD_FOR_LEFTSIDE = 161,
        JSMSG_LEXICAL_DECL_DEFINES_LET = 162,
        JSMSG_BAD_STARTING_FOROF_LHS = 163,
        JSMSG_BAD_INCOP_OPERAND = 164,
        JSMSG_BAD_LEFTSIDE_OF_ASS = 165,
        JSMSG_BAD_LOCAL_STRING_EXPORT = 166,
        JSMSG_BAD_METHOD_DEF = 167,
        JSMSG_BAD_POW_LEFTSIDE = 168,
        JSMSG_BAD_PROP_ID = 169,
        JSMSG_BAD_RETURN_OR_YIELD = 170,
        JSMSG_BAD_STRICT_ASSIGN = 171,
        JSMSG_BAD_STRICT_ASSIGN_ARGUMENTS = 172,
        JSMSG_BAD_STRICT_ASSIGN_EVAL = 173,
        JSMSG_BAD_SWITCH = 174,
        JSMSG_BAD_SUPER = 175,
        JSMSG_BAD_SUPERPROP = 176,
        JSMSG_BAD_SUPERPRIVATE = 177,
        JSMSG_BAD_SUPERCALL = 178,
        JSMSG_BAD_ARGUMENTS = 179,
        JSMSG_BRACKET_AFTER_LIST = 180,
        JSMSG_BRACKET_IN_INDEX = 181,
        JSMSG_BRACKET_OPENED = 182,
        JSMSG_CATCH_IDENTIFIER = 183,
        JSMSG_CATCH_OR_FINALLY = 184,
        JSMSG_CATCH_WITHOUT_TRY = 185,
        JSMSG_COLON_AFTER_CASE = 186,
        JSMSG_COLON_AFTER_ID = 187,
        JSMSG_COLON_IN_COND = 188,
        JSMSG_COMP_PROP_UNTERM_EXPR = 189,
        JSMSG_CURLY_AFTER_BODY = 190,
        JSMSG_CURLY_OPENED = 191,
        JSMSG_CURLY_AFTER_CATCH = 192,
        JSMSG_CURLY_AFTER_FINALLY = 193,
        JSMSG_CURLY_AFTER_LIST = 194,
        JSMSG_CURLY_AFTER_TRY = 195,
        JSMSG_CURLY_BEFORE_BODY = 196,
        JSMSG_CURLY_BEFORE_CATCH = 197,
        JSMSG_CURLY_BEFORE_CLASS = 198,
        JSMSG_CURLY_BEFORE_FINALLY = 199,
        JSMSG_CURLY_BEFORE_SWITCH = 200,
        JSMSG_CURLY_BEFORE_TRY = 201,
        JSMSG_CURLY_IN_COMPOUND = 202,
        JSMSG_DECLARATION_AFTER_EXPORT = 203,
        JSMSG_DECLARATION_AFTER_IMPORT = 204,
        JSMSG_DEPRECATED_DELETE_OPERAND = 205,
        JSMSG_DEPRECATED_OCTAL_LITERAL = 206,
        JSMSG_DEPRECATED_OCTAL_ESCAPE = 207,
        JSMSG_DEPRECATED_EIGHT_OR_NINE_ESCAPE = 208,
        JSMSG_DEPRECATED_PRAGMA = 209,
        JSMSG_DUPLICATE_EXPORT_NAME = 210,
        JSMSG_DUPLICATE_FORMAL = 211,
        JSMSG_DUPLICATE_LABEL = 212,
        JSMSG_DUPLICATE_PROPERTY = 213,
        JSMSG_DUPLICATE_PROTO_PROPERTY = 214,
        JSMSG_EQUAL_AS_ASSIGN = 215,
        JSMSG_EXPORT_DECL_AT_TOP_LEVEL = 216,
        JSMSG_FINALLY_WITHOUT_TRY = 217,
        JSMSG_FORBIDDEN_AS_STATEMENT = 218,
        JSMSG_FOR_AWAIT_OUTSIDE_ASYNC = 219,
        JSMSG_FROM_AFTER_IMPORT_CLAUSE = 220,
        JSMSG_FROM_AFTER_EXPORT_STAR = 221,
        JSMSG_GARBAGE_AFTER_INPUT = 222,
        JSMSG_IDSTART_AFTER_NUMBER = 223,
        JSMSG_BAD_ESCAPE = 224,
        JSMSG_MISSING_PRIVATE_NAME = 225,
        JSMSG_PRIVATE_DELETE = 226,
        JSMSG_MISSING_PRIVATE_DECL = 227,
        JSMSG_ILLEGAL_CHARACTER = 228,
        JSMSG_IMPORT_META_OUTSIDE_MODULE = 229,
        JSMSG_IMPORT_DECL_AT_TOP_LEVEL = 230,
        JSMSG_OF_AFTER_FOR_LOOP_DECL = 231,
        JSMSG_IN_AFTER_LEXICAL_FOR_DECL = 232,
        JSMSG_INVALID_FOR_IN_DECL_WITH_INIT = 233,
        JSMSG_INVALID_ID = 234,
        JSMSG_SEPARATOR_IN_ZERO_PREFIXED_NUMBER = 235,
        JSMSG_LABEL_NOT_FOUND = 236,
        JSMSG_GENERATOR_LABEL = 237,
        JSMSG_FUNCTION_LABEL = 238,
        JSMSG_SLOPPY_FUNCTION_LABEL = 239,
        JSMSG_LINE_BREAK_AFTER_THROW = 240,
        JSMSG_MALFORMED_ESCAPE = 241,
        JSMSG_MISSING_BINARY_DIGITS = 242,
        JSMSG_MISSING_EXPONENT = 243,
        JSMSG_MISSING_EXPR_AFTER_THROW = 244,
        JSMSG_MISSING_FORMAL = 245,
        JSMSG_MISSING_HEXDIGITS = 246,
        JSMSG_MISSING_OCTAL_DIGITS = 247,
        JSMSG_NUMBER_END_WITH_UNDERSCORE = 248,
        JSMSG_NUMBER_MULTIPLE_ADJACENT_UNDERSCORES = 249,
        JSMSG_MODULE_SPEC_AFTER_FROM = 250,
        JSMSG_NAME_AFTER_DOT = 251,
        JSMSG_NAMED_IMPORTS_OR_NAMESPACE_IMPORT = 252,
        JSMSG_NO_BINDING_NAME = 253,
        JSMSG_NO_EXPORT_NAME = 254,
        JSMSG_NO_IMPORT_NAME = 255,
        JSMSG_NO_VARIABLE_NAME = 256,
        JSMSG_PAREN_AFTER_ARGS = 257,
        JSMSG_PAREN_AFTER_CATCH = 258,
        JSMSG_PAREN_AFTER_COND = 259,
        JSMSG_PAREN_AFTER_FOR = 260,
        JSMSG_PAREN_AFTER_FORMAL = 261,
        JSMSG_PAREN_AFTER_FOR_CTRL = 262,
        JSMSG_PAREN_AFTER_SWITCH = 263,
        JSMSG_PAREN_AFTER_WITH = 264,
        JSMSG_PAREN_BEFORE_CATCH = 265,
        JSMSG_PAREN_BEFORE_COND = 266,
        JSMSG_PAREN_BEFORE_FORMAL = 267,
        JSMSG_PAREN_BEFORE_SWITCH = 268,
        JSMSG_PAREN_BEFORE_WITH = 269,
        JSMSG_PAREN_IN_PAREN = 270,
        JSMSG_PAREN_AFTER_DECORATOR = 271,
        JSMSG_RC_AFTER_EXPORT_SPEC_LIST = 272,
        JSMSG_RC_AFTER_IMPORT_SPEC_LIST = 273,
        JSMSG_RESERVED_ID = 274,
        JSMSG_REST_WITH_COMMA = 275,
        JSMSG_REST_WITH_DEFAULT = 276,
        JSMSG_SELFHOSTED_METHOD_CALL = 277,
        JSMSG_SELFHOSTED_LEXICAL = 278,
        JSMSG_SELFHOSTED_CLASS = 279,
        JSMSG_SEMI_AFTER_FOR_COND = 280,
        JSMSG_SEMI_AFTER_FOR_INIT = 281,
        JSMSG_SOURCE_TOO_LONG = 282,
        JSMSG_STMT_AFTER_RETURN = 283,
        JSMSG_STRICT_CODE_WITH = 284,
        JSMSG_STRICT_NON_SIMPLE_PARAMS = 285,
        JSMSG_TEMPLSTR_UNTERM_EXPR = 286,
        JSMSG_TOO_MANY_CASES = 287,
        JSMSG_TOO_MANY_CON_ARGS = 288,
        JSMSG_TOO_MANY_DEFAULTS = 289,
        JSMSG_TOO_MANY_FUN_ARGS = 290,
        JSMSG_TOO_MANY_LOCALS = 291,
        JSMSG_TOO_MANY_RESUME_INDEXES = 292,
        JSMSG_TOUGH_BREAK = 293,
        JSMSG_UNEXPECTED_TOKEN = 294,
        JSMSG_UNEXPECTED_TOKEN_NO_EXPECT = 295,
        JSMSG_UNEXPECTED_PARAMLIST_END = 296,
        JSMSG_UNNAMED_CLASS_STMT = 297,
        JSMSG_UNNAMED_FUNCTION_STMT = 298,
        JSMSG_UNPAIRED_SURROGATE_EXPORT = 299,
        JSMSG_UNTERMINATED_COMMENT = 300,
        JSMSG_UNTERMINATED_REGEXP = 301,
        JSMSG_UNTERMINATED_STATIC_CLASS_BLOCK = 302,
        JSMSG_EOF_BEFORE_END_OF_LITERAL = 303,
        JSMSG_EOL_BEFORE_END_OF_STRING = 304,
        JSMSG_EOF_IN_ESCAPE_IN_LITERAL = 305,
        JSMSG_USE_ASM_DIRECTIVE_FAIL = 306,
        JSMSG_VAR_HIDES_ARG = 307,
        JSMSG_WHILE_AFTER_DO = 308,
        JSMSG_YIELD_IN_PARAMETER = 309,
        JSMSG_YIELD_OUTSIDE_GENERATOR = 310,
        JSMSG_BAD_COLUMN_NUMBER = 311,
        JSMSG_BAD_LINE_NUMBER = 312,
        JSMSG_BAD_NEWTARGET = 313,
        JSMSG_BAD_NEW_OPTIONAL = 314,
        JSMSG_BAD_OPTIONAL_TEMPLATE = 315,
        JSMSG_IMPORT_ASSERTIONS_NOT_SUPPORTED = 316,
        JSMSG_ILLEGAL_PRIVATE_FIELD = 317,
        JSMSG_ILLEGAL_PRIVATE_NAME = 318,
        JSMSG_INVALID_PRIVATE_NAME_PRECEDENCE = 319,
        JSMSG_INVALID_PRIVATE_NAME_IN_UNARY_EXPR = 320,
        JSMSG_ILLEGAL_PRIVATE_EXOTIC = 321,
        JSMSG_PRIVATE_FIELD_DOUBLE = 322,
        JSMSG_PRIVATE_BRAND_DOUBLE = 323,
        JSMSG_CURLY_AFTER_ASSERT = 324,
        JSMSG_DUPLICATE_ASSERT_KEY = 325,
        JSMSG_COLON_AFTER_ASSERT_KEY = 326,
        JSMSG_ASSERT_STRING_LITERAL = 327,
        JSMSG_ASSERT_KEY_EXPECTED = 328,
        JSMSG_DECORATOR_NAME_EXPECTED = 329,
        JSMSG_CLASS_EXPECTED = 330,
        JSMSG_NO_IN_WITH_USING = 331,
        JSMSG_USING_OUTSIDE_BLOCK_OR_MODULE = 332,
        JSMSG_BAD_LEADING_UTF8_UNIT = 333,
        JSMSG_NOT_ENOUGH_CODE_UNITS = 334,
        JSMSG_BAD_TRAILING_UTF8_UNIT = 335,
        JSMSG_FORBIDDEN_UTF8_CODE_POINT = 336,
        JSMSG_BAD_CODE_UNITS = 337,
        JSMSG_CANT_CONVERT_TO_NARROW = 338,
        JSMSG_CANT_CONVERT_TO_WIDE = 339,
        JSMSG_CANT_CONVERT_WIDE_TO_UTF8 = 340,
        JSMSG_CANT_CONVERT_UTF8_TO_WIDE = 341,
        JSMSG_SMOOSH_COMPILE_ERROR = 342,
        JSMSG_SMOOSH_UNIMPLEMENTED = 343,
        JSMSG_USE_ASM_TYPE_FAIL = 344,
        JSMSG_USE_ASM_LINK_FAIL = 345,
        JSMSG_USE_ASM_TYPE_OK = 346,
        JSMSG_USE_ASM_TYPE_OK_NO_TIME = 347,
        JSMSG_WASM_VERBOSE = 348,
        JSMSG_WASM_COMPILE_WARNING = 349,
        JSMSG_WASM_HUGE_MEMORY_FAILED = 350,
        JSMSG_WASM_COMPILE_ERROR = 351,
        JSMSG_WASM_BAD_IMPORT_TYPE = 352,
        JSMSG_WASM_BAD_IMPORT_SIG = 353,
        JSMSG_WASM_BAD_TAG_SIG = 354,
        JSMSG_WASM_BAD_IMP_INDEX = 355,
        JSMSG_WASM_BAD_IMP_SIZE = 356,
        JSMSG_WASM_BAD_IMP_MAX = 357,
        JSMSG_WASM_IMP_SHARED_REQD = 358,
        JSMSG_WASM_IMP_SHARED_BANNED = 359,
        JSMSG_WASM_NO_SHMEM_LINK = 360,
        JSMSG_WASM_NO_MEM64_LINK = 361,
        JSMSG_WASM_BAD_GLOB_MUT_LINK = 362,
        JSMSG_WASM_BAD_GLOB_TYPE_LINK = 363,
        JSMSG_WASM_BAD_TBL_TYPE_LINK = 364,
        JSMSG_WASM_IND_CALL_TO_NULL = 365,
        JSMSG_WASM_IND_CALL_BAD_SIG = 366,
        JSMSG_WASM_UNREACHABLE = 367,
        JSMSG_WASM_INTEGER_OVERFLOW = 368,
        JSMSG_WASM_INVALID_CONVERSION = 369,
        JSMSG_WASM_INT_DIVIDE_BY_ZERO = 370,
        JSMSG_WASM_OUT_OF_BOUNDS = 371,
        JSMSG_WASM_UNALIGNED_ACCESS = 372,
        JSMSG_WASM_WAKE_OVERFLOW = 373,
        JSMSG_WASM_DEREF_NULL = 374,
        JSMSG_WASM_BAD_CAST = 375,
        JSMSG_WASM_MEM_IMP_LIMIT = 376,
        JSMSG_WASM_TABLE_IMP_LIMIT = 377,
        JSMSG_WASM_ARRAY_IMP_LIMIT = 378,
        JSMSG_WASM_ARRAY_NEW_ELEM_NOT_IMPLEMENTED = 379,
        JSMSG_WASM_BAD_RANGE = 380,
        JSMSG_WASM_BAD_GROW = 381,
        JSMSG_WASM_TABLE_OUT_OF_BOUNDS = 382,
        JSMSG_WASM_BAD_ENFORCE_RANGE = 383,
        JSMSG_WASM_BAD_BUF_ARG = 384,
        JSMSG_WASM_BAD_MOD_ARG = 385,
        JSMSG_WASM_BAD_BUF_MOD_ARG = 386,
        JSMSG_WASM_BAD_DESC_ARG = 387,
        JSMSG_WASM_BAD_IMPORT_ARG = 388,
        JSMSG_WASM_BAD_IMPORT_FIELD = 389,
        JSMSG_WASM_BAD_REF_NONNULLABLE_VALUE = 390,
        JSMSG_WASM_BAD_FUNCREF_VALUE = 391,
        JSMSG_WASM_BAD_NULL_EXNREF_VALUE = 392,
        JSMSG_WASM_BAD_NULL_EXTERNREF_VALUE = 393,
        JSMSG_WASM_BAD_NULL_FUNCREF_VALUE = 394,
        JSMSG_WASM_BAD_NULL_ANYREF_VALUE = 395,
        JSMSG_WASM_BAD_EQREF_VALUE = 396,
        JSMSG_WASM_BAD_I31REF_VALUE = 397,
        JSMSG_WASM_BAD_STRUCTREF_VALUE = 398,
        JSMSG_WASM_BAD_ARRAYREF_VALUE = 399,
        JSMSG_WASM_BAD_TYPEREF_VALUE = 400,
        JSMSG_WASM_BAD_VAL_TYPE = 401,
        JSMSG_WASM_BAD_STRING_VAL_TYPE = 402,
        JSMSG_WASM_BAD_STRING_IDX_TYPE = 403,
        JSMSG_WASM_BAD_EXN_ARG = 404,
        JSMSG_WASM_BAD_EXN_PAYLOAD = 405,
        JSMSG_WASM_BAD_EXN_PAYLOAD_LEN = 406,
        JSMSG_WASM_BAD_EXN_TAG = 407,
        JSMSG_WASM_BAD_EXN_OPTIONS = 408,
        JSMSG_WASM_BAD_FUNCTION_VALUE = 409,
        JSMSG_WASM_BAD_COMPILE_OPTIONS = 410,
        JSMSG_WASM_UNKNOWN_BUILTIN = 411,
        JSMSG_WASM_DUPLICATE_BUILTIN = 412,
        JSMSG_WASM_BAD_CODEPOINT = 413,
        JSMSG_WASM_NO_TRANSFER = 414,
        JSMSG_WASM_TEXT_FAIL = 415,
        JSMSG_WASM_MISSING_MAXIMUM = 416,
        JSMSG_WASM_GLOBAL_IMMUTABLE = 417,
        JSMSG_WASM_WRONG_NUMBER_OF_VALUES = 418,
        JSMSG_WASM_NONSHARED_WAIT = 419,
        JSMSG_WASM_SUPPLY_ONLY_ONE = 420,
        JSMSG_WASM_MISSING_REQUIRED = 421,
        JSMSG_WASM_MODIFIED_GC_OBJECT = 422,
        JSMSG_JSPI_ARG_POSITION = 423,
        JSMSG_JSPI_INVALID_SUSPENDER = 424,
        JSMSG_JSPI_INVALID_STATE = 425,
        JSMSG_JSPI_EXPECTED_SUSPENDER = 426,
        JSMSG_JSPI_EXPECTED_PROMISE = 427,
        JSMSG_JSPI_SIGNATURE_MISMATCH = 428,
        JSMSG_JSPI_SUSPENDER_LIMIT = 429,
        JSMSG_BAD_GETPROTOTYPEOF_TRAP_RETURN = 430,
        JSMSG_INCONSISTENT_GETPROTOTYPEOF_TRAP = 431,
        JSMSG_PROXY_SETPROTOTYPEOF_RETURNED_FALSE = 432,
        JSMSG_INCONSISTENT_SETPROTOTYPEOF_TRAP = 433,
        JSMSG_CANT_CHANGE_EXTENSIBILITY = 434,
        JSMSG_CANT_DEFINE_INVALID = 435,
        JSMSG_CANT_DEFINE_NEW = 436,
        JSMSG_CANT_DEFINE_NE_AS_NC = 437,
        JSMSG_PROXY_DEFINE_RETURNED_FALSE = 438,
        JSMSG_PROXY_DELETE_RETURNED_FALSE = 439,
        JSMSG_PROXY_PREVENTEXTENSIONS_RETURNED_FALSE = 440,
        JSMSG_PROXY_SET_RETURNED_FALSE = 441,
        JSMSG_CANT_REPORT_AS_NON_EXTENSIBLE = 442,
        JSMSG_CANT_DELETE_NON_EXTENSIBLE = 443,
        JSMSG_CANT_REPORT_C_AS_NC = 444,
        JSMSG_CANT_REPORT_E_AS_NE = 445,
        JSMSG_CANT_REPORT_INVALID = 446,
        JSMSG_CANT_REPORT_NC_AS_NE = 447,
        JSMSG_CANT_REPORT_NEW = 448,
        JSMSG_CANT_REPORT_NE_AS_NC = 449,
        JSMSG_CANT_REPORT_W_AS_NW = 450,
        JSMSG_CANT_SET_NW_NC = 451,
        JSMSG_CANT_SET_WO_SETTER = 452,
        JSMSG_CANT_SKIP_NC = 453,
        JSMSG_OWNKEYS_STR_SYM = 454,
        JSMSG_OWNKEYS_DUPLICATE = 455,
        JSMSG_MUST_REPORT_SAME_VALUE = 456,
        JSMSG_MUST_REPORT_UNDEFINED = 457,
        JSMSG_PROXY_CONSTRUCT_OBJECT = 458,
        JSMSG_PROXY_EXTENSIBILITY = 459,
        JSMSG_PROXY_GETOWN_OBJORUNDEF = 460,
        JSMSG_PROXY_REVOKED = 461,
        JSMSG_BAD_TRAP = 462,
        JSMSG_SC_BAD_CLONE_VERSION = 463,
        JSMSG_SC_BAD_SERIALIZED_DATA = 464,
        JSMSG_SC_DUP_TRANSFERABLE = 465,
        JSMSG_SC_NOT_TRANSFERABLE = 466,
        JSMSG_SC_UNSUPPORTED_TYPE = 467,
        JSMSG_SC_NOT_CLONABLE = 468,
        JSMSG_SC_NOT_CLONABLE_WITH_COOP_COEP = 469,
        JSMSG_SC_SAB_DISABLED = 470,
        JSMSG_SC_SAB_REFCNT_OFLO = 471,
        JSMSG_SC_SHMEM_TRANSFERABLE = 472,
        JSMSG_SC_SHMEM_POLICY = 473,
        JSMSG_ASSIGN_FUNCTION_OR_NULL = 474,
        JSMSG_DEBUG_BAD_LINE = 475,
        JSMSG_DEBUG_BAD_OFFSET = 476,
        JSMSG_DEBUG_BREAKPOINT_NOT_ALLOWED = 477,
        JSMSG_DEBUG_BAD_REFERENT = 478,
        JSMSG_DEBUG_BAD_RESUMPTION = 479,
        JSMSG_DEBUG_RESUMPTION_CONFLICT = 480,
        JSMSG_DEBUG_CANT_DEBUG_GLOBAL = 481,
        JSMSG_DEBUG_SAME_COMPARTMENT = 482,
        JSMSG_DEBUG_CCW_REQUIRED = 483,
        JSMSG_DEBUG_COMPARTMENT_MISMATCH = 484,
        JSMSG_DEBUG_LOOP = 485,
        JSMSG_DEBUG_NOT_DEBUGGEE = 486,
        JSMSG_DEBUG_NOT_DEBUGGING = 487,
        JSMSG_DEBUG_NOT_IDLE = 488,
        JSMSG_DEBUG_NOT_ON_STACK = 489,
        JSMSG_DEBUG_NOT_ON_STACK_OR_SUSPENDED = 490,
        JSMSG_DEBUG_NO_ENV_OBJECT = 491,
        JSMSG_DEBUG_PROTO = 492,
        JSMSG_DEBUG_WRONG_OWNER = 493,
        JSMSG_DEBUG_OPTIMIZED_OUT = 494,
        JSMSG_DEBUG_OPTIMIZED_OUT_FUN = 495,
        JSMSG_DEBUG_FORCED_RETURN_DISALLOWED = 496,
        JSMSG_DEBUG_RESUMPTION_VALUE_DISALLOWED = 497,
        JSMSG_DEBUG_VARIABLE_NOT_FOUND = 498,
        JSMSG_DEBUG_WRAPPER_IN_WAY = 499,
        JSMSG_DEBUGGEE_WOULD_RUN = 500,
        JSMSG_NOT_CALLABLE_OR_UNDEFINED = 501,
        JSMSG_NOT_TRACKING_ALLOCATIONS = 502,
        JSMSG_OBJECT_METADATA_CALLBACK_ALREADY_SET = 503,
        JSMSG_QUERY_INNERMOST_WITHOUT_LINE_URL = 504,
        JSMSG_QUERY_LINE_WITHOUT_URL = 505,
        JSMSG_DEBUG_CANT_SET_OPT_ENV = 506,
        JSMSG_DEBUG_INVISIBLE_COMPARTMENT = 507,
        JSMSG_DEBUG_CENSUS_BREAKDOWN = 508,
        JSMSG_DEBUG_CENSUS_BREAKDOWN_NESTED = 509,
        JSMSG_DEBUG_PROMISE_NOT_RESOLVED = 510,
        JSMSG_DEBUG_PROMISE_NOT_FULFILLED = 511,
        JSMSG_DEBUG_PROMISE_NOT_REJECTED = 512,
        JSMSG_DEBUG_NO_BINARY_SOURCE = 513,
        JSMSG_DEBUG_EXCLUSIVE_FRAME_COVERAGE = 514,
        JSMSG_TESTING_SCRIPTS_ONLY = 515,
        JSMSG_INVALID_ARGS = 516,
        JSMSG_TRACELOGGER_ENABLE_FAIL = 517,
        JSMSG_DATE_NOT_FINITE = 518,
        JSMSG_DUPLICATE_VARIANT_SUBTAG = 519,
        JSMSG_INTERNAL_INTL_ERROR = 520,
        JSMSG_INVALID_CURRENCY_CODE = 521,
        JSMSG_INVALID_UNIT_IDENTIFIER = 522,
        JSMSG_INVALID_DIGITS_VALUE = 523,
        JSMSG_INVALID_KEY = 524,
        JSMSG_INVALID_LANGUAGE_TAG = 525,
        JSMSG_INVALID_LOCALES_ELEMENT = 526,
        JSMSG_INVALID_LOCALE_MATCHER = 527,
        JSMSG_INVALID_OPTION_VALUE = 528,
        JSMSG_INVALID_TIME_ZONE = 529,
        JSMSG_INVALID_DATETIME_OPTION = 530,
        JSMSG_INVALID_DATETIME_STYLE = 531,
        JSMSG_UNDEFINED_CURRENCY = 532,
        JSMSG_UNDEFINED_UNIT = 533,
        JSMSG_UNDEFINED_DATE = 534,
        JSMSG_UNDEFINED_NUMBER = 535,
        JSMSG_UNDEFINED_TYPE = 536,
        JSMSG_NAN_NUMBER_RANGE = 537,
        JSMSG_INVALID_NUMBER_OPTION = 538,
        JSMSG_UNEQUAL_FRACTION_DIGITS = 539,
        JSMSG_BAD_CLASS_RANGE = 540,
        JSMSG_ESCAPE_AT_END_OF_REGEXP = 541,
        JSMSG_EXEC_NOT_OBJORNULL = 542,
        JSMSG_INVALID_DECIMAL_ESCAPE = 543,
        JSMSG_INVALID_GROUP = 544,
        JSMSG_INVALID_IDENTITY_ESCAPE = 545,
        JSMSG_INVALID_UNICODE_ESCAPE = 546,
        JSMSG_MISSING_PAREN = 547,
        JSMSG_NEWREGEXP_FLAGGED = 548,
        JSMSG_NOTHING_TO_REPEAT = 549,
        JSMSG_NUMBERS_OUT_OF_ORDER = 550,
        JSMSG_RANGE_WITH_CLASS_ESCAPE = 551,
        JSMSG_RAW_BRACKET_IN_REGEXP = 552,
        JSMSG_TOO_MANY_PARENS = 553,
        JSMSG_UNICODE_OVERFLOW = 554,
        JSMSG_UNMATCHED_RIGHT_PAREN = 555,
        JSMSG_UNTERM_CLASS = 556,
        JSMSG_INVALID_PROPERTY_NAME = 557,
        JSMSG_INVALID_CLASS_PROPERTY_NAME = 558,
        JSMSG_INCOMPLETE_QUANTIFIER = 559,
        JSMSG_INVALID_QUANTIFIER = 560,
        JSMSG_INVALID_CAPTURE_NAME = 561,
        JSMSG_DUPLICATE_CAPTURE_NAME = 562,
        JSMSG_INVALID_NAMED_REF = 563,
        JSMSG_INVALID_NAMED_CAPTURE_REF = 564,
        JSMSG_INCOMPATIBLE_REGEXP_GETTER = 565,
        JSMSG_INVALID_CLASS_SET_OP = 566,
        JSMSG_INVALID_CHAR_IN_CLASS = 567,
        JSMSG_NEGATED_CLASS_WITH_STR = 568,
        JSMSG_TYPEDOBJECT_SETTING_IMMUTABLE = 569,
        JSMSG_TOO_LONG_ARRAY = 570,
        JSMSG_BAD_INDEX = 571,
        JSMSG_DEFINE_BAD_INDEX = 572,
        JSMSG_NON_ARRAY_BUFFER_RETURNED = 573,
        JSMSG_SAME_ARRAY_BUFFER_RETURNED = 574,
        JSMSG_SHORT_ARRAY_BUFFER_RETURNED = 575,
        JSMSG_TYPED_ARRAY_BAD_ARGS = 576,
        JSMSG_TYPED_ARRAY_DETACHED = 577,
        JSMSG_ARRAYBUFFER_LENGTH_PINNED = 578,
        JSMSG_TYPED_ARRAY_RESIZED_BOUNDS = 579,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_BOUNDS = 580,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_MISALIGNED = 581,
        JSMSG_TYPED_ARRAY_CONSTRUCT_OFFSET_LENGTH_BOUNDS = 582,
        JSMSG_TYPED_ARRAY_CONSTRUCT_ARRAY_LENGTH_BOUNDS = 583,
        JSMSG_TYPED_ARRAY_CONSTRUCT_TOO_LARGE = 584,
        JSMSG_TYPED_ARRAY_BAD_HEX_STRING_LENGTH = 585,
        JSMSG_TYPED_ARRAY_BAD_HEX_DIGIT = 586,
        JSMSG_TYPED_ARRAY_BAD_BASE64_ALPHABET = 587,
        JSMSG_TYPED_ARRAY_BAD_BASE64_LAST_CHUNK_HANDLING = 588,
        JSMSG_TYPED_ARRAY_BAD_BASE64_CHAR = 589,
        JSMSG_TYPED_ARRAY_BAD_INCOMPLETE_CHUNK = 590,
        JSMSG_TYPED_ARRAY_BAD_BASE64_AFTER_PADDING = 591,
        JSMSG_TYPED_ARRAY_MISSING_BASE64_PADDING = 592,
        JSMSG_TYPED_ARRAY_EXTRA_BASE64_BITS = 593,
        JSMSG_TYPED_ARRAY_CALL_OR_CONSTRUCT = 594,
        JSMSG_NON_TYPED_ARRAY_RETURNED = 595,
        JSMSG_SHORT_TYPED_ARRAY_RETURNED = 596,
        JSMSG_TYPED_ARRAY_NOT_COMPATIBLE = 597,
        JSMSG_ARRAYBUFFER_REQUIRED = 598,
        JSMSG_ARRAYBUFFER_LENGTH_LARGER_THAN_MAXIMUM = 599,
        JSMSG_ARRAYBUFFER_NON_RESIZABLE = 600,
        JSMSG_ARRAYBUFFER_COPY_RANGE = 601,
        JSMSG_SHARED_ARRAY_BAD_LENGTH = 602,
        JSMSG_NON_SHARED_ARRAY_BUFFER_RETURNED = 603,
        JSMSG_SAME_SHARED_ARRAY_BUFFER_RETURNED = 604,
        JSMSG_SHORT_SHARED_ARRAY_BUFFER_RETURNED = 605,
        JSMSG_SHARED_ARRAY_LENGTH_SMALLER_THAN_CURRENT = 606,
        JSMSG_BAD_PARSE_NODE = 607,
        JSMSG_SYMBOL_TO_STRING = 608,
        JSMSG_SYMBOL_TO_NUMBER = 609,
        JSMSG_ATOMICS_BAD_ARRAY = 610,
        JSMSG_ATOMICS_WAIT_NOT_ALLOWED = 611,
        JSMSG_CANT_SET_INTERPOSED = 612,
        JSMSG_CANT_DEFINE_WINDOW_ELEMENT = 613,
        JSMSG_CANT_DELETE_WINDOW_ELEMENT = 614,
        JSMSG_CANT_DEFINE_WINDOW_NAMED_PROPERTY = 615,
        JSMSG_CANT_DELETE_WINDOW_NAMED_PROPERTY = 616,
        JSMSG_CANT_PREVENT_EXTENSIONS = 617,
        JSMSG_CANT_DEFINE_WINDOW_NC = 618,
        JSMSG_NO_NAMED_SETTER = 619,
        JSMSG_NO_INDEXED_SETTER = 620,
        JSMSG_NOT_DATA_DESCRIPTOR = 621,
        JSMSG_CANT_DELETE_SUPER = 622,
        JSMSG_REINIT_THIS = 623,
        JSMSG_MODULE_NO_EXPORT = 624,
        JSMSG_MODULE_CIRCULAR_IMPORT = 625,
        JSMSG_MODULE_AMBIGUOUS = 626,
        JSMSG_MISSING_EXPORT = 627,
        JSMSG_BAD_MODULE_STATUS = 628,
        JSMSG_DYNAMIC_IMPORT_FAILED = 629,
        JSMSG_DYNAMIC_IMPORT_NOT_SUPPORTED = 630,
        JSMSG_BAD_MODULE_TYPE = 631,
        JSMSG_IMPORT_MAPS_PARSE_FAILED = 632,
        JSMSG_IMPORT_MAPS_NOT_A_MAP = 633,
        JSMSG_IMPORT_MAPS_IMPORTS_NOT_A_MAP = 634,
        JSMSG_IMPORT_MAPS_SCOPES_NOT_A_MAP = 635,
        JSMSG_IMPORT_MAPS_SCOPE_VALUE_NOT_A_MAP = 636,
        JSMSG_IMPORT_ATTRIBUTES_STATIC_IMPORT_UNSUPPORTED_ATTRIBUTE = 637,
        JSMSG_IMPORT_ATTRIBUTES_DYNAMIC_IMPORT_UNSUPPORTED_ATTRIBUTE = 638,
        JSMSG_CANNOT_RESOLVE_PROMISE_WITH_ITSELF = 639,
        JSMSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY = 640,
        JSMSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE = 641,
        JSMSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE = 642,
        JSMSG_PROMISE_ERROR_IN_WRAPPED_REJECTION_REASON = 643,
        JSMSG_PROMISE_ANY_REJECTION = 644,
        JSMSG_RETURN_NOT_CALLABLE = 645,
        JSMSG_ITERATOR_NO_THROW = 646,
        JSMSG_UNHANDLABLE_PROMISE_REJECTION_WARNING = 647,
        JSMSG_FOR_AWAIT_NOT_OF = 648,
        JSMSG_NOT_AN_ASYNC_GENERATOR = 649,
        JSMSG_GET_ASYNC_ITER_RETURNED_PRIMITIVE = 650,
        JSMSG_SUSPENDED_QUEUE_NOT_EMPTY = 651,
        JSMSG_READABLESTREAM_UNDERLYINGSOURCE_TYPE_WRONG = 652,
        JSMSG_READABLESTREAM_BYTES_TYPE_NOT_IMPLEMENTED = 653,
        JSMSG_READABLESTREAM_BYOB_READER_FOR_NON_BYTE_STREAM = 654,
        JSMSG_READABLESTREAM_INVALID_READER_MODE = 655,
        JSMSG_NUMBER_MUST_BE_FINITE_NON_NEGATIVE = 656,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_BYTESWRITTEN = 657,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_SIZE = 658,
        JSMSG_READABLEBYTESTREAMCONTROLLER_INVALID_VIEW_OFFSET = 659,
        JSMSG_READABLEBYTESTREAMCONTROLLER_EMPTY_VIEW = 660,
        JSMSG_READABLEBYTESTREAMCONTROLLER_NO_VIEW = 661,
        JSMSG_READABLESTREAM_LOCKED_METHOD = 662,
        JSMSG_READABLESTREAM_LOCKED = 663,
        JSMSG_READABLESTREAM_NOT_BYTE_STREAM_CONTROLLER = 664,
        JSMSG_READABLESTREAM_NOT_DEFAULT_CONTROLLER = 665,
        JSMSG_READABLESTREAM_CONTROLLER_SET = 666,
        JSMSG_READABLESTREAMREADER_NOT_OWNED = 667,
        JSMSG_READABLESTREAMREADER_NOT_EMPTY = 668,
        JSMSG_READABLESTREAMBYOBREADER_READ_NOT_BUFFER = 669,
        JSMSG_READABLESTREAMBYOBREADER_READ_EMPTY_VIEW = 670,
        JSMSG_READABLESTREAMBYOBREADER_READ_DETACHED = 671,
        JSMSG_READABLESTREAMREADER_RELEASED = 672,
        JSMSG_READABLESTREAMCONTROLLER_CLOSED = 673,
        JSMSG_READABLESTREAMCONTROLLER_NOT_READABLE = 674,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNKSIZE = 675,
        JSMSG_READABLEBYTESTREAMCONTROLLER_BAD_CHUNK = 676,
        JSMSG_READABLEBYTESTREAMCONTROLLER_DETACHED = 677,
        JSMSG_READABLEBYTESTREAMCONTROLLER_CLOSE_PENDING_PULL = 678,
        JSMSG_READABLESTREAMBYOBREQUEST_NO_CONTROLLER = 679,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_INVALID_WRITTEN_LEN = 680,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_CLOSED = 681,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_DETACHED = 682,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_ZERO = 683,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_EXCEED = 684,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_BAD_OFFSET = 685,
        JSMSG_READABLESTREAMBYOBREQUEST_RESPOND_BAD_LEN = 686,
        JSMSG_READABLESTREAM_METHOD_NOT_IMPLEMENTED = 687,
        JSMSG_READABLESTREAM_PIPETO_BAD_SIGNAL = 688,
        JSMSG_READABLESTREAMTEE_BYOB = 689,
        JSMSG_READABLESTREAMTEE_CLONE = 690,
        JSMSG_READABLESTREAM_UNDERLYINGSINK_TYPE_WRONG = 691,
        JSMSG_WRITABLESTREAMWRITER_NOT_OWNED = 692,
        JSMSG_WRITABLESTREAM_CLOSED_OR_ERRORED = 693,
        JSMSG_WRITABLESTREAM_RELEASED_DURING_WRITE = 694,
        JSMSG_WRITABLESTREAM_WRITE_CLOSING_OR_CLOSED = 695,
        JSMSG_CANT_USE_LOCKED_WRITABLESTREAM = 696,
        JSMSG_WRITABLESTREAM_CLOSE_CLOSING_OR_CLOSED = 697,
        JSMSG_WRITABLESTREAM_CANT_RELEASE_ALREADY_CLOSED = 698,
        JSMSG_WRITABLESTREAM_ALREADY_LOCKED = 699,
        JSMSG_READABLESTREAM_NYI = 700,
        JSMSG_STREAM_MISSING_HIGHWATERMARK = 701,
        JSMSG_STREAM_INVALID_HIGHWATERMARK = 702,
        JSMSG_STREAM_CONSUME_ERROR = 703,
        JSMSG_STREAM_AUTOALLOCATECHUNKSIZE_ZERO = 704,
        JSMSG_READABLESTREAM_BYOB_SIZE = 705,
        JSMSG_WASM_ERROR_CONSUMING_RESPONSE = 706,
        JSMSG_WASM_BAD_RESPONSE_VALUE = 707,
        JSMSG_WASM_BAD_RESPONSE_MIME_TYPE = 708,
        JSMSG_WASM_BAD_RESPONSE_CORS_SAME_ORIGIN = 709,
        JSMSG_WASM_BAD_RESPONSE_STATUS = 710,
        JSMSG_WASM_RESPONSE_ALREADY_CONSUMED = 711,
        JSMSG_BIGINT_TO_NUMBER = 712,
        JSMSG_NONINTEGER_NUMBER_TO_BIGINT = 713,
        JSMSG_BIGINT_TOO_LARGE = 714,
        JSMSG_BIGINT_DIVISION_BY_ZERO = 715,
        JSMSG_BIGINT_NEGATIVE_EXPONENT = 716,
        JSMSG_BIGINT_INVALID_SYNTAX = 717,
        JSMSG_BIGINT_NOT_SERIALIZABLE = 718,
        JSMSG_NOT_A_FINALIZATION_REGISTRY = 719,
        JSMSG_BAD_HELD_VALUE = 720,
        JSMSG_BAD_UNREGISTER_TOKEN = 721,
        JSMSG_BAD_FINALIZATION_REGISTRY_OBJECT = 722,
        JSMSG_NOT_A_WEAK_REF = 723,
        JSMSG_BAD_WEAKREF_TARGET = 724,
        JSMSG_NEGATIVE_LIMIT = 725,
        JSMSG_SET_NEGATIVE_SIZE = 726,
        JSMSG_RECORD_TUPLE_NO_OBJECT = 727,
        JSMSG_RECORD_NO_PROTO = 728,
        JSMSG_RECORD_NO_SYMBOL_KEY = 729,
        JSMSG_BAD_TUPLE_INDEX = 730,
        JSMSG_BAD_TUPLE_OBJECT = 731,
        JSMSG_RECORD_TUPLE_TO_NUMBER = 732,
        JSMSG_NOT_SHADOW_REALM = 733,
        JSMSG_SHADOW_REALM_EVALUATE_NOT_STRING = 734,
        JSMSG_SHADOW_REALM_INVALID_RETURN = 735,
        JSMSG_SHADOW_REALM_WRAP_FAILURE = 736,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE = 737,
        JSMSG_SHADOW_REALM_EVALUATE_FAILURE_DETAIL = 738,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE = 739,
        JSMSG_SHADOW_REALM_WRAPPED_EXECUTION_FAILURE_DETAIL = 740,
        JSMSG_SHADOW_REALM_EXPORT_NOT_STRING = 741,
        JSMSG_SHADOW_REALM_IMPORTVALUE_FAILED = 742,
        JSMSG_SHADOW_REALM_VALUE_NOT_EXPORTED = 743,
        JSMSG_DECORATOR_INVALID_RETURN_TYPE = 744,
        JSMSG_TEMPORAL_INVALID_UNIT_RANGE = 745,
        JSMSG_TEMPORAL_INVALID_UNIT_OPTION = 746,
        JSMSG_TEMPORAL_INVALID_NUMBER = 747,
        JSMSG_TEMPORAL_INVALID_INTEGER = 748,
        JSMSG_TEMPORAL_INVALID_OBJECT = 749,
        JSMSG_TEMPORAL_MISSING_OPTION = 750,
        JSMSG_TEMPORAL_MISSING_PROPERTY = 751,
        JSMSG_TEMPORAL_UNEXPECTED_PROPERTY = 752,
        JSMSG_TEMPORAL_MISSING_TEMPORAL_FIELDS = 753,
        JSMSG_TEMPORAL_DUPLICATE_PROPERTY = 754,
        JSMSG_TEMPORAL_INVALID_PROPERTY = 755,
        JSMSG_TEMPORAL_INSTANT_INVALID = 756,
        JSMSG_TEMPORAL_INSTANT_NONINTEGER = 757,
        JSMSG_TEMPORAL_INSTANT_BAD_DURATION = 758,
        JSMSG_TEMPORAL_TIMEZONE_INVALID_IDENTIFIER = 759,
        JSMSG_TEMPORAL_TIMEZONE_NANOS_RANGE = 760,
        JSMSG_TEMPORAL_TIMEZONE_INCOMPATIBLE = 761,
        JSMSG_TEMPORAL_TIMEZONE_INSTANT_AMBIGUOUS = 762,
        JSMSG_TEMPORAL_TIMEZONE_OFFSET_SHIFT_ONE_DAY = 763,
        JSMSG_TEMPORAL_DURATION_INVALID_SIGN = 764,
        JSMSG_TEMPORAL_DURATION_INVALID_NON_FINITE = 765,
        JSMSG_TEMPORAL_DURATION_INVALID_NORMALIZED_TIME = 766,
        JSMSG_TEMPORAL_DURATION_MISSING_UNIT = 767,
        JSMSG_TEMPORAL_DURATION_NOT_INTEGER = 768,
        JSMSG_TEMPORAL_DURATION_MISSING_UNIT_SPECIFIER = 769,
        JSMSG_TEMPORAL_DURATION_UNCOMPARABLE = 770,
        JSMSG_TEMPORAL_DURATION_COMBINE_INVALID_SIGN = 771,
        JSMSG_TEMPORAL_CALENDAR_INVALID_ID = 772,
        JSMSG_TEMPORAL_CALENDAR_MISSING_FIELD = 773,
        JSMSG_TEMPORAL_CALENDAR_INVALID_FIELD = 774,
        JSMSG_TEMPORAL_CALENDAR_DUPLICATE_FIELD = 775,
        JSMSG_TEMPORAL_CALENDAR_OVERFLOW_FIELD = 776,
        JSMSG_TEMPORAL_CALENDAR_INVALID_MONTHCODE = 777,
        JSMSG_TEMPORAL_CALENDAR_INVALID_ERA = 778,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE = 779,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_ERA = 780,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_ERAYEAR = 781,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_YEAR = 782,
        JSMSG_TEMPORAL_CALENDAR_INCOMPATIBLE_MONTHCODE = 783,
        JSMSG_TEMPORAL_CALENDAR_INTERNAL_ERROR = 784,
        JSMSG_TEMPORAL_PLAIN_DATE_INVALID = 785,
        JSMSG_TEMPORAL_PLAIN_DATE_INVALID_VALUE = 786,
        JSMSG_TEMPORAL_PLAIN_DATE_TIME_INVALID = 787,
        JSMSG_TEMPORAL_PLAIN_TIME_INVALID = 788,
        JSMSG_TEMPORAL_PLAIN_TIME_INVALID_VALUE = 789,
        JSMSG_TEMPORAL_PLAIN_TIME_MISSING_UNIT = 790,
        JSMSG_TEMPORAL_PLAIN_TIME_CALENDAR_NOT_ISO8601 = 791,
        JSMSG_TEMPORAL_PLAIN_MONTH_DAY_INVALID = 792,
        JSMSG_TEMPORAL_PLAIN_YEAR_MONTH_INVALID = 793,
        JSMSG_TEMPORAL_ZONED_DATE_TIME_NO_TIME_FOUND = 794,
        JSMSG_TEMPORAL_ZONED_DATE_TIME_INCORRECT_SIGN = 795,
        JSMSG_TEMPORAL_ZONED_DATE_TIME_INCONSISTENT_INSTANT = 796,
        JSMSG_TEMPORAL_PARSER_NEGATIVE_ZERO_YEAR = 797,
        JSMSG_TEMPORAL_PARSER_MISSING_EXTENDED_YEAR = 798,
        JSMSG_TEMPORAL_PARSER_MISSING_YEAR = 799,
        JSMSG_TEMPORAL_PARSER_MISSING_MONTH = 800,
        JSMSG_TEMPORAL_PARSER_MISSING_DAY = 801,
        JSMSG_TEMPORAL_PARSER_MISSING_HOUR = 802,
        JSMSG_TEMPORAL_PARSER_MISSING_MINUTE = 803,
        JSMSG_TEMPORAL_PARSER_MISSING_SECOND = 804,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_SIGN = 805,
        JSMSG_TEMPORAL_PARSER_INVALID_MONTH = 806,
        JSMSG_TEMPORAL_PARSER_INVALID_DAY = 807,
        JSMSG_TEMPORAL_PARSER_INVALID_HOUR = 808,
        JSMSG_TEMPORAL_PARSER_INVALID_MINUTE = 809,
        JSMSG_TEMPORAL_PARSER_INVALID_SECOND = 810,
        JSMSG_TEMPORAL_PARSER_INVALID_LEAPSECOND = 811,
        JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_TIMEZONE = 812,
        JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_TIMEZONE = 813,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE = 814,
        JSMSG_TEMPORAL_PARSER_MISSING_TIMEZONE_NAME = 815,
        JSMSG_TEMPORAL_PARSER_GARBAGE_AFTER_INPUT = 816,
        JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DESIGNATOR = 817,
        JSMSG_TEMPORAL_PARSER_MISSING_TIME_DESIGNATOR = 818,
        JSMSG_TEMPORAL_PARSER_MISSING_DURATION_DIGITS = 819,
        JSMSG_TEMPORAL_PARSER_INVALID_DURATION_MINUTES = 820,
        JSMSG_TEMPORAL_PARSER_INVALID_DURATION_SECONDS = 821,
        JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_KEY = 822,
        JSMSG_TEMPORAL_PARSER_INVALID_ANNOTATION_VALUE = 823,
        JSMSG_TEMPORAL_PARSER_INVALID_CALENDAR_NAME = 824,
        JSMSG_TEMPORAL_PARSER_BRACKET_BEFORE_ANNOTATION = 825,
        JSMSG_TEMPORAL_PARSER_BRACKET_AFTER_ANNOTATION = 826,
        JSMSG_TEMPORAL_PARSER_ASSIGNMENT_IN_ANNOTATION = 827,
        JSMSG_TEMPORAL_PARSER_INVALID_CRITICAL_ANNOTATION = 828,
        JSMSG_TEMPORAL_PARSER_MISSING_DATE_TIME_SEPARATOR = 829,
        JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_MONTH_DAY = 830,
        JSMSG_TEMPORAL_PARSER_AMBIGUOUS_TIME_YEAR_MONTH = 831,
        JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR = 832,
        JSMSG_TEMPORAL_PARSER_INVALID_UTC_DESIGNATOR_WITHOUT_NAME = 833,
        JSMSG_TEMPORAL_PARSER_MONTH_DAY_CALENDAR_NOT_ISO8601 = 834,
        JSMSG_TEMPORAL_PARSER_YEAR_MONTH_CALENDAR_NOT_ISO8601 = 835,
        JSMSG_TEMPORAL_PARSER_INVALID_SUBMINUTE_TIMEZONE = 836,
        JSErr_Limit = 837,
    }
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCParamKey {
        /** Maximum nominal heap before last ditch GC.

 Soft limit on the number of bytes we are allowed to allocate in the GC
 heap. Attempts to allocate gcthings over this limit will return null and
 subsequently invoke the standard OOM machinery, independent of available
 physical memory.

 Pref: javascript.options.mem.max
 Default: 0xffffffff*/
        JSGC_MAX_BYTES = 0,
        /** Maximum size of the generational GC nurseries.

 This will be rounded to the nearest gc::ChunkSize.

 Pref: javascript.options.mem.nursery.max_kb
 Default: JS::DefaultNurseryMaxBytes*/
        JSGC_MAX_NURSERY_BYTES = 2,
        /// Amount of bytes allocated by the GC.
        JSGC_BYTES = 3,
        /// Number of times GC has been invoked. Includes both major and minor GC.
        JSGC_NUMBER = 4,
        /** Whether incremental GC is enabled. If not, GC will always run to
 completion.

 prefs: javascript.options.mem.gc_incremental.
 Default: false*/
        JSGC_INCREMENTAL_GC_ENABLED = 5,
        /** Whether per-zone GC is enabled. If not, all zones are collected every time.

 prefs: javascript.options.mem.gc_per_zone
 Default: false*/
        JSGC_PER_ZONE_GC_ENABLED = 6,
        /// Number of cached empty GC chunks.
        JSGC_UNUSED_CHUNKS = 7,
        /// Total number of allocated GC chunks.
        JSGC_TOTAL_CHUNKS = 8,
        /** Max milliseconds to spend in an incremental GC slice.

 A value of zero means there is no maximum.

 Pref: javascript.options.mem.gc_incremental_slice_ms
 Default: DefaultTimeBudgetMS.*/
        JSGC_SLICE_TIME_BUDGET_MS = 9,
        /** GCs less than this far apart in milliseconds will be considered
 'high-frequency GCs'.

 Pref: javascript.options.mem.gc_high_frequency_time_limit_ms
 Default: HighFrequencyThreshold*/
        JSGC_HIGH_FREQUENCY_TIME_LIMIT = 11,
        /** Upper limit for classifying a heap as small (MB).

 Dynamic heap growth thresholds are based on whether the heap is small,
 medium or large. Heaps smaller than this size are classified as small;
 larger heaps are classified as medium or large.

 Pref: javascript.options.mem.gc_small_heap_size_max_mb
 Default: SmallHeapSizeMaxBytes*/
        JSGC_SMALL_HEAP_SIZE_MAX = 12,
        /** Lower limit for classifying a heap as large (MB).

 Dynamic heap growth thresholds are based on whether the heap is small,
 medium or large. Heaps larger than this size are classified as large;
 smaller heaps are classified as small or medium.

 Pref: javascript.options.mem.gc_large_heap_size_min_mb
 Default: LargeHeapSizeMinBytes*/
        JSGC_LARGE_HEAP_SIZE_MIN = 13,
        /** Heap growth factor for small heaps in the high-frequency GC state.

 Pref: javascript.options.mem.gc_high_frequency_small_heap_growth
 Default: HighFrequencySmallHeapGrowth*/
        JSGC_HIGH_FREQUENCY_SMALL_HEAP_GROWTH = 14,
        /** Heap growth factor for large heaps in the high-frequency GC state.

 Pref: javascript.options.mem.gc_high_frequency_large_heap_growth
 Default: HighFrequencyLargeHeapGrowth*/
        JSGC_HIGH_FREQUENCY_LARGE_HEAP_GROWTH = 15,
        /** Heap growth factor for low frequency GCs.

 This factor is applied regardless of the size of the heap when not in the
 high-frequency GC state.

 Pref: javascript.options.mem.gc_low_frequency_heap_growth
 Default: LowFrequencyHeapGrowth*/
        JSGC_LOW_FREQUENCY_HEAP_GROWTH = 16,
        /** Whether balanced heap limits are enabled.

 If this is set to true then heap limits are calculated in a way designed to
 balance memory usage optimally between many heaps.

 Otherwise, heap limits are set based on a linear multiple of the retained
 size after the last collection.

 Pref: javascript.options.mem.gc_balanced_heap_limits
 Default: BalancedHeapLimitsEnabled*/
        JSGC_BALANCED_HEAP_LIMITS_ENABLED = 17,
        /** Heap growth parameter for balanced heap limit calculation.

 This parameter trades off GC time for memory usage. Smaller values result
 in lower memory use and larger values result in less time spent collecting.

 Heap limits are set to the heap's retained size plus some extra space. The
 extra space is calculated based on several factors but is scaled
 proportionally to this parameter.

 Pref: javascript.options.mem.gc_heap_growth_factor
 Default: HeapGrowthFactor*/
        JSGC_HEAP_GROWTH_FACTOR = 18,
        /** Lower limit for collecting a zone (MB).

 Zones smaller than this size will not normally be collected.

 Pref: javascript.options.mem.gc_allocation_threshold_mb
 Default GCZoneAllocThresholdBase*/
        JSGC_ALLOCATION_THRESHOLD = 19,
        /** We try to keep at least this many unused chunks in the free chunk pool at
 all times, even after a shrinking GC.

 Pref: javascript.options.mem.gc_min_empty_chunk_count
 Default: MinEmptyChunkCount*/
        JSGC_MIN_EMPTY_CHUNK_COUNT = 21,
        /** We never keep more than this many unused chunks in the free chunk pool.

 Pref: javascript.options.mem.gc_max_empty_chunk_count
 Default: MaxEmptyChunkCount*/
        JSGC_MAX_EMPTY_CHUNK_COUNT = 22,
        /** Whether compacting GC is enabled.

 Pref: javascript.options.mem.gc_compacting
 Default: CompactingEnabled*/
        JSGC_COMPACTING_ENABLED = 23,
        /** Whether parallel marking is enabled.

 Pref: javascript.options.mem.gc_parallel_marking
 Default: ParallelMarkingEnabled*/
        JSGC_PARALLEL_MARKING_ENABLED = 24,
        /** Limit of how far over the incremental trigger threshold we allow the heap
 to grow before finishing a collection non-incrementally, for small heaps.

 We trigger an incremental GC when a trigger threshold is reached but the
 collection may not be fast enough to keep up with the mutator. At some
 point we finish the collection non-incrementally.

 Default: SmallHeapIncrementalLimit
 Pref: javascript.options.mem.gc_small_heap_incremental_limit*/
        JSGC_SMALL_HEAP_INCREMENTAL_LIMIT = 25,
        /** Limit of how far over the incremental trigger threshold we allow the heap
 to grow before finishing a collection non-incrementally, for large heaps.

 Default: LargeHeapIncrementalLimit
 Pref: javascript.options.mem.gc_large_heap_incremental_limit*/
        JSGC_LARGE_HEAP_INCREMENTAL_LIMIT = 26,
        /** Free space bytes threshold for eager nursery collection.

 Default: NurseryChunkUsableSize / 4
 Pref: javascript.options.mem.nursery_eager_collection_threshold_kb*/
        JSGC_NURSERY_EAGER_COLLECTION_THRESHOLD_KB = 27,
        /** Free space fraction threshold for eager nursery collection. This is a
 percentage (from 0 to 99).

 Default: 25
 Pref: javascript.options.mem.nursery_eager_collection_threshold_percent*/
        JSGC_NURSERY_EAGER_COLLECTION_THRESHOLD_PERCENT = 30,
        /** Minimum size of the generational GC nurseries.

 This value will be rounded to the nearest Nursery::SubChunkStep if below
 gc::ChunkSize, otherwise it'll be rounded to the nearest gc::ChunkSize.

 Default: Nursery::SubChunkLimit
 Pref: javascript.options.mem.nursery.min_kb*/
        JSGC_MIN_NURSERY_BYTES = 31,
        /** The minimum time to allow between triggering last ditch GCs in seconds.

 Default: 60 seconds
 Pref: None*/
        JSGC_MIN_LAST_DITCH_GC_PERIOD = 32,
        /** The delay (in heapsize kilobytes) between slices of an incremental GC.

 Default: ZoneAllocDelayBytes*/
        JSGC_ZONE_ALLOC_DELAY_KB = 33,
        /** The delay (in heapsize kilobytes) between slices of an incremental GC.

 Default: ZoneAllocDelayBytes*/
        JSGC_NURSERY_BYTES = 34,
        /** Retained size base value for calculating malloc heap threshold.

 Default: MallocThresholdBase*/
        JSGC_MALLOC_THRESHOLD_BASE = 35,
        /** Whether incremental weakmap marking is enabled.

 Pref: javascript.options.mem.incremental_weakmap
 Default: IncrementalWeakMarkEnabled*/
        JSGC_INCREMENTAL_WEAKMAP_ENABLED = 37,
        /** The chunk size in bytes for this system.

 This parameter is read-only.*/
        JSGC_CHUNK_BYTES = 38,
        /** The number of background threads to use for parallel GC work for each CPU
 core, expressed as an integer percentage.

 Pref: javascript.options.mem.gc_helper_thread_ratio*/
        JSGC_HELPER_THREAD_RATIO = 39,
        /** The maximum number of background threads to use for parallel GC work.

 Pref: javascript.options.mem.gc_max_helper_threads*/
        JSGC_MAX_HELPER_THREADS = 40,
        /** The number of background threads to use for parallel GC work.

 This parameter is read-only and is set based on the
 JSGC_HELPER_THREAD_RATIO and JSGC_MAX_HELPER_THREADS parameters.*/
        JSGC_HELPER_THREAD_COUNT = 41,
        /// A number that is incremented on every major GC slice.
        JSGC_MAJOR_GC_NUMBER = 44,
        /// A number that is incremented on every minor GC.
        JSGC_MINOR_GC_NUMBER = 45,
        /** JS::MaybeRunNurseryCollection will collect the nursery if it hasn't been
 collected in this many milliseconds.

 Default: 5000
 Pref: javascript.options.mem.nursery_eager_collection_timeout_ms*/
        JSGC_NURSERY_EAGER_COLLECTION_TIMEOUT_MS = 46,
        /** The system page size in KB.

 This parameter is read-only.*/
        JSGC_SYSTEM_PAGE_SIZE_KB = 47,
        /** In an incremental GC, this determines the point at which to start
 increasing the slice budget and frequency of allocation triggered slices to
 try to avoid reaching the incremental limit and finishing the collection
 synchronously.

 The threshold is calculated by subtracting this value from the heap's
 incremental limit.*/
        JSGC_URGENT_THRESHOLD_MB = 48,
        /** Get the number of threads used for parallel marking.

 Pref: None.*/
        JSGC_MARKING_THREAD_COUNT = 49,
        /** The heap size above which to use parallel marking.

 Pref: javascript.options.mem.gc_parallel_marking_threshold_mb
 Default: ParallelMarkingThresholdMB*/
        JSGC_PARALLEL_MARKING_THRESHOLD_MB = 50,
        /** Whether the semispace nursery is enabled.

 Pref: javascript.options.mem.gc_experimental_semispace_nursery
 Default: SemispaceNurseryEnabled*/
        JSGC_SEMISPACE_NURSERY_ENABLED = 51,
        /** Set the maximum number of threads to use for parallel marking, if enabled.

 The actual number used is calculated based on the number of available
 helper threads and can be found by getting the JSGC_MARKING_THREAD_COUNT
 parameter.

 Pref: javascript.options.mem.gc_max_parallel_marking_threads
 Default: 2.*/
        JSGC_MAX_MARKING_THREADS = 52,
        /** Whether to automatically generate missing allocation sites so data about
 them can be gathered.

 Pref: None, this is an internal engine feature.
 Default: false.*/
        JSGC_GENERATE_MISSING_ALLOC_SITES = 53,
        /// A number that is incremented every GC slice.
        JSGC_SLICE_NUMBER = 54,
    }
    pub type JSTraceDataOp = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSGrayRootsTracer = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            budget: *mut root::JS::SliceBudget,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSGCStatus {
        JSGC_BEGIN = 0,
        JSGC_END = 1,
    }
    pub type JSObjectsTenuredCallback = ::std::option::Option<
        unsafe extern "C" fn(
            gcx: *mut root::JS::GCContext,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSFinalizeStatus {
        /** Called when preparing to sweep a group of zones, before anything has been
 swept.  The collector will not yield to the mutator before calling the
 callback with JSFINALIZE_GROUP_START status.*/
        JSFINALIZE_GROUP_PREPARE = 0,
        /** Called after preparing to sweep a group of zones. Weak references to
 unmarked things have been removed at this point, but no GC things have
 been swept. The collector may yield to the mutator after this point.*/
        JSFINALIZE_GROUP_START = 1,
        /** Called after sweeping a group of zones. All dead GC things have been
 swept at this point.*/
        JSFINALIZE_GROUP_END = 2,
        /// Called at the end of collection when everything has been swept.
        JSFINALIZE_COLLECTION_END = 3,
    }
    pub type JSFinalizeCallback = ::std::option::Option<
        unsafe extern "C" fn(
            gcx: *mut root::JS::GCContext,
            status: root::JSFinalizeStatus,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSWeakPointerZonesCallback = ::std::option::Option<
        unsafe extern "C" fn(trc: *mut root::JSTracer, data: *mut ::std::os::raw::c_void),
    >;
    pub type JSWeakPointerCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            trc: *mut root::JSTracer,
            comp: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type JSHostCleanupFinalizationRegistryCallback = ::std::option::Option<
        unsafe extern "C" fn(
            doCleanup: *mut root::JSFunction,
            incumbentGlobal: *mut root::JSObject,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    #[repr(C)]
    pub struct JSExternalStringCallbacks__bindgen_vtable(::std::os::raw::c_void);
    /** Each external string has a pointer to JSExternalStringCallbacks. Embedders
 can use this to implement custom finalization or memory reporting behavior.*/
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSExternalStringCallbacks {
        pub vtable_: *const JSExternalStringCallbacks__bindgen_vtable,
    }
    pub type JSGCCallback = ::std::option::Option<
        unsafe extern "C" fn(
            cx: *mut root::JSContext,
            status: root::JSGCStatus,
            reason: root::JS::GCReason,
            data: *mut ::std::os::raw::c_void,
        ),
    >;
    #[repr(C)]
    pub struct JSErrorInterceptor__bindgen_vtable(::std::os::raw::c_void);
    /// Callback used to intercept JavaScript errors.
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorInterceptor {
        pub vtable_: *const JSErrorInterceptor__bindgen_vtable,
    }
    impl root::JSExnType {
        pub const JSEXN_FIRST: root::JSExnType = JSExnType::JSEXN_ERR;
    }
    impl root::JSExnType {
        pub const JSEXN_WARN: root::JSExnType = JSExnType::JSEXN_ERROR_LIMIT;
    }
    #[repr(u32)]
    /** Possible exception types. These types are part of a JSErrorFormatString
 structure. They define which error to throw in case of a runtime error.

 JSEXN_WARN is used for warnings, that are not strictly errors but are handled
 using the generalized error reporting mechanism.  (One side effect of this
 type is to not prepend 'Error:' to warning messages.)  This value can go away
 if we ever decide to use an entirely separate mechanism for warnings.*/
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSExnType {
        JSEXN_ERR = 0,
        JSEXN_INTERNALERR = 1,
        JSEXN_AGGREGATEERR = 2,
        JSEXN_EVALERR = 3,
        JSEXN_RANGEERR = 4,
        JSEXN_REFERENCEERR = 5,
        JSEXN_SYNTAXERR = 6,
        JSEXN_TYPEERR = 7,
        JSEXN_URIERR = 8,
        JSEXN_DEBUGGEEWOULDRUN = 9,
        JSEXN_WASMCOMPILEERROR = 10,
        JSEXN_WASMLINKERROR = 11,
        JSEXN_WASMRUNTIMEERROR = 12,
        JSEXN_ERROR_LIMIT = 13,
        JSEXN_NOTE = 14,
        JSEXN_LIMIT = 15,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorFormatString {
        /// The error message name in ASCII.
        pub name: *const ::std::os::raw::c_char,
        /// The error format string in ASCII.
        pub format: *const ::std::os::raw::c_char,
        /// The number of arguments to expand in the formatted error message.
        pub argCount: u16,
        /// One of the JSExnType constants above.
        pub exnType: i16,
    }
    pub type JSErrorCallback = ::std::option::Option<
        unsafe extern "C" fn(
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
        ) -> *const root::JSErrorFormatString,
    >;
    /** Base class that implements parts shared by JSErrorReport and
 JSErrorNotes::Note.*/
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorBase {
        pub message_: root::JS::ConstUTF8CharsZ,
        pub filename: root::JS::ConstUTF8CharsZ,
        pub sourceId: ::std::os::raw::c_uint,
        pub lineno: u32,
        pub column: root::JS::ColumnNumberOneOrigin,
        pub errorNumber: ::std::os::raw::c_uint,
        pub errorMessageName: *const ::std::os::raw::c_char,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: [u8; 3usize],
    }
    impl JSErrorBase {
        #[inline]
        pub fn ownsMessage_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsMessage_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            ownsMessage_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
            __bindgen_bitfield_unit
                .set(
                    0usize,
                    1u8,
                    {
                        let ownsMessage_: u8 = unsafe {
                            ::std::mem::transmute(ownsMessage_)
                        };
                        ownsMessage_ as u64
                    },
                );
            __bindgen_bitfield_unit
        }
        #[inline]
        pub unsafe fn newMessageString(
            &mut self,
            cx: *mut root::JSContext,
        ) -> *mut root::JSString {
            JSErrorBase_newMessageString(self, cx)
        }
    }
    /// Notes associated with JSErrorReport.
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorNotes {
        pub notes_: [u32; 6usize],
    }
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorNotes_Note {
        pub _base: root::JSErrorBase,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSErrorNotes_iterator {
        pub note_: *mut u32,
    }
    pub type JSErrorNotes_iterator_iterator_category = root::std::input_iterator_tag;
    /** UniquePtr is a smart pointer that wholly owns a resource.  Ownership may be
 transferred out of a UniquePtr through explicit action, but otherwise the
 resource is destroyed when the UniquePtr is destroyed.

 UniquePtr is similar to C++98's std::auto_ptr, but it improves upon auto_ptr
 in one crucial way: it's impossible to copy a UniquePtr.  Copying an auto_ptr
 obviously *can't* copy ownership of its singly-owned resource.  So what
 happens if you try to copy one?  Bizarrely, ownership is implicitly
 *transferred*, preserving single ownership but breaking code that assumes a
 copy of an object is identical to the original.  (This is why auto_ptr is
 prohibited in STL containers.)

 UniquePtr solves this problem by being *movable* rather than copyable.
 Instead of passing a |UniquePtr u| directly to the constructor or assignment
 operator, you pass |Move(u)|.  In doing so you indicate that you're *moving*
 ownership out of |u|, into the target of the construction/assignment.  After
 the transfer completes, |u| contains |nullptr| and may be safely destroyed.
 This preserves single ownership but also allows UniquePtr to be moved by
 algorithms that have been made move-safe.  (Note: if |u| is instead a
 temporary expression, don't use |Move()|: just pass the expression, because
 it's already move-ready.  For more information see Move.h.)

 UniquePtr is also better than std::auto_ptr in that the deletion operation is
 customizable.  An optional second template parameter specifies a class that
 (through its operator()(T*)) implements the desired deletion policy.  If no
 policy is specified, mozilla::DefaultDelete<T> is used -- which will either
 |delete| or |delete[]| the resource, depending whether the resource is an
 array.  Custom deletion policies ideally should be empty classes (no member
 fields, no member fields in base classes, no virtual methods/inheritance),
 because then UniquePtr can be just as efficient as a raw pointer.

 Use of UniquePtr proceeds like so:

   UniquePtr<int> g1; // initializes to nullptr
   g1.reset(new int); // switch resources using reset()
   g1 = nullptr; // clears g1, deletes the int

   UniquePtr<int> g2(new int); // owns that int
   int* p = g2.release(); // g2 leaks its int -- still requires deletion
   delete p; // now freed

   struct S { int x; S(int x) : x(x) {} };
   UniquePtr<S> g3, g4(new S(5));
   g3 = std::move(g4); // g3 owns the S, g4 cleared
   S* p = g3.get(); // g3 still owns |p|
   assert(g3->x == 5); // operator-> works (if .get() != nullptr)
   assert((*g3).x == 5); // also operator* (again, if not cleared)
   std::swap(g3, g4); // g4 now owns the S, g3 cleared
   g3.swap(g4);  // g3 now owns the S, g4 cleared
   UniquePtr<S> g5(std::move(g3)); // g5 owns the S, g3 cleared
   g5.reset(); // deletes the S, g5 cleared

   struct FreePolicy { void operator()(void* p) { free(p); } };
   UniquePtr<int, FreePolicy> g6(static_cast<int*>(malloc(sizeof(int))));
   int* ptr = g6.get();
   g6 = nullptr; // calls free(ptr)

 Now, carefully note a few things you *can't* do:

   UniquePtr<int> b1;
   b1 = new int; // BAD: can only assign another UniquePtr
   int* ptr = b1; // BAD: no auto-conversion to pointer, use get()

   UniquePtr<int> b2(b1); // BAD: can't copy a UniquePtr
   UniquePtr<int> b3 = b1; // BAD: can't copy-assign a UniquePtr

 (Note that changing a UniquePtr to store a direct |new| expression is
 permitted, but usually you should use MakeUnique, defined at the end of this
 header.)

 A few miscellaneous notes:

 UniquePtr, when not instantiated for an array type, can be move-constructed
 and move-assigned, not only from itself but from "derived" UniquePtr<U, E>
 instantiations where U converts to T and E converts to D.  If you want to use
 this, you're going to have to specify a deletion policy for both UniquePtr
 instantations, and T pretty much has to have a virtual destructor.  In other
 words, this doesn't work:

   struct Base { virtual ~Base() {} };
   struct Derived : Base {};

   UniquePtr<Base> b1;
   // BAD: DefaultDelete<Base> and DefaultDelete<Derived> don't interconvert
   UniquePtr<Derived> d1(std::move(b));

   UniquePtr<Base> b2;
   UniquePtr<Derived, DefaultDelete<Base>> d2(std::move(b2)); // okay

 UniquePtr is specialized for array types.  Specializing with an array type
 creates a smart-pointer version of that array -- not a pointer to such an
 array.

   UniquePtr<int[]> arr(new int[5]);
   arr[0] = 4;

 What else is different?  Deletion of course uses |delete[]|.  An operator[]
 is provided.  Functionality that doesn't make sense for arrays is removed.
 The constructors and mutating methods only accept array pointers (not T*, U*
 that converts to T*, or UniquePtr<U[]> or UniquePtr<U>) or |nullptr|.

 It's perfectly okay for a function to return a UniquePtr. This transfers
 the UniquePtr's sole ownership of the data, to the fresh UniquePtr created
 in the calling function, that will then solely own that data. Such functions
 can return a local variable UniquePtr, |nullptr|, |UniquePtr(ptr)| where
 |ptr| is a |T*|, or a UniquePtr |Move()|'d from elsewhere.

 UniquePtr will commonly be a member of a class, with lifetime equivalent to
 that of that class.  If you want to expose the related resource, you could
 expose a raw pointer via |get()|, but ownership of a raw pointer is
 inherently unclear.  So it's better to expose a |const UniquePtr&| instead.
 This prohibits mutation but still allows use of |get()| when needed (but
 operator-> is preferred).  Of course, you can only use this smart pointer as
 long as the enclosing class instance remains live -- no different than if you
 exposed the |get()| raw pointer.

 To pass a UniquePtr-managed resource as a pointer, use a |const UniquePtr&|
 argument.  To specify an inout parameter (where the method may or may not
 take ownership of the resource, or reset it), or to specify an out parameter
 (where simply returning a |UniquePtr| isn't possible), use a |UniquePtr&|
 argument.  To unconditionally transfer ownership of a UniquePtr
 into a method, use a |UniquePtr| argument.  To conditionally transfer
 ownership of a resource into a method, should the method want it, use a
 |UniquePtr&&| argument.*/
    pub type JSErrorNotes_iterator_value_type = u32;
    pub type JSErrorNotes_iterator_difference_type = isize;
    pub type JSErrorNotes_iterator_pointer = *mut root::JSErrorNotes_iterator_value_type;
    pub type JSErrorNotes_iterator_reference = *mut root::JSErrorNotes_iterator_value_type;
    impl JSErrorNotes {
        #[inline]
        pub unsafe fn length(&mut self) -> usize {
            JSErrorNotes_length(self)
        }
        #[inline]
        pub unsafe fn copy(&mut self, cx: *mut root::JSContext) -> u32 {
            JSErrorNotes_copy(self, cx)
        }
        #[inline]
        pub unsafe fn begin(&mut self) -> root::JSErrorNotes_iterator {
            JSErrorNotes_begin(self)
        }
        #[inline]
        pub unsafe fn end(&mut self) -> root::JSErrorNotes_iterator {
            JSErrorNotes_end(self)
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            JSErrorNotes_JSErrorNotes(__bindgen_tmp.as_mut_ptr());
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn destruct(&mut self) {
            JSErrorNotes_JSErrorNotes_destructor(self)
        }
    }
    /// Describes a single error or warning that occurs in the execution of script.
    #[repr(C)]
    #[derive(Debug, PartialEq)]
    pub struct JSErrorReport {
        pub _base: root::JSErrorBase,
        pub linebuf_: *const u16,
        pub linebufLength_: usize,
        pub tokenOffset_: usize,
        pub notes: u32,
        pub exnType: i16,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub __bindgen_padding_0: u8,
    }
    impl JSErrorReport {
        #[inline]
        pub fn isMuted(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isMuted(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn isWarning_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_isWarning_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ownsLinebuf_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ownsLinebuf_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            isMuted: bool,
            isWarning_: bool,
            ownsLinebuf_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
            __bindgen_bitfield_unit
                .set(
                    0usize,
                    1u8,
                    {
                        let isMuted: u8 = unsafe { ::std::mem::transmute(isMuted) };
                        isMuted as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    1usize,
                    1u8,
                    {
                        let isWarning_: u8 = unsafe {
                            ::std::mem::transmute(isWarning_)
                        };
                        isWarning_ as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    2usize,
                    1u8,
                    {
                        let ownsLinebuf_: u8 = unsafe {
                            ::std::mem::transmute(ownsLinebuf_)
                        };
                        ownsLinebuf_ as u64
                    },
                );
            __bindgen_bitfield_unit
        }
        #[inline]
        pub unsafe fn initBorrowedLinebuf(
            &mut self,
            linebufArg: *const u16,
            linebufLengthArg: usize,
            tokenOffsetArg: usize,
        ) {
            JSErrorReport_initBorrowedLinebuf(
                self,
                linebufArg,
                linebufLengthArg,
                tokenOffsetArg,
            )
        }
    }
    pub type JSInterruptCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JSContext) -> bool,
    >;
    pub type JSIterateCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: *mut ::std::os::raw::c_void,
            arg3: *mut root::JS::Compartment,
        ) -> root::JS::CompartmentIterResult,
    >;
    /** Callback used to ask the embedding for the cross compartment wrapper handler
 that implements the desired prolicy for this kind of object in the
 destination compartment. |obj| is the object to be wrapped. If |existing| is
 non-nullptr, it will point to an existing wrapper object that should be
 re-used if possible. |existing| is guaranteed to be a cross-compartment
 wrapper with a lazily-defined prototype and the correct global. It is
 guaranteed not to wrap a function.*/
    pub type JSWrapObjectCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
        ) -> *mut root::JSObject,
    >;
    /** Callback used by the wrap hook to ask the embedding to prepare an object
 for wrapping in a context. This might include unwrapping other wrappers
 or even finding a more suitable object for the new compartment. If |origObj|
 is non-null, then it is the original object we are going to swap into during
 a transplant.*/
    pub type JSPreWrapCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JSContext,
            arg2: root::JS::HandleObject,
            arg3: root::JS::HandleObject,
            arg4: root::JS::HandleObject,
            arg5: root::JS::HandleObject,
            arg6: root::JS::MutableHandleObject,
        ),
    >;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSWrapObjectCallbacks {
        pub wrap: root::JSWrapObjectCallback,
        pub preWrap: root::JSPreWrapCallback,
    }
    pub type JSDestroyZoneCallback = ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut root::JS::GCContext, arg2: *mut root::JS::Zone),
    >;
    pub type JSDestroyCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut root::JS::GCContext,
            arg2: *mut root::JS::Compartment,
        ),
    >;
    pub type JSSizeOfIncludingThisCompartmentCallback = ::std::option::Option<
        unsafe extern "C" fn(
            arg1: root::mozilla::MallocSizeOf,
            arg2: *mut root::JS::Compartment,
        ) -> usize,
    >;
    pub const JSFUN_CONSTRUCTOR: ::std::os::raw::c_uint = 1024;
    pub const JSFUN_FLAGS_MASK: ::std::os::raw::c_uint = 1024;
    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum JSJitCompilerOption {
        JSJITCOMPILER_BASELINE_INTERPRETER_WARMUP_TRIGGER = 0,
        JSJITCOMPILER_BASELINE_WARMUP_TRIGGER = 1,
        JSJITCOMPILER_IC_FORCE_MEGAMORPHIC = 2,
        JSJITCOMPILER_ION_NORMAL_WARMUP_TRIGGER = 3,
        JSJITCOMPILER_ION_GVN_ENABLE = 4,
        JSJITCOMPILER_ION_FORCE_IC = 5,
        JSJITCOMPILER_ION_ENABLE = 6,
        JSJITCOMPILER_JIT_TRUSTEDPRINCIPALS_ENABLE = 7,
        JSJITCOMPILER_ION_CHECK_RANGE_ANALYSIS = 8,
        JSJITCOMPILER_ION_FREQUENT_BAILOUT_THRESHOLD = 9,
        JSJITCOMPILER_BASE_REG_FOR_LOCALS = 10,
        JSJITCOMPILER_INLINING_BYTECODE_MAX_LENGTH = 11,
        JSJITCOMPILER_BASELINE_INTERPRETER_ENABLE = 12,
        JSJITCOMPILER_BASELINE_ENABLE = 13,
        JSJITCOMPILER_PORTABLE_BASELINE_ENABLE = 14,
        JSJITCOMPILER_PORTABLE_BASELINE_WARMUP_THRESHOLD = 15,
        JSJITCOMPILER_OFFTHREAD_COMPILATION_ENABLE = 16,
        JSJITCOMPILER_FULL_DEBUG_CHECKS = 17,
        JSJITCOMPILER_JUMP_THRESHOLD = 18,
        JSJITCOMPILER_NATIVE_REGEXP_ENABLE = 19,
        JSJITCOMPILER_JIT_HINTS_ENABLE = 20,
        JSJITCOMPILER_SIMULATOR_ALWAYS_INTERRUPT = 21,
        JSJITCOMPILER_SPECTRE_INDEX_MASKING = 22,
        JSJITCOMPILER_SPECTRE_OBJECT_MITIGATIONS = 23,
        JSJITCOMPILER_SPECTRE_STRING_MITIGATIONS = 24,
        JSJITCOMPILER_SPECTRE_VALUE_MASKING = 25,
        JSJITCOMPILER_SPECTRE_JIT_TO_CXX_CALLS = 26,
        JSJITCOMPILER_WRITE_PROTECT_CODE = 27,
        JSJITCOMPILER_WASM_FOLD_OFFSETS = 28,
        JSJITCOMPILER_WASM_DELAY_TIER2 = 29,
        JSJITCOMPILER_WASM_JIT_BASELINE = 30,
        JSJITCOMPILER_WASM_JIT_OPTIMIZING = 31,
        JSJITCOMPILER_REGEXP_DUPLICATE_NAMED_GROUPS = 32,
        JSJITCOMPILER_NOT_AN_OPTION = 33,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSFunctionSpecWithHelp {
        pub name: *const ::std::os::raw::c_char,
        pub call: root::JSNative,
        pub nargs: u16,
        pub flags: u16,
        pub jitInfo: *const root::JSJitInfo,
        pub usage: *const ::std::os::raw::c_char,
        pub help: *const ::std::os::raw::c_char,
    }
    /// <div rustbindgen replaces="JSJitMethodCallArgs"></div>
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct JSJitMethodCallArgs {
        pub argv_: *mut root::JS::Value,
        pub argc_: ::std::os::raw::c_uint,
        pub _bitfield_align_1: [u8; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize]>,
        pub wantUsedRval_: root::JS::detail::NoUsedRval,
    }
    impl JSJitMethodCallArgs {
        #[inline]
        pub fn constructing_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_constructing_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn ignoresReturnValue_(&self) -> bool {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
        }
        #[inline]
        pub fn set_ignoresReturnValue_(&mut self, val: bool) {
            unsafe {
                let val: u8 = ::std::mem::transmute(val);
                self._bitfield_1.set(1usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            constructing_: bool,
            ignoresReturnValue_: bool,
        ) -> root::__BindgenBitfieldUnit<[u8; 1usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
            __bindgen_bitfield_unit
                .set(
                    0usize,
                    1u8,
                    {
                        let constructing_: u8 = unsafe {
                            ::std::mem::transmute(constructing_)
                        };
                        constructing_ as u64
                    },
                );
            __bindgen_bitfield_unit
                .set(
                    1usize,
                    1u8,
                    {
                        let ignoresReturnValue_: u8 = unsafe {
                            ::std::mem::transmute(ignoresReturnValue_)
                        };
                        ignoresReturnValue_ as u64
                    },
                );
            __bindgen_bitfield_unit
        }
    }
    pub mod jsglue {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type WantToMeasure = ::std::option::Option<
            unsafe extern "C" fn(obj: *mut root::JSObject) -> bool,
        >;
        pub type GetSize = ::std::option::Option<
            unsafe extern "C" fn(obj: *mut root::JSObject) -> usize,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JobQueueTraps {
            pub getIncumbentGlobal: ::std::option::Option<
                unsafe extern "C" fn(
                    queue: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                ) -> *mut root::JSObject,
            >,
            pub enqueuePromiseJob: ::std::option::Option<
                unsafe extern "C" fn(
                    queue: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    promise: root::JS::HandleObject,
                    job: root::JS::HandleObject,
                    allocationSite: root::JS::HandleObject,
                    incumbentGlobal: root::JS::HandleObject,
                ) -> bool,
            >,
            pub empty: ::std::option::Option<
                unsafe extern "C" fn(queue: *const ::std::os::raw::c_void) -> bool,
            >,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RustJobQueue {
            pub _base: root::JS::JobQueue,
            pub mTraps: root::jsglue::JobQueueTraps,
            pub mQueue: *const ::std::os::raw::c_void,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ReadableStreamUnderlyingSourceTraps {
            pub requestData: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    stream: root::JS::HandleObject,
                    desiredSize: usize,
                ),
            >,
            pub writeIntoReadRequestBuffer: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    stream: root::JS::HandleObject,
                    chunk: root::JS::HandleObject,
                    length: usize,
                    bytesWritten: *mut usize,
                ),
            >,
            pub cancel: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    stream: root::JS::HandleObject,
                    reason: root::JS::HandleValue,
                    resolve_to: *mut root::JS::Value,
                ),
            >,
            pub onClosed: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    stream: root::JS::HandleObject,
                ),
            >,
            pub onErrored: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *const ::std::os::raw::c_void,
                    cx: *mut root::JSContext,
                    stream: root::JS::HandleObject,
                    reason: root::JS::HandleValue,
                ),
            >,
            pub finalize: ::std::option::Option<
                unsafe extern "C" fn(
                    source: *mut root::JS::ReadableStreamUnderlyingSource,
                ),
            >,
        }
        #[repr(C)]
        #[derive(Debug, PartialEq)]
        pub struct RustReadableStreamUnderlyingSource {
            pub _base: root::JS::ReadableStreamUnderlyingSource,
            pub mTraps: root::jsglue::ReadableStreamUnderlyingSourceTraps,
            pub mSource: *const ::std::os::raw::c_void,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSExternalStringCallbacksTraps {
            pub finalize: ::std::option::Option<
                unsafe extern "C" fn(
                    privateData: *const ::std::os::raw::c_void,
                    chars: *mut u16,
                ),
            >,
            pub finalize_latin1: ::std::option::Option<
                unsafe extern "C" fn(
                    privateData: *const ::std::os::raw::c_void,
                    chars: *mut root::JS::Latin1Char,
                ),
            >,
            pub sizeOfBuffer: ::std::option::Option<
                unsafe extern "C" fn(
                    privateData: *const ::std::os::raw::c_void,
                    chars: *const u16,
                    mallocSizeOf: root::mozilla::MallocSizeOf,
                ) -> usize,
            >,
            pub sizeOfBuffer_latin1: ::std::option::Option<
                unsafe extern "C" fn(
                    privateData: *const ::std::os::raw::c_void,
                    chars: *const root::JS::Latin1Char,
                    mallocSizeOf: root::mozilla::MallocSizeOf,
                ) -> usize,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RustJSExternalStringCallbacks {
            pub _base: root::JSExternalStringCallbacks,
            pub mTraps: root::jsglue::JSExternalStringCallbacksTraps,
            pub privateData: *mut ::std::os::raw::c_void,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ProxyTraps {
            pub enter: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    action: root::js::BaseProxyHandler_Action,
                    bp: *mut bool,
                ) -> bool,
            >,
            pub getOwnPropertyDescriptor: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                    isNone: *mut bool,
                ) -> bool,
            >,
            pub defineProperty: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    desc: root::JS::Handle<root::JS::PropertyDescriptor>,
                    result: *mut root::JS::ObjectOpResult,
                ) -> bool,
            >,
            pub ownPropertyKeys: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    props: root::JS::MutableHandleIdVector,
                ) -> bool,
            >,
            pub delete_: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    result: *mut root::JS::ObjectOpResult,
                ) -> bool,
            >,
            pub enumerate: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    props: root::JS::MutableHandleIdVector,
                ) -> bool,
            >,
            pub getPrototypeIfOrdinary: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    isOrdinary: *mut bool,
                    protop: root::JS::MutableHandleObject,
                ) -> bool,
            >,
            pub getPrototype: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    protop: root::JS::MutableHandleObject,
                ) -> bool,
            >,
            pub setPrototype: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    proto: root::JS::HandleObject,
                    result: *mut root::JS::ObjectOpResult,
                ) -> bool,
            >,
            pub setImmutablePrototype: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    succeeded: *mut bool,
                ) -> bool,
            >,
            pub preventExtensions: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    result: *mut root::JS::ObjectOpResult,
                ) -> bool,
            >,
            pub isExtensible: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    succeeded: *mut bool,
                ) -> bool,
            >,
            pub has: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    bp: *mut bool,
                ) -> bool,
            >,
            pub get: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    receiver: root::JS::HandleValue,
                    id: root::JS::HandleId,
                    vp: root::JS::MutableHandleValue,
                ) -> bool,
            >,
            pub set: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    v: root::JS::HandleValue,
                    receiver: root::JS::HandleValue,
                    result: *mut root::JS::ObjectOpResult,
                ) -> bool,
            >,
            pub call: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    args: *const root::JS::CallArgs,
                ) -> bool,
            >,
            pub construct: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    args: *const root::JS::CallArgs,
                ) -> bool,
            >,
            pub hasOwn: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    id: root::JS::HandleId,
                    bp: *mut bool,
                ) -> bool,
            >,
            pub getOwnEnumerablePropertyKeys: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    props: root::JS::MutableHandleIdVector,
                ) -> bool,
            >,
            pub nativeCall: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    test: root::JS::IsAcceptableThis,
                    impl_: root::JS::NativeImpl,
                    args: root::JS::CallArgs,
                ) -> bool,
            >,
            pub objectClassIs: ::std::option::Option<
                unsafe extern "C" fn(
                    obj: root::JS::HandleObject,
                    classValue: root::js::ESClass,
                    cx: *mut root::JSContext,
                ) -> bool,
            >,
            pub className: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                ) -> *const ::std::os::raw::c_char,
            >,
            pub fun_toString: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    isToString: bool,
                ) -> *mut root::JSString,
            >,
            pub boxedValue_unbox: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    proxy: root::JS::HandleObject,
                    vp: root::JS::MutableHandleValue,
                ) -> bool,
            >,
            pub defaultValue: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JSContext,
                    obj: root::JS::HandleObject,
                    hint: root::JSType,
                    vp: root::JS::MutableHandleValue,
                ) -> bool,
            >,
            pub trace: ::std::option::Option<
                unsafe extern "C" fn(
                    trc: *mut root::JSTracer,
                    proxy: *mut root::JSObject,
                ),
            >,
            pub finalize: ::std::option::Option<
                unsafe extern "C" fn(
                    cx: *mut root::JS::GCContext,
                    proxy: *mut root::JSObject,
                ),
            >,
            pub objectMoved: ::std::option::Option<
                unsafe extern "C" fn(
                    proxy: *mut root::JSObject,
                    old: *mut root::JSObject,
                ) -> usize,
            >,
            pub isCallable: ::std::option::Option<
                unsafe extern "C" fn(obj: *mut root::JSObject) -> bool,
            >,
            pub isConstructor: ::std::option::Option<
                unsafe extern "C" fn(obj: *mut root::JSObject) -> bool,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct WrapperProxyHandler {
            pub _base: root::js::Wrapper,
            pub mTraps: root::jsglue::ProxyTraps,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ForwardingProxyHandler {
            pub _base: root::js::BaseProxyHandler,
            pub mTraps: root::jsglue::ProxyTraps,
            pub mExtra: *const ::std::os::raw::c_void,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct ServoDOMVisitor {
            pub _base: root::JS::ObjectPrivateVisitor,
            pub get_size: root::jsglue::GetSize,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct JSPrincipalsCallbacks {
            pub write: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::JSPrincipals,
                    cx: *mut root::JSContext,
                    writer: *mut root::JSStructuredCloneWriter,
                ) -> bool,
            >,
            pub isSystemOrAddonPrincipal: ::std::option::Option<
                unsafe extern "C" fn(arg1: *mut root::JSPrincipals) -> bool,
            >,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq)]
        pub struct RustJSPrincipals {
            pub _base: root::JSPrincipals,
            pub callbacks: root::jsglue::JSPrincipalsCallbacks,
            pub privateData: *mut ::std::os::raw::c_void,
        }
        pub type EncodedStringCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
        >;
        extern "C" {
            #[link_name = "\u{1}_ZN6jsglue7JS_InitEv"]
            pub fn JS_Init() -> bool;
            #[link_name = "\u{1}_ZN6jsglue18JS_NewRealmOptionsEv"]
            pub fn JS_NewRealmOptions() -> *mut root::JS::RealmOptions;
            #[link_name = "\u{1}_ZN6jsglue18DeleteRealmOptionsEPN2JS12RealmOptionsE"]
            pub fn DeleteRealmOptions(options: *mut root::JS::RealmOptions);
            #[link_name = "\u{1}_ZN6jsglue26JS_NewOwningCompileOptionsEP9JSContext"]
            pub fn JS_NewOwningCompileOptions(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::OwningCompileOptions;
            #[link_name = "\u{1}_ZN6jsglue26DeleteOwningCompileOptionsEPN2JS20OwningCompileOptionsE"]
            pub fn DeleteOwningCompileOptions(opts: *mut root::JS::OwningCompileOptions);
            #[link_name = "\u{1}_ZN6jsglue15JS_AsShadowZoneEPN2JS4ZoneE"]
            pub fn JS_AsShadowZone(
                zone: *mut root::JS::Zone,
            ) -> *mut root::JS::shadow::Zone;
            #[link_name = "\u{1}_ZN6jsglue17JS_CallArgsFromVpEjPN2JS5ValueE"]
            pub fn JS_CallArgsFromVp(
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> root::JS::CallArgs;
            #[link_name = "\u{1}_ZN6jsglue25JS_StackCapture_AllFramesEPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_AllFrames(capture: *mut root::JS::StackCapture);
            #[link_name = "\u{1}_ZN6jsglue25JS_StackCapture_MaxFramesEjPN7mozilla7VariantIJN2JS9AllFramesENS2_9MaxFramesENS2_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_MaxFrames(
                max: u32,
                capture: *mut root::JS::StackCapture,
            );
            #[link_name = "\u{1}_ZN6jsglue34JS_StackCapture_FirstSubsumedFrameEP9JSContextbPN7mozilla7VariantIJN2JS9AllFramesENS4_9MaxFramesENS4_18FirstSubsumedFrameEEEE"]
            pub fn JS_StackCapture_FirstSubsumedFrame(
                cx: *mut root::JSContext,
                ignoreSelfHostedFrames: bool,
                capture: *mut root::JS::StackCapture,
            );
            #[link_name = "\u{1}_ZN6jsglue21GetLinearStringLengthEP14JSLinearString"]
            pub fn GetLinearStringLength(s: *mut root::JSLinearString) -> usize;
            #[link_name = "\u{1}_ZN6jsglue21GetLinearStringCharAtEP14JSLinearStringm"]
            pub fn GetLinearStringCharAt(
                s: *mut root::JSLinearString,
                idx: usize,
            ) -> u16;
            #[link_name = "\u{1}_ZN6jsglue18AtomToLinearStringEP6JSAtom"]
            pub fn AtomToLinearString(
                atom: *mut root::JSAtom,
            ) -> *mut root::JSLinearString;
            #[link_name = "\u{1}_ZN6jsglue20JS_ForOfIteratorInitEPN2JS13ForOfIteratorENS0_6HandleINS0_5ValueEEENS1_19NonIterableBehaviorE"]
            pub fn JS_ForOfIteratorInit(
                iterator: *mut root::JS::ForOfIterator,
                iterable: root::JS::HandleValue,
                nonIterableBehavior: root::JS::ForOfIterator_NonIterableBehavior,
            ) -> bool;
            #[link_name = "\u{1}_ZN6jsglue20JS_ForOfIteratorNextEPN2JS13ForOfIteratorENS0_13MutableHandleINS0_5ValueEEEPb"]
            pub fn JS_ForOfIteratorNext(
                iterator: *mut root::JS::ForOfIterator,
                val: root::JS::MutableHandleValue,
                done: *mut bool,
            ) -> bool;
            #[link_name = "\u{1}_ZN6jsglue18JS_ValueSetBooleanEPN2JS5ValueEb"]
            pub fn JS_ValueSetBoolean(value: *mut root::JS::Value, x: bool);
            #[link_name = "\u{1}_ZN6jsglue17JS_ValueIsBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueIsBoolean(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue17JS_ValueToBooleanEPKN2JS5ValueE"]
            pub fn JS_ValueToBoolean(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue17JS_ValueSetDoubleEPN2JS5ValueEd"]
            pub fn JS_ValueSetDouble(value: *mut root::JS::Value, x: f64);
            #[link_name = "\u{1}_ZN6jsglue16JS_ValueIsDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueIsDouble(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue16JS_ValueToDoubleEPKN2JS5ValueE"]
            pub fn JS_ValueToDouble(value: *const root::JS::Value) -> f64;
            #[link_name = "\u{1}_ZN6jsglue16JS_ValueSetInt32EPN2JS5ValueEi"]
            pub fn JS_ValueSetInt32(value: *mut root::JS::Value, x: i32);
            #[link_name = "\u{1}_ZN6jsglue15JS_ValueIsInt32EPKN2JS5ValueE"]
            pub fn JS_ValueIsInt32(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue15JS_ValueToInt32EPKN2JS5ValueE"]
            pub fn JS_ValueToInt32(value: *const root::JS::Value) -> i32;
            #[link_name = "\u{1}_ZN6jsglue16JS_ValueIsNumberEPKN2JS5ValueE"]
            pub fn JS_ValueIsNumber(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue16JS_ValueToNumberEPKN2JS5ValueE"]
            pub fn JS_ValueToNumber(value: *const root::JS::Value) -> f64;
            #[link_name = "\u{1}_ZN6jsglue15JS_ValueSetNullEPN2JS5ValueE"]
            pub fn JS_ValueSetNull(value: *mut root::JS::Value);
            #[link_name = "\u{1}_ZN6jsglue14JS_ValueIsNullEPKN2JS5ValueE"]
            pub fn JS_ValueIsNull(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue19JS_ValueIsUndefinedEPKN2JS5ValueE"]
            pub fn JS_ValueIsUndefined(value: *const root::JS::Value) -> bool;
            #[link_name = "\u{1}_ZN6jsglue12GetErrorTypeERKN2JS5ValueE"]
            pub fn GetErrorType(val: *const root::JS::Value) -> root::JSExnType;
            #[link_name = "\u{1}_ZN6jsglue14gWantToMeasureE"]
            pub static mut gWantToMeasure: root::jsglue::WantToMeasure;
            #[link_name = "\u{1}_ZNK6jsglue12RustJobQueue17isDrainingStoppedEv"]
            pub fn RustJobQueue_isDrainingStopped(
                this: *mut ::std::os::raw::c_void,
            ) -> bool;
            #[link_name = "\u{1}_ZN6jsglueL13HandlerFamilyE"]
            pub static mut HandlerFamily: ::std::os::raw::c_int;
            #[link_name = "\u{1}_ZN6jsglue19ShouldMeasureObjectEP8JSObjectPP11nsISupports"]
            pub fn ShouldMeasureObject(
                obj: *mut root::JSObject,
                iface: *mut *mut root::nsISupports,
            ) -> bool;
            pub fn CreateRustJSPrincipals(
                callbacks: *const root::jsglue::JSPrincipalsCallbacks,
                privateData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSPrincipals;
            pub fn DestroyRustJSPrincipals(principals: *mut root::JSPrincipals);
            pub fn GetRustJSPrincipalsPrivate(
                principals: *mut root::JSPrincipals,
            ) -> *mut ::std::os::raw::c_void;
            pub fn InvokeGetOwnPropertyDescriptor(
                handler: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                isNone: *mut bool,
            ) -> bool;
            pub fn InvokeHasOwn(
                handler: *const ::std::os::raw::c_void,
                cx: *mut root::JSContext,
                proxy: root::JS::HandleObject,
                id: root::JS::HandleId,
                bp: *mut bool,
            ) -> bool;
            pub fn RUST_FUNCTION_VALUE_TO_JITINFO(
                v: root::JS::Value,
            ) -> *const root::JSJitInfo;
            pub fn CallJitGetterOp(
                info: *const root::JSJitInfo,
                cx: *mut root::JSContext,
                thisObj: root::JS::HandleObject,
                specializedThis: *mut ::std::os::raw::c_void,
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> bool;
            pub fn CallJitSetterOp(
                info: *const root::JSJitInfo,
                cx: *mut root::JSContext,
                thisObj: root::JS::HandleObject,
                specializedThis: *mut ::std::os::raw::c_void,
                argc: ::std::os::raw::c_uint,
                vp: *mut root::JS::Value,
            ) -> bool;
            pub fn CallJitMethodOp(
                info: *const root::JSJitInfo,
                cx: *mut root::JSContext,
                thisObj: root::JS::HandleObject,
                specializedThis: *mut ::std::os::raw::c_void,
                argc: u32,
                vp: *mut root::JS::Value,
            ) -> bool;
            pub fn CreateProxyHandler(
                aTraps: *const root::jsglue::ProxyTraps,
                aExtra: *const ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_void;
            pub fn CreateWrapperProxyHandler(
                aTraps: *const root::jsglue::ProxyTraps,
            ) -> *const ::std::os::raw::c_void;
            pub fn GetCrossCompartmentWrapper() -> *const ::std::os::raw::c_void;
            pub fn GetSecurityWrapper() -> *const ::std::os::raw::c_void;
            pub fn DeleteCompileOptions(aOpts: *mut root::JS::ReadOnlyCompileOptions);
            pub fn NewCompileOptions(
                aCx: *mut root::JSContext,
                aFile: *const ::std::os::raw::c_char,
                aLine: ::std::os::raw::c_uint,
            ) -> *mut root::JS::ReadOnlyCompileOptions;
            pub fn WrapperNew(
                aCx: *mut root::JSContext,
                aObj: root::JS::HandleObject,
                aHandler: *const ::std::os::raw::c_void,
                aClass: *const root::JSClass,
            ) -> *mut root::JSObject;
            #[link_name = "\u{1}_ZN6jsglueL16WindowProxyClassE"]
            pub static WindowProxyClass: root::JSClass;
            pub fn GetWindowProxyClass() -> *const root::JSClass;
            pub fn NewWindowProxy(
                aCx: *mut root::JSContext,
                aObj: root::JS::HandleObject,
                aHandler: *const ::std::os::raw::c_void,
            ) -> *mut root::JSObject;
            pub fn GetProxyReservedSlot(
                obj: *mut root::JSObject,
                slot: u32,
                dest: *mut root::JS::Value,
            );
            pub fn GetProxyPrivate(obj: *mut root::JSObject, dest: *mut root::JS::Value);
            pub fn SetProxyReservedSlot(
                obj: *mut root::JSObject,
                slot: u32,
                val: *const root::JS::Value,
            );
            pub fn SetProxyPrivate(
                obj: *mut root::JSObject,
                expando: *const root::JS::Value,
            );
            pub fn RUST_JSID_IS_INT(id: root::JS::HandleId) -> bool;
            pub fn int_to_jsid(i: i32, id: root::JS::MutableHandleId);
            pub fn RUST_JSID_TO_INT(id: root::JS::HandleId) -> i32;
            pub fn RUST_JSID_IS_STRING(id: root::JS::HandleId) -> bool;
            pub fn RUST_JSID_TO_STRING(id: root::JS::HandleId) -> *mut root::JSString;
            pub fn RUST_SYMBOL_TO_JSID(
                sym: *mut root::JS::Symbol,
                id: root::JS::MutableHandleId,
            );
            pub fn RUST_JSID_IS_VOID(id: root::JS::HandleId) -> bool;
            pub fn SetBuildId(
                buildId: *mut root::JS::BuildIdCharVector,
                chars: *const ::std::os::raw::c_char,
                len: usize,
            ) -> bool;
            pub fn RUST_SET_JITINFO(
                func: *mut root::JSFunction,
                info: *const root::JSJitInfo,
            );
            pub fn RUST_INTERNED_STRING_TO_JSID(
                cx: *mut root::JSContext,
                str_: *mut root::JSString,
                id: root::JS::MutableHandleId,
            );
            pub fn RUST_js_GetErrorMessage(
                userRef: *mut ::std::os::raw::c_void,
                errorNumber: u32,
            ) -> *const root::JSErrorFormatString;
            pub fn IsProxyHandlerFamily(obj: *mut root::JSObject) -> bool;
            pub fn GetProxyHandlerFamily() -> *const ::std::os::raw::c_void;
            pub fn GetProxyHandlerExtra(
                obj: *mut root::JSObject,
            ) -> *const ::std::os::raw::c_void;
            pub fn GetProxyHandler(
                obj: *mut root::JSObject,
            ) -> *const ::std::os::raw::c_void;
            pub fn ReportErrorASCII(
                aCx: *mut root::JSContext,
                aError: *const ::std::os::raw::c_char,
            );
            pub fn ReportErrorUTF8(
                aCx: *mut root::JSContext,
                aError: *const ::std::os::raw::c_char,
            );
            pub fn IsWrapper(obj: *mut root::JSObject) -> bool;
            pub fn UnwrapObjectStatic(obj: *mut root::JSObject) -> *mut root::JSObject;
            pub fn UnwrapObjectDynamic(
                obj: *mut root::JSObject,
                cx: *mut root::JSContext,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
            pub fn UncheckedUnwrapObject(
                obj: *mut root::JSObject,
                stopAtWindowProxy: bool,
            ) -> *mut root::JSObject;
            pub fn CreateRootedIdVector(
                cx: *mut root::JSContext,
            ) -> *mut root::JS::PersistentRootedIdVector;
            pub fn GetIdVectorAddress(
                v: *mut root::JS::PersistentRootedIdVector,
            ) -> *mut ::std::os::raw::c_void;
            pub fn SliceRootedIdVector(
                v: *const root::JS::PersistentRootedIdVector,
                length: *mut usize,
            ) -> *const root::jsid;
            pub fn AppendToIdVector(
                v: root::JS::MutableHandleIdVector,
                id: root::JS::HandleId,
            ) -> bool;
            pub fn DestroyRootedIdVector(v: *mut root::JS::PersistentRootedIdVector);
            pub fn CreateRootedObjectVector(
                aCx: *mut root::JSContext,
            ) -> *mut root::JS::PersistentRootedObjectVector;
            pub fn GetObjectVectorAddress(
                v: *mut root::JS::PersistentRootedObjectVector,
            ) -> *mut ::std::os::raw::c_void;
            pub fn AppendToRootedObjectVector(
                v: *mut root::JS::PersistentRootedObjectVector,
                obj: *mut root::JSObject,
            ) -> bool;
            pub fn DeleteRootedObjectVector(
                v: *mut root::JS::PersistentRootedObjectVector,
            );
            pub fn malloc_usable_size(arg1: *mut ::std::os::raw::c_void) -> usize;
            #[link_name = "\u{1}_ZN6jsglueL12MallocSizeOfEPKv"]
            pub fn MallocSizeOf(aPtr: *const ::std::os::raw::c_void) -> usize;
            pub fn CollectServoSizes(
                cx: *mut root::JSContext,
                sizes: *mut root::JS::ServoSizes,
                gs: root::jsglue::GetSize,
            ) -> bool;
            pub fn InitializeMemoryReporter(wtm: root::jsglue::WantToMeasure);
            pub fn CallValueTracer(
                trc: *mut root::JSTracer,
                valuep: *mut root::JS::Heap<root::JS::Value>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallIdTracer(
                trc: *mut root::JSTracer,
                idp: *mut root::JS::Heap<root::jsid>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallObjectTracer(
                trc: *mut root::JSTracer,
                objp: *mut root::JS::Heap<*mut root::JSObject>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallStringTracer(
                trc: *mut root::JSTracer,
                strp: *mut root::JS::Heap<*mut root::JSString>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallSymbolTracer(
                trc: *mut root::JSTracer,
                bip: *mut root::JS::Heap<*mut root::JS::Symbol>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallBigIntTracer(
                trc: *mut root::JSTracer,
                bip: *mut root::JS::Heap<*mut root::JS::BigInt>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallScriptTracer(
                trc: *mut root::JSTracer,
                scriptp: *mut root::JS::Heap<*mut root::JSScript>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallFunctionTracer(
                trc: *mut root::JSTracer,
                funp: *mut root::JS::Heap<*mut root::JSFunction>,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallUnbarrieredObjectTracer(
                trc: *mut root::JSTracer,
                objp: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallObjectRootTracer(
                trc: *mut root::JSTracer,
                objp: *mut *mut root::JSObject,
                name: *const ::std::os::raw::c_char,
            );
            pub fn CallValueRootTracer(
                trc: *mut root::JSTracer,
                valp: *mut root::JS::Value,
                name: *const ::std::os::raw::c_char,
            );
            pub fn IsDebugBuild() -> bool;
            pub fn GetInt8ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut i8,
            );
            pub fn GetUint8ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            pub fn GetUint8ClampedArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u8,
            );
            pub fn GetInt16ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut i16,
            );
            pub fn GetUint16ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u16,
            );
            pub fn GetInt32ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut i32,
            );
            pub fn GetUint32ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut u32,
            );
            pub fn GetFloat32ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut f32,
            );
            pub fn GetFloat64ArrayLengthAndData(
                obj: *mut root::JSObject,
                length: *mut usize,
                isSharedMemory: *mut bool,
                data: *mut *mut f64,
            );
            pub fn NewJSAutoStructuredCloneBuffer(
                scope: root::JS::StructuredCloneScope,
                callbacks: *const root::JSStructuredCloneCallbacks,
            ) -> *mut root::JSAutoStructuredCloneBuffer;
            pub fn DeleteJSAutoStructuredCloneBuffer(
                buf: *mut root::JSAutoStructuredCloneBuffer,
            );
            pub fn GetLengthOfJSStructuredCloneData(
                data: *mut root::JSStructuredCloneData,
            ) -> usize;
            pub fn CopyJSStructuredCloneData(
                src: *mut root::JSStructuredCloneData,
                dest: *mut u8,
            );
            pub fn WriteBytesToJSStructuredCloneData(
                src: *const u8,
                len: usize,
                dest: *mut root::JSStructuredCloneData,
            ) -> bool;
            pub fn JS_GetPromiseResult(
                promise: root::JS::HandleObject,
                dest: root::JS::MutableHandleValue,
            );
            pub fn JS_GetScriptPrivate(
                script: *mut root::JSScript,
                dest: root::JS::MutableHandleValue,
            );
            pub fn JS_MaybeGetScriptPrivate(
                obj: *mut root::JSObject,
                dest: root::JS::MutableHandleValue,
            );
            pub fn JS_GetModulePrivate(
                module: *mut root::JSObject,
                dest: root::JS::MutableHandleValue,
            );
            pub fn JS_GetScriptedCallerPrivate(
                cx: *mut root::JSContext,
                dest: root::JS::MutableHandleValue,
            );
            pub fn JS_GetNaNValue(cx: *mut root::JSContext, dest: *mut root::JS::Value);
            pub fn JS_GetPositiveInfinityValue(
                cx: *mut root::JSContext,
                dest: *mut root::JS::Value,
            );
            pub fn JS_GetReservedSlot(
                obj: *mut root::JSObject,
                index: u32,
                dest: *mut root::JS::Value,
            );
            pub fn JS_GetRegExpFlags(
                cx: *mut root::JSContext,
                obj: root::JS::HandleObject,
                flags: *mut root::JS::RegExpFlags,
            );
            pub fn EncodeStringToUTF8(
                cx: *mut root::JSContext,
                str_: root::JS::HandleString,
                cb: root::jsglue::EncodedStringCallback,
            );
            pub fn JS_ForgetStringLinearness(
                str_: *mut root::JSLinearString,
            ) -> *mut root::JSString;
            pub fn CreateJobQueue(
                aTraps: *const root::jsglue::JobQueueTraps,
                aQueue: *const ::std::os::raw::c_void,
            ) -> *mut root::JS::JobQueue;
            pub fn DeleteJobQueue(queue: *mut root::JS::JobQueue);
            pub fn CreateReadableStreamUnderlyingSource(
                aTraps: *const root::jsglue::ReadableStreamUnderlyingSourceTraps,
                aSource: *const ::std::os::raw::c_void,
            ) -> *mut root::JS::ReadableStreamUnderlyingSource;
            pub fn DeleteReadableStreamUnderlyingSource(
                source: *mut root::JS::ReadableStreamUnderlyingSource,
            );
            pub fn CreateJSExternalStringCallbacks(
                aTraps: *const root::jsglue::JSExternalStringCallbacksTraps,
                privateData: *mut ::std::os::raw::c_void,
            ) -> *mut root::JSExternalStringCallbacks;
            pub fn DeleteJSExternalStringCallbacks(
                callbacks: *mut root::JSExternalStringCallbacks,
            );
            pub fn DispatchableRun(
                cx: *mut root::JSContext,
                ptr: *mut root::JS::Dispatchable,
                mb: root::JS::Dispatchable_MaybeShuttingDown,
            );
            pub fn StreamConsumerConsumeChunk(
                sc: *mut root::JS::StreamConsumer,
                begin: *const u8,
                length: usize,
            ) -> bool;
            pub fn StreamConsumerStreamEnd(sc: *mut root::JS::StreamConsumer);
            pub fn StreamConsumerStreamError(
                sc: *mut root::JS::StreamConsumer,
                errorCode: usize,
            );
            pub fn StreamConsumerNoteResponseURLs(
                sc: *mut root::JS::StreamConsumer,
                maybeUrl: *const ::std::os::raw::c_char,
                maybeSourceMapUrl: *const ::std::os::raw::c_char,
            );
            pub fn DescribeScriptedCaller(
                cx: *mut root::JSContext,
                buffer: *mut ::std::os::raw::c_char,
                buflen: usize,
                line: *mut u32,
                col: *mut u32,
            ) -> bool;
            pub fn SetDataPropertyDescriptor(
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                value: root::JS::HandleValue,
                attrs: u32,
            );
            pub fn SetAccessorPropertyDescriptor(
                desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
                getter: root::JS::HandleObject,
                setter: root::JS::HandleObject,
                attrs: u32,
            );
        }
    }
    pub type __builtin_va_list = *mut ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct _bindgen_ty_7 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone, PartialEq)]
    pub struct IterImpl {
        pub mSegment: usize,
        pub mData: *mut ::std::os::raw::c_char,
        pub mDataEnd: *mut ::std::os::raw::c_char,
        pub mAbsoluteOffset: usize,
    }
    extern "C" {
        #[link_name = "\u{1}_Z9JS_AssertPKcS0_i"]
        pub fn JS_Assert(
            s: *const ::std::os::raw::c_char,
            file: *const ::std::os::raw::c_char,
            ln: ::std::os::raw::c_int,
        ) -> !;
        /// Complain when out of memory.
        #[link_name = "\u{1}_Z20JS_ReportOutOfMemoryP9JSContext"]
        pub fn JS_ReportOutOfMemory(cx: *mut root::JSContext);
        #[link_name = "\u{1}_ZN14ProfilingStackD1Ev"]
        pub fn ProfilingStack_ProfilingStack_destructor(this: *mut root::ProfilingStack);
        #[link_name = "\u{1}_ZN11JSAutoRealmC1EP9JSContextP8JSObject"]
        pub fn JSAutoRealm_JSAutoRealm(
            this: *mut root::JSAutoRealm,
            cx: *mut root::JSContext,
            target: *mut root::JSObject,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_ZN11JSAutoRealmC1EP9JSContextP8JSScript"]
        pub fn JSAutoRealm_JSAutoRealm1(
            this: *mut root::JSAutoRealm,
            cx: *mut root::JSContext,
            target: *mut root::JSScript,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_ZN11JSAutoRealmD1Ev"]
        pub fn JSAutoRealm_JSAutoRealm_destructor(this: *mut root::JSAutoRealm);
        #[link_name = "\u{1}_ZN19JSAutoNullableRealmC1EP9JSContextP8JSObject"]
        pub fn JSAutoNullableRealm_JSAutoNullableRealm(
            this: *mut root::JSAutoNullableRealm,
            cx: *mut root::JSContext,
            targetOrNull: *mut root::JSObject,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_ZN19JSAutoNullableRealmD1Ev"]
        pub fn JSAutoNullableRealm_JSAutoNullableRealm_destructor(
            this: *mut root::JSAutoNullableRealm,
        );
        #[link_name = "\u{1}_ZN12JSPrincipals4dumpEv"]
        pub fn JSPrincipals_dump(this: *mut root::JSPrincipals);
        #[link_name = "\u{1}_Z17JS_HoldPrincipalsP12JSPrincipals"]
        pub fn JS_HoldPrincipals(principals: *mut root::JSPrincipals);
        #[link_name = "\u{1}_Z17JS_DropPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_DropPrincipals(
            cx: *mut root::JSContext,
            principals: *mut root::JSPrincipals,
        );
        #[link_name = "\u{1}_Z23JS_SetSecurityCallbacksP9JSContextPK19JSSecurityCallbacks"]
        pub fn JS_SetSecurityCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSSecurityCallbacks,
        );
        #[link_name = "\u{1}_Z23JS_GetSecurityCallbacksP9JSContext"]
        pub fn JS_GetSecurityCallbacks(
            cx: *mut root::JSContext,
        ) -> *const root::JSSecurityCallbacks;
        #[link_name = "\u{1}_Z23JS_SetTrustedPrincipalsP9JSContextP12JSPrincipals"]
        pub fn JS_SetTrustedPrincipals(
            cx: *mut root::JSContext,
            prin: *mut root::JSPrincipals,
        );
        #[link_name = "\u{1}_Z32JS_InitDestroyPrincipalsCallbackP9JSContextPFvP12JSPrincipalsE"]
        pub fn JS_InitDestroyPrincipalsCallback(
            cx: *mut root::JSContext,
            destroyPrincipals: root::JSDestroyPrincipalsOp,
        );
        #[link_name = "\u{1}_Z29JS_InitReadPrincipalsCallbackP9JSContextPFbS0_P23JSStructuredCloneReaderPP12JSPrincipalsE"]
        pub fn JS_InitReadPrincipalsCallback(
            cx: *mut root::JSContext,
            read: root::JSReadPrincipalsOp,
        );
        /** Set the size of the native stack that should not be exceed. To disable
 stack size checking pass 0.

 SpiderMonkey allows for a distinction between system code (such as GCs, which
 may incidentally be triggered by script but are not strictly performed on
 behalf of such script), trusted script (as determined by
 JS_SetTrustedPrincipals), and untrusted script. Each kind of code may have a
 different stack quota, allowing embedders to keep higher-priority machinery
 running in the face of scripted stack exhaustion by something else.

 The stack quotas for each kind of code should be monotonically descending,
 and may be specified with this function. If 0 is passed for a given kind
 of code, it defaults to the value of the next-highest-priority kind.

 This function may only be called immediately after the runtime is initialized
 and before any code is executed and/or interrupts requested.*/
        #[link_name = "\u{1}_Z22JS_SetNativeStackQuotaP9JSContextmmm"]
        pub fn JS_SetNativeStackQuota(
            cx: *mut root::JSContext,
            systemCodeStackSize: root::JS::NativeStackSize,
            trustedScriptStackSize: root::JS::NativeStackSize,
            untrustedScriptStackSize: root::JS::NativeStackSize,
        );
        /** Given a buffer, return false if the buffer might become a valid JavaScript
 script with the addition of more lines, or true if the validity of such a
 script is conclusively known (because it's the prefix of a valid script --
 and possibly the entirety of such a script).

 The intent of this function is to enable interactive compilation: accumulate
 lines in a buffer until JS_Utf8BufferIsCompilableUnit is true, then pass it
 to the compiler.

 The provided buffer is interpreted as UTF-8 data.  An error is reported if
 a UTF-8 encoding error is encountered.*/
        #[link_name = "\u{1}_Z29JS_Utf8BufferIsCompilableUnitP9JSContextN2JS6HandleIP8JSObjectEEPKcm"]
        pub fn JS_Utf8BufferIsCompilableUnit(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            utf8: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
        /// Evaluate a script in the scope of the current global of cx.
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_ExecuteScript1(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
        /** As above, but providing an explicit scope chain.  envChain must not include
 the global object on it; that's implicit.  It needs to contain the other
 objects that should end up on the script's scope chain.*/
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ExecuteScript2(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_ExecuteScriptP9JSContextN2JS6HandleINS1_13StackGCVectorIP8JSObjectN2js15TempAllocPolicyEEEEENS2_IP8JSScriptEE"]
        pub fn JS_ExecuteScript3(
            cx: *mut root::JSContext,
            envChain: root::JS::HandleObjectVector,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> bool;
        /** DEPRECATED

 Allocate memory sufficient to contain the characters of |str| truncated to
 Latin-1 and a trailing null terminator, fill the memory with the characters
 interpreted in that manner plus the null terminator, and return a pointer to
 the memory.

 This function *loses information* when it copies the characters of |str| if
 |str| contains code units greater than 0xFF.  Additionally, users that
 depend on null-termination will misinterpret the copied characters if |str|
 contains any nulls.  Avoid using this function if possible, because it will
 eventually be removed.*/
        #[link_name = "\u{1}_Z23JS_EncodeStringToLatin1P9JSContextP8JSString"]
        pub fn JS_EncodeStringToLatin1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
        /** DEPRECATED

 Same behavior as JS_EncodeStringToLatin1(), but encode into a UTF-8 string.

 This function *loses information* when it copies the characters of |str| if
 |str| contains invalid UTF-16: U+FFFD REPLACEMENT CHARACTER will be copied
 instead.

 The returned string is also subject to misinterpretation if |str| contains
 any nulls (which are faithfully transcribed into the returned string, but
 which will implicitly truncate the string if it's passed to functions that
 expect null-terminated strings).

 Avoid using this function if possible, because we'll remove it once we can
 devise a better API for the task.*/
        #[link_name = "\u{1}_Z21JS_EncodeStringToUTF8P9JSContextN2JS6HandleIP8JSStringEE"]
        pub fn JS_EncodeStringToUTF8(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
        ) -> root::JS::UniqueChars;
        /** DEPRECATED

 Same behavior as JS_EncodeStringToLatin1(), but encode into an ASCII string.

 This function asserts in debug mode that the input string contains only
 ASCII characters.

 The returned string is also subject to misinterpretation if |str| contains
 any nulls (which are faithfully transcribed into the returned string, but
 which will implicitly truncate the string if it's passed to functions that
 expect null-terminated strings).

 Avoid using this function if possible, because we'll remove it once we can
 devise a better API for the task.*/
        #[link_name = "\u{1}_Z22JS_EncodeStringToASCIIP9JSContextP8JSString"]
        pub fn JS_EncodeStringToASCII(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueChars;
        #[link_name = "\u{1}_ZL18JS_NULL_CLASS_SPEC"]
        pub static JS_NULL_CLASS_SPEC: *const root::js::ClassSpec;
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_EXT"]
        pub static JS_NULL_CLASS_EXT: *const root::js::ClassExtension;
        #[link_name = "\u{1}_ZL18JS_NULL_OBJECT_OPS"]
        pub static JS_NULL_OBJECT_OPS: *const root::js::ObjectOps;
        #[link_name = "\u{1}_ZL26JSCLASS_HAS_RESERVED_SLOTSj"]
        pub fn JSCLASS_HAS_RESERVED_SLOTS(n: u32) -> u32;
        #[link_name = "\u{1}_ZL31JSCLASS_GLOBAL_FLAGS_WITH_SLOTSj"]
        pub fn JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(n: u32) -> u32;
        #[link_name = "\u{1}_ZL24JSCLASS_HAS_CACHED_PROTO10JSProtoKey"]
        pub fn JSCLASS_HAS_CACHED_PROTO(key: root::JSProtoKey) -> u32;
        #[link_name = "\u{1}_ZL17JS_NULL_CLASS_OPS"]
        pub static JS_NULL_CLASS_OPS: *const root::JSClassOps;
        #[link_name = "\u{1}_ZL22JSCLASS_RESERVED_SLOTSPK7JSClass"]
        pub fn JSCLASS_RESERVED_SLOTS(clasp: *const root::JSClass) -> u32;
        #[link_name = "\u{1}_ZL33JSCLASS_HAS_GLOBAL_FLAG_AND_SLOTSPK7JSClass"]
        pub fn JSCLASS_HAS_GLOBAL_FLAG_AND_SLOTS(clasp: *const root::JSClass) -> bool;
        #[link_name = "\u{1}_ZL24JSCLASS_CACHED_PROTO_KEYPK7JSClass"]
        pub fn JSCLASS_CACHED_PROTO_KEY(clasp: *const root::JSClass) -> root::JSProtoKey;
        /** This function can be used to track memory used by ICU.  If it is called, it
 *must* be called before JS_Init.  Don't use it unless you know what you're
 doing!*/
        #[link_name = "\u{1}_Z24JS_SetICUMemoryFunctionsPFPvPKvmEPFS_S1_S_mEPFvS1_S_E"]
        pub fn JS_SetICUMemoryFunctions(
            allocFn: root::JS_ICUAllocFn,
            reallocFn: root::JS_ICUReallocFn,
            freeFn: root::JS_ICUFreeFn,
        ) -> bool;
        /** Destroy free-standing resources allocated by SpiderMonkey, not associated
 with any runtime, context, or other structure.

 This method should be called after all other JSAPI data has been properly
 cleaned up: every new runtime must have been destroyed, every new context
 must have been destroyed, and so on.  Calling this method before all other
 resources have been destroyed has undefined behavior.

 Failure to call this method, at present, has no adverse effects other than
 leaking memory.  This may not always be the case; it's recommended that all
 embedders call this method when all other JSAPI operations have completed.

 It is currently not possible to initialize SpiderMonkey multiple times (that
 is, calling JS_Init/JSAPI methods/JS_ShutDown in that order, then doing so
 again).  This restriction may eventually be lifted.*/
        #[link_name = "\u{1}_Z11JS_ShutDownv"]
        pub fn JS_ShutDown();
        /** A variant of JS_ShutDown for process which used JS_FrontendOnlyInit instead
 of JS_Init.*/
        #[link_name = "\u{1}_Z23JS_FrontendOnlyShutDownv"]
        pub fn JS_FrontendOnlyShutDown();
        /** Performs the JSON.stringify operation, as specified by ECMAScript, except
 writing stringified data by exactly one call of |callback|, passing |data| as
 argument.

 In cases where JSON.stringify would return undefined, this function calls
 |callback| with the string "null".*/
        #[link_name = "\u{1}_Z12JS_StringifyP9JSContextN2JS13MutableHandleINS1_5ValueEEENS1_6HandleIP8JSObjectEENS5_IS3_EEPFbPKDsjPvESC_"]
        pub fn JS_Stringify(
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
            replacer: root::JS::Handle<*mut root::JSObject>,
            space: root::JS::Handle<root::JS::Value>,
            callback: root::JSONWriteCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
        /// Performs the JSON.parse operation as specified by ECMAScript.
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKDsjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /// Performs the JSON.parse operation as specified by ECMAScript.
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ParseJSON1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /// Performs the JSON.parse operation as specified by ECMAScript.
        #[link_name = "\u{1}_Z12JS_ParseJSONP9JSContextPKhjN2JS13MutableHandleINS3_5ValueEEE"]
        pub fn JS_ParseJSON2(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            len: u32,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /** Performs the JSON.parse operation as specified by ECMAScript, using the
 given |reviver| argument as the corresponding optional argument to that
 function.*/
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextPKDsjN2JS6HandleINS3_5ValueEEENS3_13MutableHandleIS5_EE"]
        pub fn JS_ParseJSONWithReviver(
            cx: *mut root::JSContext,
            chars: *const u16,
            len: u32,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /** Performs the JSON.parse operation as specified by ECMAScript, using the
 given |reviver| argument as the corresponding optional argument to that
 function.*/
        #[link_name = "\u{1}_Z23JS_ParseJSONWithReviverP9JSContextN2JS6HandleIP8JSStringEENS2_INS1_5ValueEEENS1_13MutableHandleIS6_EE"]
        pub fn JS_ParseJSONWithReviver1(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            reviver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /** Get a description of one of obj's own properties. If no such property exists
 on obj, return true with desc.object() set to null.

 Implements: ES6 [[GetOwnProperty]] internal method.*/
        #[link_name = "\u{1}_Z31JS_GetOwnPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_GetOwnPropertyDescriptorById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
        ) -> bool;
        #[link_name = "\u{1}_Z27JS_GetOwnPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_GetOwnPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
        ) -> bool;
        #[link_name = "\u{1}_Z29JS_GetOwnUCPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_GetOwnUCPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
        ) -> bool;
        /** DEPRECATED

 Like JS_GetOwnPropertyDescriptorById, but also searches the prototype chain
 if no own property is found directly on obj. The object on which the
 property is found is returned in holder. If the property is not found
 on the prototype chain, then desc is Nothing.*/
        #[link_name = "\u{1}_Z28JS_GetPropertyDescriptorByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEENS8_IS4_EE"]
        pub fn JS_GetPropertyDescriptorById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            holder: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z24JS_GetPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEENS8_IS4_EE"]
        pub fn JS_GetPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            holder: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_GetUCPropertyDescriptorP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEENS8_IS4_EE"]
        pub fn JS_GetUCPropertyDescriptor(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
            holder: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_ZNK14JSPropertySpec8getValueEP9JSContextN2JS13MutableHandleINS2_5ValueEEE"]
        pub fn JSPropertySpec_getValue(
            this: *const root::JSPropertySpec,
            cx: *mut root::JSContext,
            value: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_GetEmptyStringP9JSContext"]
        pub fn JS_GetEmptyString(cx: *mut root::JSContext) -> *mut root::JSString;
        #[link_name = "\u{1}_Z22JS_GetEmptyStringValueP9JSContext"]
        pub fn JS_GetEmptyStringValue(cx: *mut root::JSContext) -> root::JS::Value;
        #[link_name = "\u{1}_Z17JS_NewStringCopyNP9JSContextPKcm"]
        pub fn JS_NewStringCopyN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            n: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z17JS_NewStringCopyZP9JSContextPKc"]
        pub fn JS_NewStringCopyZ(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8ZP9JSContextN2JS15ConstUTF8CharsZE"]
        pub fn JS_NewStringCopyUTF8Z(
            cx: *mut root::JSContext,
            s: root::JS::ConstUTF8CharsZ,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z21JS_NewStringCopyUTF8NP9JSContextRKN2JS9UTF8CharsE"]
        pub fn JS_NewStringCopyUTF8N(
            cx: *mut root::JSContext,
            s: *const root::JS::UTF8Chars,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z17JS_AtomizeStringNP9JSContextPKcm"]
        pub fn JS_AtomizeStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z16JS_AtomizeStringP9JSContextPKc"]
        pub fn JS_AtomizeString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z23JS_AtomizeAndPinStringNP9JSContextPKcm"]
        pub fn JS_AtomizeAndPinStringN(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z22JS_AtomizeAndPinStringP9JSContextPKc"]
        pub fn JS_AtomizeAndPinString(
            cx: *mut root::JSContext,
            s: *const ::std::os::raw::c_char,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z18JS_NewLatin1StringP9JSContextN7mozilla9UniquePtrIA_hN2JS10FreePolicyEEEm"]
        pub fn JS_NewLatin1String(
            cx: *mut root::JSContext,
            chars: u32,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z14JS_NewUCStringP9JSContextN7mozilla9UniquePtrIA_DsN2JS10FreePolicyEEEm"]
        pub fn JS_NewUCString(
            cx: *mut root::JSContext,
            chars: root::JS::UniqueTwoByteChars,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z25JS_NewUCStringDontDeflateP9JSContextN7mozilla9UniquePtrIA_DsN2JS10FreePolicyEEEm"]
        pub fn JS_NewUCStringDontDeflate(
            cx: *mut root::JSContext,
            chars: root::JS::UniqueTwoByteChars,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyNP9JSContextPKDsm"]
        pub fn JS_NewUCStringCopyN(
            cx: *mut root::JSContext,
            s: *const u16,
            n: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z19JS_NewUCStringCopyZP9JSContextPKDs"]
        pub fn JS_NewUCStringCopyZ(
            cx: *mut root::JSContext,
            s: *const u16,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z19JS_AtomizeUCStringNP9JSContextPKDsm"]
        pub fn JS_AtomizeUCStringN(
            cx: *mut root::JSContext,
            s: *const u16,
            length: usize,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z18JS_AtomizeUCStringP9JSContextPKDs"]
        pub fn JS_AtomizeUCString(
            cx: *mut root::JSContext,
            s: *const u16,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z17JS_CompareStringsP9JSContextP8JSStringS2_Pi"]
        pub fn JS_CompareStrings(
            cx: *mut root::JSContext,
            str1: *mut root::JSString,
            str2: *mut root::JSString,
            result: *mut i32,
        ) -> bool;
        #[must_use]
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcPb"]
        pub fn JS_StringEqualsAscii(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            match_: *mut bool,
        ) -> bool;
        #[must_use]
        #[link_name = "\u{1}_Z20JS_StringEqualsAsciiP9JSContextP8JSStringPKcmPb"]
        pub fn JS_StringEqualsAscii1(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
            match_: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_PutEscapedStringP9JSContextPcmP8JSStringc"]
        pub fn JS_PutEscapedString(
            cx: *mut root::JSContext,
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
        #[link_name = "\u{1}_Z18JS_GetStringLengthP8JSString"]
        pub fn JS_GetStringLength(str_: *mut root::JSString) -> usize;
        #[link_name = "\u{1}_Z17JS_StringIsLinearP8JSString"]
        pub fn JS_StringIsLinear(str_: *mut root::JSString) -> bool;
        #[link_name = "\u{1}_Z32JS_GetLatin1StringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetLatin1StringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const root::JS::Latin1Char;
        #[link_name = "\u{1}_Z33JS_GetTwoByteStringCharsAndLengthP9JSContextRKN2JS15AutoRequireNoGCEP8JSStringPm"]
        pub fn JS_GetTwoByteStringCharsAndLength(
            cx: *mut root::JSContext,
            nogc: *const root::JS::AutoRequireNoGC,
            str_: *mut root::JSString,
            length: *mut usize,
        ) -> *const u16;
        #[link_name = "\u{1}_Z18JS_GetStringCharAtP9JSContextP8JSStringmPDs"]
        pub fn JS_GetStringCharAt(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            index: usize,
            res: *mut u16,
        ) -> bool;
        #[link_name = "\u{1}_Z32JS_GetTwoByteExternalStringCharsP8JSString"]
        pub fn JS_GetTwoByteExternalStringChars(str_: *mut root::JSString) -> *const u16;
        #[link_name = "\u{1}_Z18JS_CopyStringCharsP9JSContextRKN7mozilla5RangeIDsEEP8JSString"]
        pub fn JS_CopyStringChars(
            cx: *mut root::JSContext,
            dest: *const root::mozilla::Range<u16>,
            str_: *mut root::JSString,
        ) -> bool;
        /** Copies the string's characters to a null-terminated char16_t buffer.

 Returns nullptr on OOM.*/
        #[link_name = "\u{1}_Z19JS_CopyStringCharsZP9JSContextP8JSString"]
        pub fn JS_CopyStringCharsZ(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> root::JS::UniqueTwoByteChars;
        #[link_name = "\u{1}_Z21JS_EnsureLinearStringP9JSContextP8JSString"]
        pub fn JS_EnsureLinearString(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> *mut root::JSLinearString;
        #[link_name = "\u{1}_ZL26JS_ASSERT_STRING_IS_LINEARP8JSString"]
        pub fn JS_ASSERT_STRING_IS_LINEAR(
            str_: *mut root::JSString,
        ) -> *mut root::JSLinearString;
        #[link_name = "\u{1}_ZL27JS_FORGET_STRING_LINEARNESSP14JSLinearString"]
        pub fn JS_FORGET_STRING_LINEARNESS(
            str_: *mut root::JSLinearString,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKc"]
        pub fn JS_LinearStringEqualsAscii(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_LinearStringEqualsAsciiP14JSLinearStringPKcm"]
        pub fn JS_LinearStringEqualsAscii1(
            str_: *mut root::JSLinearString,
            asciiBytes: *const ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
        #[link_name = "\u{1}_Z25JS_PutEscapedLinearStringPcmP14JSLinearStringc"]
        pub fn JS_PutEscapedLinearString(
            buffer: *mut ::std::os::raw::c_char,
            size: usize,
            str_: *mut root::JSLinearString,
            quote: ::std::os::raw::c_char,
        ) -> usize;
        /** Create a dependent string, i.e., a string that owns no character storage,
 but that refers to a slice of another string's chars.  Dependent strings
 are mutable by definition, so the thread safety comments above apply.*/
        #[link_name = "\u{1}_Z21JS_NewDependentStringP9JSContextN2JS6HandleIP8JSStringEEmm"]
        pub fn JS_NewDependentString(
            cx: *mut root::JSContext,
            str_: root::JS::Handle<*mut root::JSString>,
            start: usize,
            length: usize,
        ) -> *mut root::JSString;
        /** Concatenate two strings, possibly resulting in a rope.
 See above for thread safety comments.*/
        #[link_name = "\u{1}_Z16JS_ConcatStringsP9JSContextN2JS6HandleIP8JSStringEES5_"]
        pub fn JS_ConcatStrings(
            cx: *mut root::JSContext,
            left: root::JS::Handle<*mut root::JSString>,
            right: root::JS::Handle<*mut root::JSString>,
        ) -> *mut root::JSString;
        /** For JS_DecodeBytes, set *dstlenp to the size of the destination buffer before
 the call; on return, *dstlenp contains the number of characters actually
 stored. To determine the necessary destination buffer size, make a sizing
 call that passes nullptr for dst.

 On errors, the functions report the error. In that case, *dstlenp contains
 the number of characters or bytes transferred so far.  If cx is nullptr, no
 error is reported on failure, and the functions simply return false.

 NB: This function does not store an additional zero byte or char16_t after
 the transcoded string.*/
        #[link_name = "\u{1}_Z14JS_DecodeBytesP9JSContextPKcmPDsPm"]
        pub fn JS_DecodeBytes(
            cx: *mut root::JSContext,
            src: *const ::std::os::raw::c_char,
            srclen: usize,
            dst: *mut u16,
            dstlenp: *mut usize,
        ) -> bool;
        /** Get number of bytes in the string encoding (without accounting for a
 terminating zero bytes. The function returns (size_t) -1 if the string
 can not be encoded into bytes and reports an error using cx accordingly.*/
        #[link_name = "\u{1}_Z26JS_GetStringEncodingLengthP9JSContextP8JSString"]
        pub fn JS_GetStringEncodingLength(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> usize;
        #[must_use]
        /** Encode string into a buffer. The function does not stores an additional
 zero byte. The function returns (size_t) -1 if the string can not be
 encoded into bytes with no error reported. Otherwise it returns the number
 of bytes that are necessary to encode the string. If that exceeds the
 length parameter, the string will be cut and only length bytes will be
 written into the buffer.*/
        #[link_name = "\u{1}_Z23JS_EncodeStringToBufferP9JSContextP8JSStringPcm"]
        pub fn JS_EncodeStringToBuffer(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            buffer: *mut ::std::os::raw::c_char,
            length: usize,
        ) -> bool;
        /** Encode as many scalar values of the string as UTF-8 as can fit
 into the caller-provided buffer replacing unpaired surrogates
 with the REPLACEMENT CHARACTER.

 If JS::StringHasLatin1Chars(str) returns true, the function
 is guaranteed to convert the entire string if
 buffer.Length() >= 2 * JS_GetStringLength(str). Otherwise,
 the function is guaranteed to convert the entire string if
 buffer.Length() >= 3 * JS_GetStringLength(str).

 This function does not alter the representation of |str| or
 any |JSString*| substring that is a constituent part of it.
 Returns mozilla::Nothing() on OOM, without reporting an error;
 some data may have been written to |buffer| when this happens.

 If there's no OOM, returns the number of code units read and
 the number of code units written.

 The semantics of this method match the semantics of
 TextEncoder.encodeInto().

 The function does not store an additional zero byte.*/
        #[link_name = "\u{1}_Z34JS_EncodeStringToUTF8BufferPartialP9JSContextP8JSStringN7mozilla4SpanIcLm4294967295EEE"]
        pub fn JS_EncodeStringToUTF8BufferPartial(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
            buffer: [u32; 2usize],
        ) -> root::mozilla::Maybe;
        /// DO NOT USE, only present for Rust bindings as a temporary hack
        #[link_name = "\u{1}_Z33JS_DeprecatedStringHasLatin1CharsP8JSString"]
        pub fn JS_DeprecatedStringHasLatin1Chars(str_: *mut root::JSString) -> bool;
        #[link_name = "\u{1}_ZN21JSStructuredCloneData20discardTransferablesEv"]
        pub fn JSStructuredCloneData_discardTransferables(
            this: *mut root::JSStructuredCloneData,
        );
        #[link_name = "\u{1}_ZN21JSStructuredCloneDataD1Ev"]
        pub fn JSStructuredCloneData_JSStructuredCloneData_destructor(
            this: *mut root::JSStructuredCloneData,
        );
        /** Implements StructuredDeserialize and StructuredDeserializeWithTransfer.

 Note: If `data` contains transferable objects, it can be read only once.*/
        #[link_name = "\u{1}_Z22JS_ReadStructuredCloneP9JSContextRK21JSStructuredCloneDatajN2JS20StructuredCloneScopeENS4_13MutableHandleINS4_5ValueEEERKNS4_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_ReadStructuredClone(
            cx: *mut root::JSContext,
            data: *const root::JSStructuredCloneData,
            version: u32,
            scope: root::JS::StructuredCloneScope,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
        /** Implements StructuredSerialize, StructuredSerializeForStorage, and
 StructuredSerializeWithTransfer.

 Note: If the scope is DifferentProcess then the cloneDataPolicy must deny
 shared-memory objects, or an error will be signaled if a shared memory object
 is seen.*/
        #[link_name = "\u{1}_Z23JS_WriteStructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEEP21JSStructuredCloneDataNS1_20StructuredCloneScopeERKNS1_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPvS4_"]
        pub fn JS_WriteStructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            data: *mut root::JSStructuredCloneData,
            scope: root::JS::StructuredCloneScope,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
            transferable: root::JS::HandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z34JS_StructuredCloneHasTransferablesR21JSStructuredCloneDataPb"]
        pub fn JS_StructuredCloneHasTransferables(
            data: *mut root::JSStructuredCloneData,
            hasTransferable: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z18JS_StructuredCloneP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIS3_EEPK26JSStructuredCloneCallbacksPv"]
        pub fn JS_StructuredClone(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            vp: root::JS::MutableHandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer5clearEv"]
        pub fn JSAutoStructuredCloneBuffer_clear(
            this: *mut root::JSAutoStructuredCloneBuffer,
        );
        /** Adopt some memory. It will be automatically freed by the destructor.
 data must have been allocated by the JS engine (e.g., extracted via
 JSAutoStructuredCloneBuffer::steal).*/
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer5adoptEO21JSStructuredCloneDatajPK26JSStructuredCloneCallbacksPv"]
        pub fn JSAutoStructuredCloneBuffer_adopt(
            this: *mut root::JSAutoStructuredCloneBuffer,
            data: *mut root::JSStructuredCloneData,
            version: u32,
            callbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        );
        /** Release ownership of the buffer and assign it and ownership of it to
 `data`.*/
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer6giveToEP21JSStructuredCloneData"]
        pub fn JSAutoStructuredCloneBuffer_giveTo(
            this: *mut root::JSAutoStructuredCloneBuffer,
            data: *mut root::JSStructuredCloneData,
        );
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer4readEP9JSContextN2JS13MutableHandleINS2_5ValueEEERKNS2_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JSAutoStructuredCloneBuffer_read(
            this: *mut root::JSAutoStructuredCloneBuffer,
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEEPK26JSStructuredCloneCallbacksPv"]
        pub fn JSAutoStructuredCloneBuffer_write(
            this: *mut root::JSAutoStructuredCloneBuffer,
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBuffer5writeEP9JSContextN2JS6HandleINS2_5ValueEEES5_RKNS2_15CloneDataPolicyEPK26JSStructuredCloneCallbacksPv"]
        pub fn JSAutoStructuredCloneBuffer_write1(
            this: *mut root::JSAutoStructuredCloneBuffer,
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            transferable: root::JS::HandleValue,
            cloneDataPolicy: *const root::JS::CloneDataPolicy,
            optionalCallbacks: *const root::JSStructuredCloneCallbacks,
            closure: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_ZN27JSAutoStructuredCloneBufferC1EOS_"]
        pub fn JSAutoStructuredCloneBuffer_JSAutoStructuredCloneBuffer(
            this: *mut root::JSAutoStructuredCloneBuffer,
            other: *mut root::JSAutoStructuredCloneBuffer,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z17JS_ReadUint32PairP23JSStructuredCloneReaderPjS1_"]
        pub fn JS_ReadUint32Pair(
            r: *mut root::JSStructuredCloneReader,
            p1: *mut u32,
            p2: *mut u32,
        ) -> bool;
        #[link_name = "\u{1}_Z12JS_ReadBytesP23JSStructuredCloneReaderPvm"]
        pub fn JS_ReadBytes(
            r: *mut root::JSStructuredCloneReader,
            p: *mut ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_ReadStringP23JSStructuredCloneReaderN2JS13MutableHandleIP8JSStringEE"]
        pub fn JS_ReadString(
            r: *mut root::JSStructuredCloneReader,
            str_: root::JS::MutableHandleString,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_ReadDoubleP23JSStructuredCloneReaderPd"]
        pub fn JS_ReadDouble(r: *mut root::JSStructuredCloneReader, v: *mut f64) -> bool;
        #[link_name = "\u{1}_Z17JS_ReadTypedArrayP23JSStructuredCloneReaderN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ReadTypedArray(
            r: *mut root::JSStructuredCloneReader,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z18JS_WriteUint32PairP23JSStructuredCloneWriterjj"]
        pub fn JS_WriteUint32Pair(
            w: *mut root::JSStructuredCloneWriter,
            tag: u32,
            data: u32,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_WriteBytesP23JSStructuredCloneWriterPKvm"]
        pub fn JS_WriteBytes(
            w: *mut root::JSStructuredCloneWriter,
            p: *const ::std::os::raw::c_void,
            len: usize,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_WriteStringP23JSStructuredCloneWriterN2JS6HandleIP8JSStringEE"]
        pub fn JS_WriteString(
            w: *mut root::JSStructuredCloneWriter,
            str_: root::JS::HandleString,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_WriteDoubleP23JSStructuredCloneWriterd"]
        pub fn JS_WriteDouble(w: *mut root::JSStructuredCloneWriter, v: f64) -> bool;
        #[link_name = "\u{1}_Z18JS_WriteTypedArrayP23JSStructuredCloneWriterN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_WriteTypedArray(
            w: *mut root::JSStructuredCloneWriter,
            v: root::JS::HandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_ObjectNotWrittenP23JSStructuredCloneWriterN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ObjectNotWritten(
            w: *mut root::JSStructuredCloneWriter,
            obj: root::JS::HandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_GetStructuredCloneScopeP23JSStructuredCloneWriter"]
        pub fn JS_GetStructuredCloneScope(
            w: *mut root::JSStructuredCloneWriter,
        ) -> root::JS::StructuredCloneScope;
        #[link_name = "\u{1}_Z15JS_NewInt8ArrayP9JSContextm"]
        pub fn JS_NewInt8Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z24JS_NewInt8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_NewInt8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewInt8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z16JS_NewUint8ArrayP9JSContextm"]
        pub fn JS_NewUint8Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_NewUint8ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_NewUint8ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewUint8ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z16JS_NewInt16ArrayP9JSContextm"]
        pub fn JS_NewInt16Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_NewInt16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_NewInt16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewInt16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z17JS_NewUint16ArrayP9JSContextm"]
        pub fn JS_NewUint16Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_NewUint16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_NewUint16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewUint16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z16JS_NewInt32ArrayP9JSContextm"]
        pub fn JS_NewInt32Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_NewInt32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewInt32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_NewInt32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewInt32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z17JS_NewUint32ArrayP9JSContextm"]
        pub fn JS_NewUint32Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_NewUint32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_NewUint32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewUint32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z18JS_NewFloat32ArrayP9JSContextm"]
        pub fn JS_NewFloat32Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_NewFloat32ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat32ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_NewFloat32ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewFloat32ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z18JS_NewFloat64ArrayP9JSContextm"]
        pub fn JS_NewFloat64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_NewFloat64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_NewFloat64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewFloat64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z23JS_NewUint8ClampedArrayP9JSContextm"]
        pub fn JS_NewUint8ClampedArray(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z32JS_NewUint8ClampedArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewUint8ClampedArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z33JS_NewUint8ClampedArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewUint8ClampedArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z19JS_NewBigInt64ArrayP9JSContextm"]
        pub fn JS_NewBigInt64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_NewBigInt64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigInt64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z29JS_NewBigInt64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewBigInt64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z20JS_NewBigUint64ArrayP9JSContextm"]
        pub fn JS_NewBigUint64Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z29JS_NewBigUint64ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewBigUint64ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z30JS_NewBigUint64ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewBigUint64ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z18JS_NewFloat16ArrayP9JSContextm"]
        pub fn JS_NewFloat16Array(
            cx: *mut root::JSContext,
            nelements: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_NewFloat16ArrayFromArrayP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewFloat16ArrayFromArray(
            cx: *mut root::JSContext,
            array: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_NewFloat16ArrayWithBufferP9JSContextN2JS6HandleIP8JSObjectEEmx"]
        pub fn JS_NewFloat16ArrayWithBuffer(
            cx: *mut root::JSContext,
            arrayBuffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            length: i64,
        ) -> *mut root::JSObject;
        /** Check whether obj supports JS_GetTypedArray* APIs. Note that this may return
 false if a security wrapper is encountered that denies the unwrapping. If
 this test or one of the JS_Is*Array tests succeeds, then it is safe to call
 the various accessor JSAPI calls defined below.*/
        #[link_name = "\u{1}_Z21JS_IsTypedArrayObjectP8JSObject"]
        pub fn JS_IsTypedArrayObject(obj: *mut root::JSObject) -> bool;
        /** Check whether obj supports JS_GetArrayBufferView* APIs. Note that this may
 return false if a security wrapper is encountered that denies the
 unwrapping. If this test or one of the more specific tests succeeds, then it
 is safe to call the various ArrayBufferView accessor JSAPI calls defined
 below.*/
        #[link_name = "\u{1}_Z26JS_IsArrayBufferViewObjectP8JSObject"]
        pub fn JS_IsArrayBufferViewObject(obj: *mut root::JSObject) -> bool;
        /** Return the isShared flag of a typed array, which denotes whether
 the underlying buffer is a SharedArrayBuffer.

 |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 be known that it would pass such a test: it is a typed array or a wrapper of
 a typed array, and the unwrapping will succeed.*/
        #[link_name = "\u{1}_Z26JS_GetTypedArraySharednessP8JSObject"]
        pub fn JS_GetTypedArraySharedness(obj: *mut root::JSObject) -> bool;
        #[link_name = "\u{1}_Z23JS_GetObjectAsInt8ArrayP8JSObjectPmPbPPa"]
        pub fn JS_GetObjectAsInt8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i8,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z24JS_GetObjectAsUint8ArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt16ArrayP8JSObjectPmPbPPs"]
        pub fn JS_GetObjectAsInt16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i16,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint16ArrayP8JSObjectPmPbPPt"]
        pub fn JS_GetObjectAsUint16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z24JS_GetObjectAsInt32ArrayP8JSObjectPmPbPPi"]
        pub fn JS_GetObjectAsInt32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i32,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_GetObjectAsUint32ArrayP8JSObjectPmPbPPj"]
        pub fn JS_GetObjectAsUint32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u32,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat32ArrayP8JSObjectPmPbPPf"]
        pub fn JS_GetObjectAsFloat32Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f32,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat64ArrayP8JSObjectPmPbPPd"]
        pub fn JS_GetObjectAsFloat64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut f64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z31JS_GetObjectAsUint8ClampedArrayP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsUint8ClampedArray(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z27JS_GetObjectAsBigInt64ArrayP8JSObjectPmPbPPx"]
        pub fn JS_GetObjectAsBigInt64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut i64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_GetObjectAsBigUint64ArrayP8JSObjectPmPbPPy"]
        pub fn JS_GetObjectAsBigUint64Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u64,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z26JS_GetObjectAsFloat16ArrayP8JSObjectPmPbPPt"]
        pub fn JS_GetObjectAsFloat16Array(
            maybeWrapped: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u16,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z29JS_GetObjectAsArrayBufferViewP8JSObjectPmPbPPh"]
        pub fn JS_GetObjectAsArrayBufferView(
            obj: *mut root::JSObject,
            length: *mut usize,
            isSharedMemory: *mut bool,
            data: *mut *mut u8,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewTypeP8JSObject"]
        pub fn JS_GetArrayBufferViewType(
            obj: *mut root::JSObject,
        ) -> root::JS::Scalar::Type;
        /** Return the number of elements in a typed array.

 |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 be known that it would pass such a test: it is a typed array or a wrapper of
 a typed array, and the unwrapping will succeed.*/
        #[link_name = "\u{1}_Z22JS_GetTypedArrayLengthP8JSObject"]
        pub fn JS_GetTypedArrayLength(obj: *mut root::JSObject) -> usize;
        /** Return the byte offset from the start of an ArrayBuffer to the start of a
 typed array view.

 |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 be known that it would pass such a test: it is a typed array or a wrapper of
 a typed array, and the unwrapping will succeed.*/
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteOffsetP8JSObject"]
        pub fn JS_GetTypedArrayByteOffset(obj: *mut root::JSObject) -> usize;
        /** Return the byte length of a typed array.

 |obj| must have passed a JS_IsTypedArrayObject/JS_Is*Array test, or somehow
 be known that it would pass such a test: it is a typed array or a wrapper of
 a typed array, and the unwrapping will succeed.*/
        #[link_name = "\u{1}_Z26JS_GetTypedArrayByteLengthP8JSObject"]
        pub fn JS_GetTypedArrayByteLength(obj: *mut root::JSObject) -> usize;
        /// More generic name for JS_GetTypedArrayByteLength to cover DataViews as well
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteLengthP8JSObject"]
        pub fn JS_GetArrayBufferViewByteLength(obj: *mut root::JSObject) -> usize;
        /// More generic name for JS_GetTypedArrayByteOffset to cover DataViews as well
        #[link_name = "\u{1}_Z31JS_GetArrayBufferViewByteOffsetP8JSObject"]
        pub fn JS_GetArrayBufferViewByteOffset(obj: *mut root::JSObject) -> usize;
        /** Same as above, but for any kind of ArrayBufferView. Prefer the type-specific
 versions when possible.*/
        #[link_name = "\u{1}_Z25JS_GetArrayBufferViewDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetArrayBufferViewData(
            obj: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut ::std::os::raw::c_void;
        /** Return a "fixed" pointer (one that will not move during a GC) to the
 ArrayBufferView's data. Note that this will not keep the object alive; the
 holding object should be rooted or traced. If the view is storing the data
 inline, this will copy the data to the provided buffer, returning nullptr if
 bufSize is inadequate.

 Avoid using this unless necessary. JS_GetArrayBufferViewData is simpler and
 more efficient because it requires the caller to ensure that a GC will not
 occur and thus does not need to handle movable data.*/
        #[link_name = "\u{1}_Z30JS_GetArrayBufferViewFixedDataP8JSObjectPhm"]
        pub fn JS_GetArrayBufferViewFixedData(
            obj: *mut root::JSObject,
            buffer: *mut u8,
            bufSize: usize,
        ) -> *mut u8;
        /** If the bufSize passed to JS_GetArrayBufferViewFixedData is at least this
 many bytes, then any copied data is guaranteed to fit into the provided
 buffer.*/
        #[link_name = "\u{1}_Z27JS_MaxMovableTypedArraySizev"]
        pub fn JS_MaxMovableTypedArraySize() -> usize;
        /** Return the ArrayBuffer or SharedArrayBuffer underlying an ArrayBufferView.
 This may return a detached buffer.  |obj| must be an object that would
 return true for JS_IsArrayBufferViewObject().*/
        #[link_name = "\u{1}_Z27JS_GetArrayBufferViewBufferP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_GetArrayBufferViewBuffer(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            isSharedMemory: *mut bool,
        ) -> *mut root::JSObject;
        /** Create a new DataView using the given buffer for storage. The given buffer
 must be an ArrayBuffer or SharedArrayBuffer (or a cross-compartment wrapper
 of either type), and the offset and length must fit within the bounds of the
 buffer. Currently, nullptr will be returned and an exception will be thrown
 if these conditions do not hold, but do not depend on that behavior.*/
        #[link_name = "\u{1}_Z14JS_NewDataViewP9JSContextN2JS6HandleIP8JSObjectEEmm"]
        pub fn JS_NewDataView(
            cx: *mut root::JSContext,
            buffer: root::JS::Handle<*mut root::JSObject>,
            byteOffset: usize,
            byteLength: usize,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z19JS_GetInt8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i8;
        #[link_name = "\u{1}_Z20JS_GetUint8ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
        #[link_name = "\u{1}_Z20JS_GetInt16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i16;
        #[link_name = "\u{1}_Z21JS_GetUint16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
        #[link_name = "\u{1}_Z20JS_GetInt32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetInt32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i32;
        #[link_name = "\u{1}_Z21JS_GetUint32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u32;
        #[link_name = "\u{1}_Z22JS_GetFloat32ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat32ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f32;
        #[link_name = "\u{1}_Z22JS_GetFloat64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut f64;
        #[link_name = "\u{1}_Z27JS_GetUint8ClampedArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetUint8ClampedArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u8;
        #[link_name = "\u{1}_Z23JS_GetBigInt64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigInt64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut i64;
        #[link_name = "\u{1}_Z24JS_GetBigUint64ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetBigUint64ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u64;
        #[link_name = "\u{1}_Z22JS_GetFloat16ArrayDataP8JSObjectPbRKN2JS15AutoRequireNoGCE"]
        pub fn JS_GetFloat16ArrayData(
            maybeWrapped: *mut root::JSObject,
            isSharedMemory: *mut bool,
            arg1: *const root::JS::AutoRequireNoGC,
        ) -> *mut u16;
        /** Call a function, passing a this-value and arguments. This is the C++
 equivalent of `rval = Reflect.apply(fun, obj, args)`.

 Implements: ES6 7.3.12 Call(F, V, [argumentsList]).
 Use this function to invoke the [[Call]] internal method.*/
        #[link_name = "\u{1}_Z20JS_CallFunctionValueP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEERKNS1_16HandleValueArrayENS1_13MutableHandleIS6_EE"]
        pub fn JS_CallFunctionValue(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fval: root::JS::Handle<root::JS::Value>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z15JS_CallFunctionP9JSContextN2JS6HandleIP8JSObjectEENS2_IP10JSFunctionEERKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fun: root::JS::Handle<*mut root::JSFunction>,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /// Perform the method call `rval = obj[name](args)`.
        #[link_name = "\u{1}_Z19JS_CallFunctionNameP9JSContextN2JS6HandleIP8JSObjectEEPKcRKNS1_16HandleValueArrayENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_CallFunctionName(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            args: *const root::JS::HandleValueArray,
            rval: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_NewContextjP9JSRuntime"]
        pub fn JS_NewContext(
            maxbytes: u32,
            parentRuntime: *mut root::JSRuntime,
        ) -> *mut root::JSContext;
        #[link_name = "\u{1}_Z17JS_DestroyContextP9JSContext"]
        pub fn JS_DestroyContext(cx: *mut root::JSContext);
        #[link_name = "\u{1}_Z20JS_GetContextPrivateP9JSContext"]
        pub fn JS_GetContextPrivate(
            cx: *mut root::JSContext,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z20JS_SetContextPrivateP9JSContextPv"]
        pub fn JS_SetContextPrivate(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z19JS_GetParentRuntimeP9JSContext"]
        pub fn JS_GetParentRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
        #[link_name = "\u{1}_Z13JS_GetRuntimeP9JSContext"]
        pub fn JS_GetRuntime(cx: *mut root::JSContext) -> *mut root::JSRuntime;
        #[link_name = "\u{1}_Z18JS_SetFutexCanWaitP9JSContext"]
        pub fn JS_SetFutexCanWait(cx: *mut root::JSContext);
        /** Register externally maintained GC roots.

 traceOp: the trace operation. For each root the implementation should call
          JS::TraceEdge whenever the root contains a traceable thing.
 data:    the data argument to pass to each invocation of traceOp.*/
        #[link_name = "\u{1}_Z24JS_AddExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
        /// Undo a call to JS_AddExtraGCRootsTracer.
        #[link_name = "\u{1}_Z27JS_RemoveExtraGCRootsTracerP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_RemoveExtraGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSTraceDataOp,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z5JS_GCP9JSContextN2JS8GCReasonE"]
        pub fn JS_GC(cx: *mut root::JSContext, reason: root::JS::GCReason);
        #[link_name = "\u{1}_Z10JS_MaybeGCP9JSContext"]
        pub fn JS_MaybeGC(cx: *mut root::JSContext);
        #[link_name = "\u{1}_Z16JS_SetGCCallbackP9JSContextPFvS0_10JSGCStatusN2JS8GCReasonEPvES4_"]
        pub fn JS_SetGCCallback(
            cx: *mut root::JSContext,
            cb: root::JSGCCallback,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z28JS_SetObjectsTenuredCallbackP9JSContextPFvPN2JS9GCContextEPvES4_"]
        pub fn JS_SetObjectsTenuredCallback(
            cx: *mut root::JSContext,
            cb: root::JSObjectsTenuredCallback,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z22JS_AddFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvES5_"]
        pub fn JS_AddFinalizeCallback(
            cx: *mut root::JSContext,
            cb: root::JSFinalizeCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_Z25JS_RemoveFinalizeCallbackP9JSContextPFvPN2JS9GCContextE16JSFinalizeStatusPvE"]
        pub fn JS_RemoveFinalizeCallback(
            cx: *mut root::JSContext,
            cb: root::JSFinalizeCallback,
        );
        #[link_name = "\u{1}_Z30JS_AddWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvES3_"]
        pub fn JS_AddWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_Z33JS_RemoveWeakPointerZonesCallbackP9JSContextPFvP8JSTracerPvE"]
        pub fn JS_RemoveWeakPointerZonesCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerZonesCallback,
        );
        #[link_name = "\u{1}_Z36JS_AddWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvES6_"]
        pub fn JS_AddWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
            data: *mut ::std::os::raw::c_void,
        ) -> bool;
        #[link_name = "\u{1}_Z39JS_RemoveWeakPointerCompartmentCallbackP9JSContextPFvP8JSTracerPN2JS11CompartmentEPvE"]
        pub fn JS_RemoveWeakPointerCompartmentCallback(
            cx: *mut root::JSContext,
            cb: root::JSWeakPointerCompartmentCallback,
        );
        #[link_name = "\u{1}_Z27JS_UpdateWeakPointerAfterGCP8JSTracerPN2JS4HeapIP8JSObjectEE"]
        pub fn JS_UpdateWeakPointerAfterGC(
            trc: *mut root::JSTracer,
            objp: *mut root::JS::Heap<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z38JS_UpdateWeakPointerAfterGCUnbarrieredP8JSTracerPP8JSObject"]
        pub fn JS_UpdateWeakPointerAfterGCUnbarriered(
            trc: *mut root::JSTracer,
            objp: *mut *mut root::JSObject,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_SetGCParameterP9JSContext12JSGCParamKeyj"]
        pub fn JS_SetGCParameter(
            cx: *mut root::JSContext,
            key: root::JSGCParamKey,
            value: u32,
        );
        #[link_name = "\u{1}_Z19JS_ResetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_ResetGCParameter(cx: *mut root::JSContext, key: root::JSGCParamKey);
        #[link_name = "\u{1}_Z17JS_GetGCParameterP9JSContext12JSGCParamKey"]
        pub fn JS_GetGCParameter(
            cx: *mut root::JSContext,
            key: root::JSGCParamKey,
        ) -> u32;
        #[link_name = "\u{1}_Z40JS_SetGCParametersBasedOnAvailableMemoryP9JSContextj"]
        pub fn JS_SetGCParametersBasedOnAvailableMemory(
            cx: *mut root::JSContext,
            availMemMB: u32,
        );
        /** Create a new JSString whose chars member refers to external memory, i.e.,
 memory requiring application-specific finalization.*/
        #[link_name = "\u{1}_Z26JS_NewExternalStringLatin1P9JSContextPKhmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalStringLatin1(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z22JS_NewExternalUCStringP9JSContextPKDsmPK25JSExternalStringCallbacks"]
        pub fn JS_NewExternalUCString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
        ) -> *mut root::JSString;
        /** Create a new JSString whose chars member may refer to external memory.
 If a new external string is allocated, |*allocatedExternal| is set to true.
 Otherwise the returned string is either not an external string or an
 external string allocated by a previous call and |*allocatedExternal| is set
 to false. If |*allocatedExternal| is false, |fin| won't be called.*/
        #[link_name = "\u{1}_Z31JS_NewMaybeExternalStringLatin1P9JSContextPKhmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalStringLatin1(
            cx: *mut root::JSContext,
            chars: *const root::JS::Latin1Char,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z27JS_NewMaybeExternalUCStringP9JSContextPKDsmPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalUCString(
            cx: *mut root::JSContext,
            chars: *const u16,
            length: usize,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
        /** Similar to JS_NewMaybeExternalStringLatin1.

 Create an external Latin1 string if the utf8 buffer contains only ASCII
 chars, otherwise copy the chars into a non-external string.*/
        #[link_name = "\u{1}_Z29JS_NewMaybeExternalStringUTF8P9JSContextRKN2JS9UTF8CharsEPK25JSExternalStringCallbacksPb"]
        pub fn JS_NewMaybeExternalStringUTF8(
            cx: *mut root::JSContext,
            utf8: *const root::JS::UTF8Chars,
            callbacks: *const root::JSExternalStringCallbacks,
            allocatedExternal: *mut bool,
        ) -> *mut root::JSString;
        /** Return the 'callbacks' arg passed to JS_NewExternalStringLatin1,
 JS_NewExternalUCString, JS_NewMaybeExternalStringLatin1,
 or JS_NewMaybeExternalUCString.*/
        #[link_name = "\u{1}_Z29JS_GetExternalStringCallbacksP8JSString"]
        pub fn JS_GetExternalStringCallbacks(
            str_: *mut root::JSString,
        ) -> *const root::JSExternalStringCallbacks;
        #[link_name = "\u{1}_Z23JS_DefineDebuggerObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineDebuggerObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z30JS_SetErrorInterceptorCallbackP9JSRuntimeP18JSErrorInterceptor"]
        pub fn JS_SetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
            callback: *mut root::JSErrorInterceptor,
        );
        #[link_name = "\u{1}_Z30JS_GetErrorInterceptorCallbackP9JSRuntime"]
        pub fn JS_GetErrorInterceptorCallback(
            arg1: *mut root::JSRuntime,
        ) -> *mut root::JSErrorInterceptor;
        #[link_name = "\u{1}_ZN11JSErrorBase16newMessageStringEP9JSContext"]
        pub fn JSErrorBase_newMessageString(
            this: *mut root::JSErrorBase,
            cx: *mut root::JSContext,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_ZN12JSErrorNotes12addNoteASCIIEP9JSContextPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjES9_jz"]
        pub fn JSErrorNotes_addNoteASCII(
            this: *mut root::JSErrorNotes,
            cx: *mut root::JSContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes12addNoteASCIIEPN2js15FrontendContextEPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjESA_jz"]
        pub fn JSErrorNotes_addNoteASCII1(
            this: *mut root::JSErrorNotes,
            fc: *mut root::js::FrontendContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes13addNoteLatin1EP9JSContextPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjES9_jz"]
        pub fn JSErrorNotes_addNoteLatin1(
            this: *mut root::JSErrorNotes,
            cx: *mut root::JSContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes13addNoteLatin1EPN2js15FrontendContextEPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjESA_jz"]
        pub fn JSErrorNotes_addNoteLatin11(
            this: *mut root::JSErrorNotes,
            fc: *mut root::js::FrontendContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes11addNoteUTF8EP9JSContextPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjES9_jz"]
        pub fn JSErrorNotes_addNoteUTF8(
            this: *mut root::JSErrorNotes,
            cx: *mut root::JSContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes11addNoteUTF8EPN2js15FrontendContextEPKcjjN2JS21ColumnNumberOneOriginEPFPK19JSErrorFormatStringPvjESA_jz"]
        pub fn JSErrorNotes_addNoteUTF81(
            this: *mut root::JSErrorNotes,
            fc: *mut root::js::FrontendContext,
            filename: *const ::std::os::raw::c_char,
            sourceId: ::std::os::raw::c_uint,
            lineno: u32,
            column: root::JS::ColumnNumberOneOrigin,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        ) -> bool;
        #[link_name = "\u{1}_ZN12JSErrorNotes6lengthEv"]
        pub fn JSErrorNotes_length(this: *mut root::JSErrorNotes) -> usize;
        #[link_name = "\u{1}_ZN12JSErrorNotes4copyEP9JSContext"]
        pub fn JSErrorNotes_copy(
            this: *mut root::JSErrorNotes,
            cx: *mut root::JSContext,
        ) -> u32;
        #[link_name = "\u{1}_ZN12JSErrorNotes5beginEv"]
        pub fn JSErrorNotes_begin(
            this: *mut root::JSErrorNotes,
        ) -> root::JSErrorNotes_iterator;
        #[link_name = "\u{1}_ZN12JSErrorNotes3endEv"]
        pub fn JSErrorNotes_end(
            this: *mut root::JSErrorNotes,
        ) -> root::JSErrorNotes_iterator;
        #[link_name = "\u{1}_ZN12JSErrorNotesC1Ev"]
        pub fn JSErrorNotes_JSErrorNotes(
            this: *mut root::JSErrorNotes,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_ZN12JSErrorNotesD1Ev"]
        pub fn JSErrorNotes_JSErrorNotes_destructor(this: *mut root::JSErrorNotes);
        #[link_name = "\u{1}_ZN13JSErrorReport19initBorrowedLinebufEPKDsmm"]
        pub fn JSErrorReport_initBorrowedLinebuf(
            this: *mut root::JSErrorReport,
            linebufArg: *const u16,
            linebufLengthArg: usize,
            tokenOffsetArg: usize,
        );
        /** Report an exception represented by the sprintf-like conversion of format
 and its arguments.*/
        #[link_name = "\u{1}_Z19JS_ReportErrorASCIIP9JSContextPKcz"]
        pub fn JS_ReportErrorASCII(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
        #[link_name = "\u{1}_Z20JS_ReportErrorLatin1P9JSContextPKcz"]
        pub fn JS_ReportErrorLatin1(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
        #[link_name = "\u{1}_Z18JS_ReportErrorUTF8P9JSContextPKcz"]
        pub fn JS_ReportErrorUTF8(
            cx: *mut root::JSContext,
            format: *const ::std::os::raw::c_char,
            ...
        );
        #[link_name = "\u{1}_Z25JS_ReportErrorNumberASCIIP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberASCIIVAP9JSContextPFPK19JSErrorFormatStringPvjES4_jS4_"]
        pub fn JS_ReportErrorNumberASCIIVA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: root::va_list,
        );
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberLatin1P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberLatin1(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
        #[link_name = "\u{1}_Z28JS_ReportErrorNumberLatin1VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jS4_"]
        pub fn JS_ReportErrorNumberLatin1VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: root::va_list,
        );
        #[link_name = "\u{1}_Z24JS_ReportErrorNumberUTF8P9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUTF8(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
        #[link_name = "\u{1}_Z26JS_ReportErrorNumberUTF8VAP9JSContextPFPK19JSErrorFormatStringPvjES4_jS4_"]
        pub fn JS_ReportErrorNumberUTF8VA(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ap: root::va_list,
        );
        #[link_name = "\u{1}_Z29JS_ReportErrorNumberUTF8ArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKc"]
        pub fn JS_ReportErrorNumberUTF8Array(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const ::std::os::raw::c_char,
        );
        #[link_name = "\u{1}_Z22JS_ReportErrorNumberUCP9JSContextPFPK19JSErrorFormatStringPvjES4_jz"]
        pub fn JS_ReportErrorNumberUC(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            ...
        );
        #[link_name = "\u{1}_Z27JS_ReportErrorNumberUCArrayP9JSContextPFPK19JSErrorFormatStringPvjES4_jPPKDs"]
        pub fn JS_ReportErrorNumberUCArray(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            userRef: *mut ::std::os::raw::c_void,
            errorNumber: ::std::os::raw::c_uint,
            args: *mut *const u16,
        );
        #[link_name = "\u{1}_Z28JS_ExpandErrorArgumentsASCIIP9JSContextPFPK19JSErrorFormatStringPvjEjP13JSErrorReportz"]
        pub fn JS_ExpandErrorArgumentsASCII(
            cx: *mut root::JSContext,
            errorCallback: root::JSErrorCallback,
            errorNumber: ::std::os::raw::c_uint,
            reportp: *mut root::JSErrorReport,
            ...
        ) -> bool;
        /// Complain when an allocation size overflows the maximum supported limit.
        #[link_name = "\u{1}_Z27JS_ReportAllocationOverflowP9JSContext"]
        pub fn JS_ReportAllocationOverflow(cx: *mut root::JSContext);
        #[link_name = "\u{1}_Z21JS_IsExceptionPendingP9JSContext"]
        pub fn JS_IsExceptionPending(cx: *mut root::JSContext) -> bool;
        #[link_name = "\u{1}_Z24JS_IsThrowingOutOfMemoryP9JSContext"]
        pub fn JS_IsThrowingOutOfMemory(cx: *mut root::JSContext) -> bool;
        #[link_name = "\u{1}_Z22JS_GetPendingExceptionP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPendingException(
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z22JS_SetPendingExceptionP9JSContextN2JS6HandleINS1_5ValueEEENS1_22ExceptionStackBehaviorE"]
        pub fn JS_SetPendingException(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            behavior: root::JS::ExceptionStackBehavior,
        );
        #[link_name = "\u{1}_Z24JS_ClearPendingExceptionP9JSContext"]
        pub fn JS_ClearPendingException(cx: *mut root::JSContext);
        /** If the given object is an exception object, the exception will have (or be
 able to lazily create) an error report struct, and this function will return
 the address of that struct.  Otherwise, it returns nullptr. The lifetime
 of the error report struct that might be returned is the same as the
 lifetime of the exception object.*/
        #[link_name = "\u{1}_Z21JS_ErrorFromExceptionP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_ErrorFromException(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSErrorReport;
        #[link_name = "\u{1}_Z17JS_IsGlobalObjectP8JSObject"]
        pub fn JS_IsGlobalObject(obj: *mut root::JSObject) -> bool;
        #[link_name = "\u{1}_Z18JS_NewGlobalObjectP9JSContextPK7JSClassP12JSPrincipalsN2JS21OnNewGlobalHookOptionERKNS6_12RealmOptionsE"]
        pub fn JS_NewGlobalObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            principals: *mut root::JSPrincipals,
            hookOption: root::JS::OnNewGlobalHookOption,
            options: *const root::JS::RealmOptions,
        ) -> *mut root::JSObject;
        /** Spidermonkey does not have a good way of keeping track of what compartments
 should be marked on their own. We can mark the roots unconditionally, but
 marking GC things only relevant in live compartments is hard. To mitigate
 this, we create a static trace hook, installed on each global object, from
 which we can be sure the compartment is relevant, and mark it.

 It is still possible to specify custom trace hooks for global object classes.
 They can be provided via the RealmOptions passed to JS_NewGlobalObject.*/
        #[link_name = "\u{1}_Z24JS_GlobalObjectTraceHookP8JSTracerP8JSObject"]
        pub fn JS_GlobalObjectTraceHook(
            trc: *mut root::JSTracer,
            global: *mut root::JSObject,
        );
        #[link_name = "\u{1}_Z24JS_FireOnNewGlobalObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FireOnNewGlobalObject(
            cx: *mut root::JSContext,
            global: root::JS::HandleObject,
        );
        #[link_name = "\u{1}_Z20JS_CheckForInterruptP9JSContext"]
        pub fn JS_CheckForInterrupt(cx: *mut root::JSContext) -> bool;
        #[link_name = "\u{1}_Z23JS_AddInterruptCallbackP9JSContextPFbS0_E"]
        pub fn JS_AddInterruptCallback(
            cx: *mut root::JSContext,
            callback: root::JSInterruptCallback,
        ) -> bool;
        #[link_name = "\u{1}_Z27JS_DisableInterruptCallbackP9JSContext"]
        pub fn JS_DisableInterruptCallback(cx: *mut root::JSContext) -> bool;
        #[link_name = "\u{1}_Z25JS_ResetInterruptCallbackP9JSContextb"]
        pub fn JS_ResetInterruptCallback(cx: *mut root::JSContext, enable: bool);
        #[link_name = "\u{1}_Z27JS_RequestInterruptCallbackP9JSContext"]
        pub fn JS_RequestInterruptCallback(cx: *mut root::JSContext);
        #[link_name = "\u{1}_Z34JS_RequestInterruptCallbackCanWaitP9JSContext"]
        pub fn JS_RequestInterruptCallbackCanWait(cx: *mut root::JSContext);
        #[link_name = "\u{1}_Z9JS_mallocP9JSContextm"]
        pub fn JS_malloc(
            cx: *mut root::JSContext,
            nbytes: usize,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z10JS_reallocP9JSContextPvmm"]
        pub fn JS_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
        /** A wrapper for |js_free(p)| that may delay |js_free(p)| invocation as a
 performance optimization.  |cx| may be nullptr.*/
        #[link_name = "\u{1}_Z7JS_freeP9JSContextPv"]
        pub fn JS_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
        /** Same as above, but for buffers that will be used with the BYOB
 (Bring Your Own Buffer) JSString creation functions, such as
 JS_NewLatin1String and JS_NewUCString*/
        #[link_name = "\u{1}_Z16JS_string_mallocP9JSContextm"]
        pub fn JS_string_malloc(
            cx: *mut root::JSContext,
            nbytes: usize,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z17JS_string_reallocP9JSContextPvmm"]
        pub fn JS_string_realloc(
            cx: *mut root::JSContext,
            p: *mut ::std::os::raw::c_void,
            oldBytes: usize,
            newBytes: usize,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z14JS_string_freeP9JSContextPv"]
        pub fn JS_string_free(cx: *mut root::JSContext, p: *mut ::std::os::raw::c_void);
        /** Define a property on obj.

 This function uses JS::ObjectOpResult to indicate conditions that ES6
 specifies as non-error failures. This is inconvenient at best, so use this
 function only if you are implementing a proxy handler's defineProperty()
 method. For all other purposes, use one of the many DefineProperty functions
 below that throw an exception in all failure cases.

 Implements: ES6 [[DefineOwnProperty]] internal method.*/
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefinePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        /** Define a property on obj, throwing a TypeError if the attempt fails.
 This is the C++ equivalent of `Object.defineProperty(obj, id, desc)`.*/
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefinePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEEj"]
        pub fn JS_DefinePropertyById2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefinePropertyById3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_S5_j"]
        pub fn JS_DefinePropertyById4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEES5_j"]
        pub fn JS_DefinePropertyById5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_IP8JSStringEEj"]
        pub fn JS_DefinePropertyById6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEij"]
        pub fn JS_DefinePropertyById7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEjj"]
        pub fn JS_DefinePropertyById8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z21JS_DefinePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEdj"]
        pub fn JS_DefinePropertyById9(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEESB_j"]
        pub fn JS_DefineProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JSNative,
            setter: root::JSNative,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_S5_j"]
        pub fn JS_DefineProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcS5_j"]
        pub fn JS_DefineProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_IP8JSStringEEj"]
        pub fn JS_DefineProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcij"]
        pub fn JS_DefineProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcjj"]
        pub fn JS_DefineProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefinePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcdj"]
        pub fn JS_DefineProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEERNS1_14ObjectOpResultE"]
        pub fn JS_DefineUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_18PropertyDescriptorEEE"]
        pub fn JS_DefineUCProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            desc: root::JS::Handle<root::JS::PropertyDescriptor>,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineUCProperty2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_S5_j"]
        pub fn JS_DefineUCProperty3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmS5_j"]
        pub fn JS_DefineUCProperty4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_IP8JSStringEEj"]
        pub fn JS_DefineUCProperty5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmij"]
        pub fn JS_DefineUCProperty6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmjj"]
        pub fn JS_DefineUCProperty7(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DefineUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmdj"]
        pub fn JS_DefineUCProperty8(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEEj"]
        pub fn JS_DefineElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<root::JS::Value>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_S5_j"]
        pub fn JS_DefineElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            getter: root::JS::Handle<*mut root::JSObject>,
            setter: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_j"]
        pub fn JS_DefineElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSObject>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEEj"]
        pub fn JS_DefineElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: root::JS::Handle<*mut root::JSString>,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjij"]
        pub fn JS_DefineElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: i32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjjj"]
        pub fn JS_DefineElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: u32,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DefineElementP9JSContextN2JS6HandleIP8JSObjectEEjdj"]
        pub fn JS_DefineElement6(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            value: f64,
            attrs: ::std::os::raw::c_uint,
        ) -> bool;
        /** Compute the expression `id in obj`.

 If obj has an own or inherited property obj[id], set *foundp = true and
 return true. If not, set *foundp = false and return true. On error, return
 false with an exception pending.

 Implements: ES6 [[Has]] internal method.*/
        #[link_name = "\u{1}_Z18JS_HasPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_HasPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_HasUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_HasUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_HasElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_HasElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
        /** Determine whether obj has an own property with the key `id`.

 Implements: ES6 7.3.11 HasOwnProperty(O, P).*/
        #[link_name = "\u{1}_Z21JS_HasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_HasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_HasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_HasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
        /** Get the value of the property `obj[id]`, or undefined if no such property
 exists. This is the C++ equivalent of `vp = Reflect.get(obj, id, receiver)`.

 Most callers don't need the `receiver` argument. Consider using
 JS_GetProperty instead. (But if you're implementing a proxy handler's set()
 method, it's often correct to call this function and pass the receiver
 through.)

 Implements: ES6 [[Get]] internal method.*/
        #[link_name = "\u{1}_Z23JS_ForwardGetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEENS1_13MutableHandleIS8_EE"]
        pub fn JS_ForwardGetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            receiver: root::JS::Handle<root::JS::Value>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z22JS_ForwardGetElementToP9JSContextN2JS6HandleIP8JSObjectEEjS5_NS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_ForwardGetElementTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            receiver: root::JS::Handle<*mut root::JSObject>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        /** Get the value of the property `obj[id]`, or undefined if no such property
 exists. The result is stored in vp.

 Implements: ES6 7.3.1 Get(O, P).*/
        #[link_name = "\u{1}_Z18JS_GetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_GetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_GetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_GetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_GetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        /** Perform the same property assignment as `Reflect.set(obj, id, v, receiver)`.

 This function has a `receiver` argument that most callers don't need.
 Consider using JS_SetProperty instead.

 Implements: ES6 [[Set]] internal method.*/
        #[link_name = "\u{1}_Z23JS_ForwardSetPropertyToP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEES9_RNS1_14ObjectOpResultE"]
        pub fn JS_ForwardSetPropertyTo(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
            receiver: root::JS::Handle<root::JS::Value>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        /** Perform the assignment `obj[id] = v`.

 This function performs non-strict assignment, so if the property is
 read-only, nothing happens and no error is thrown.*/
        #[link_name = "\u{1}_Z18JS_SetPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEENS2_INS1_5ValueEEE"]
        pub fn JS_SetPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_SetPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcNS2_INS1_5ValueEEE"]
        pub fn JS_SetProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_SetUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmNS2_INS1_5ValueEEE"]
        pub fn JS_SetUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_INS1_5ValueEEE"]
        pub fn JS_SetElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<root::JS::Value>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjS5_"]
        pub fn JS_SetElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjNS2_IP8JSStringEE"]
        pub fn JS_SetElement2(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: root::JS::Handle<*mut root::JSString>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEji"]
        pub fn JS_SetElement3(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: i32,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjj"]
        pub fn JS_SetElement4(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: u32,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_SetElementP9JSContextN2JS6HandleIP8JSObjectEEjd"]
        pub fn JS_SetElement5(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            v: f64,
        ) -> bool;
        /** Delete a property. This is the C++ equivalent of
 `result = Reflect.deleteProperty(obj, id)`.

 This function has a `result` out parameter that most callers don't need.
 Unless you can pass through an ObjectOpResult provided by your caller, it's
 probably best to use the JS_DeletePropertyById signature with just 3
 arguments.

 Implements: ES6 [[Delete]] internal method.*/
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEERNS1_14ObjectOpResultE"]
        pub fn JS_DeletePropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_DeleteUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEjRNS1_14ObjectOpResultE"]
        pub fn JS_DeleteElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        /** Delete a property, ignoring strict failures. This is the C++ equivalent of
 the JS `delete obj[id]` in non-strict mode code.*/
        #[link_name = "\u{1}_Z21JS_DeletePropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEE"]
        pub fn JS_DeletePropertyById1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DeletePropertyP9JSContextN2JS6HandleIP8JSObjectEEPKc"]
        pub fn JS_DeleteProperty1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
        ) -> bool;
        #[link_name = "\u{1}_Z16JS_DeleteElementP9JSContextN2JS6HandleIP8JSObjectEEj"]
        pub fn JS_DeleteElement1(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
        ) -> bool;
        /** Get an array of the non-symbol enumerable properties of obj.
 This function is roughly equivalent to:

     var result = [];
     for (key in obj) {
         result.push(key);
     }
     return result;

 This is the closest thing we currently have to the ES6 [[Enumerate]]
 internal method.

 The array of ids returned by JS_Enumerate must be rooted to protect its
 contents from garbage collection. Use JS::Rooted<JS::IdVector>.*/
        #[link_name = "\u{1}_Z12JS_EnumerateP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_8GCVectorINS1_11PropertyKeyELm0EN2js15TempAllocPolicyEEEEE"]
        pub fn JS_Enumerate(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            props: root::JS::MutableHandle<root::JS::IdVector>,
        ) -> bool;
        /// Other property-defining functions
        #[link_name = "\u{1}_Z15JS_DefineObjectP9JSContextN2JS6HandleIP8JSObjectEEPKcPK7JSClassj"]
        pub fn JS_DefineObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            clasp: *const root::JSClass,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z19JS_DefinePropertiesP9JSContextN2JS6HandleIP8JSObjectEEPK14JSPropertySpec"]
        pub fn JS_DefineProperties(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            ps: *const root::JSPropertySpec,
        ) -> bool;
        #[link_name = "\u{1}_Z28JS_AlreadyHasOwnPropertyByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_AlreadyHasOwnPropertyById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z24JS_AlreadyHasOwnPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKcPb"]
        pub fn JS_AlreadyHasOwnProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_AlreadyHasOwnUCPropertyP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPb"]
        pub fn JS_AlreadyHasOwnUCProperty(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z23JS_AlreadyHasOwnElementP9JSContextN2JS6HandleIP8JSObjectEEjPb"]
        pub fn JS_AlreadyHasOwnElement(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            index: u32,
            foundp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z18JS_DefineFunctionsP9JSContextN2JS6HandleIP8JSObjectEEPK14JSFunctionSpec"]
        pub fn JS_DefineFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            fs: *const root::JSFunctionSpec,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_DefineFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKcPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const ::std::os::raw::c_char,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
        #[link_name = "\u{1}_Z19JS_DefineUCFunctionP9JSContextN2JS6HandleIP8JSObjectEEPKDsmPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineUCFunction(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            name: *const u16,
            namelen: usize,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
        #[link_name = "\u{1}_Z21JS_DefineFunctionByIdP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPFbS0_jPNS1_5ValueEEjj"]
        pub fn JS_DefineFunctionById(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            id: root::JS::Handle<root::jsid>,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            attrs: ::std::os::raw::c_uint,
        ) -> *mut root::JSFunction;
        /** This function calls |compartmentCallback| on every compartment until either
 all compartments have been iterated or CompartmentIterResult::Stop is
 returned. Beware that there is no guarantee that the compartment will survive
 after the callback returns. Also, barriers are disabled via the TraceSession.*/
        #[link_name = "\u{1}_Z22JS_IterateCompartmentsP9JSContextPvPFN2JS21CompartmentIterResultES0_S1_PNS2_11CompartmentEE"]
        pub fn JS_IterateCompartments(
            cx: *mut root::JSContext,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
        /** This function calls |compartmentCallback| on every compartment in the given
 zone until either all compartments have been iterated or
 CompartmentIterResult::Stop is returned. Beware that there is no guarantee
 that the compartment will survive after the callback returns. Also, barriers
 are disabled via the TraceSession.*/
        #[link_name = "\u{1}_Z28JS_IterateCompartmentsInZoneP9JSContextPN2JS4ZoneEPvPFNS1_21CompartmentIterResultES0_S4_PNS1_11CompartmentEE"]
        pub fn JS_IterateCompartmentsInZone(
            cx: *mut root::JSContext,
            zone: *mut root::JS::Zone,
            data: *mut ::std::os::raw::c_void,
            compartmentCallback: root::JSIterateCompartmentCallback,
        );
        #[link_name = "\u{1}_Z25JS_SetDestroyZoneCallbackP9JSContextPFvPN2JS9GCContextEPNS1_4ZoneEE"]
        pub fn JS_SetDestroyZoneCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyZoneCallback,
        );
        #[link_name = "\u{1}_Z32JS_SetDestroyCompartmentCallbackP9JSContextPFvPN2JS9GCContextEPNS1_11CompartmentEE"]
        pub fn JS_SetDestroyCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSDestroyCompartmentCallback,
        );
        #[link_name = "\u{1}_Z44JS_SetSizeOfIncludingThisCompartmentCallbackP9JSContextPFmPFmPKvEPN2JS11CompartmentEE"]
        pub fn JS_SetSizeOfIncludingThisCompartmentCallback(
            cx: *mut root::JSContext,
            callback: root::JSSizeOfIncludingThisCompartmentCallback,
        );
        #[link_name = "\u{1}_Z24JS_SetCompartmentPrivatePN2JS11CompartmentEPv"]
        pub fn JS_SetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z24JS_GetCompartmentPrivatePN2JS11CompartmentE"]
        pub fn JS_GetCompartmentPrivate(
            compartment: *mut root::JS::Compartment,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z18JS_SetZoneUserDataPN2JS4ZoneEPv"]
        pub fn JS_SetZoneUserData(
            zone: *mut root::JS::Zone,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z18JS_GetZoneUserDataPN2JS4ZoneE"]
        pub fn JS_GetZoneUserData(
            zone: *mut root::JS::Zone,
        ) -> *mut ::std::os::raw::c_void;
        #[link_name = "\u{1}_Z34JS_RefreshCrossCompartmentWrappersP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_RefreshCrossCompartmentWrappers(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
        /** Mark a jsid after entering a new compartment. Different zones separately
 mark the ids in a runtime, and this must be used any time an id is obtained
 from one compartment and then used in another compartment, unless the two
 compartments are guaranteed to be in the same zone.*/
        #[link_name = "\u{1}_Z18JS_MarkCrossZoneIdP9JSContextN2JS11PropertyKeyE"]
        pub fn JS_MarkCrossZoneId(cx: *mut root::JSContext, id: root::jsid);
        /** If value stores a jsid (an atomized string or symbol), mark that id as for
 JS_MarkCrossZoneId.*/
        #[link_name = "\u{1}_Z23JS_MarkCrossZoneIdValueP9JSContextRKN2JS5ValueE"]
        pub fn JS_MarkCrossZoneIdValue(
            cx: *mut root::JSContext,
            value: *const root::JS::Value,
        );
        #[link_name = "\u{1}_ZL14JS_NumberValued"]
        pub fn JS_NumberValue(d: f64) -> root::JS::Value;
        #[link_name = "\u{1}_Z22JS_StringHasBeenPinnedP9JSContextP8JSString"]
        pub fn JS_StringHasBeenPinned(
            cx: *mut root::JSContext,
            str_: *mut root::JSString,
        ) -> bool;
        /// Microseconds since the epoch, midnight, January 1, 1970 UTC.
        #[link_name = "\u{1}_Z6JS_Nowv"]
        pub fn JS_Now() -> i64;
        #[link_name = "\u{1}_Z16JS_ValueToObjectP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleIP8JSObjectEE"]
        pub fn JS_ValueToObject(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            objp: root::JS::MutableHandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z18JS_ValueToFunctionP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToFunction(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
        #[link_name = "\u{1}_Z21JS_ValueToConstructorP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToConstructor(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
        ) -> *mut root::JSFunction;
        #[link_name = "\u{1}_Z16JS_ValueToSourceP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_ValueToSource(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z16JS_DoubleIsInt32dPi"]
        pub fn JS_DoubleIsInt32(d: f64, ip: *mut i32) -> bool;
        #[link_name = "\u{1}_Z14JS_TypeOfValueP9JSContextN2JS6HandleINS1_5ValueEEE"]
        pub fn JS_TypeOfValue(
            cx: *mut root::JSContext,
            v: root::JS::Handle<root::JS::Value>,
        ) -> root::JSType;
        /// True iff fun is the global eval function.
        #[link_name = "\u{1}_Z24JS_IsBuiltinEvalFunctionP10JSFunction"]
        pub fn JS_IsBuiltinEvalFunction(fun: *mut root::JSFunction) -> bool;
        /// True iff fun is the Function constructor.
        #[link_name = "\u{1}_Z31JS_IsBuiltinFunctionConstructorP10JSFunction"]
        pub fn JS_IsBuiltinFunctionConstructor(fun: *mut root::JSFunction) -> bool;
        #[link_name = "\u{1}_Z27JS_GetImplementationVersionv"]
        pub fn JS_GetImplementationVersion() -> *const ::std::os::raw::c_char;
        #[link_name = "\u{1}_Z25JS_SetWrapObjectCallbacksP9JSContextPK21JSWrapObjectCallbacks"]
        pub fn JS_SetWrapObjectCallbacks(
            cx: *mut root::JSContext,
            callbacks: *const root::JSWrapObjectCallbacks,
        );
        #[link_name = "\u{1}_Z15JS_GetErrorTypeRKN2JS5ValueE"]
        pub fn JS_GetErrorType(val: *const root::JS::Value) -> root::mozilla::Maybe;
        #[link_name = "\u{1}_Z13JS_WrapObjectP9JSContextN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_WrapObject(
            cx: *mut root::JSContext,
            objp: root::JS::MutableHandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z12JS_WrapValueP9JSContextN2JS13MutableHandleINS1_5ValueEEE"]
        pub fn JS_WrapValue(
            cx: *mut root::JSContext,
            vp: root::JS::MutableHandleValue,
        ) -> bool;
        #[link_name = "\u{1}_Z19JS_TransplantObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_TransplantObject(
            cx: *mut root::JSContext,
            origobj: root::JS::HandleObject,
            target: root::JS::HandleObject,
        ) -> *mut root::JSObject;
        /** Resolve id, which must contain either a string or an int, to a standard
 class name in obj if possible, defining the class's constructor and/or
 prototype and storing true in *resolved.  If id does not name a standard
 class or a top-level property induced by initializing a standard class,
 store false in *resolved and just return true.  Return false on error,
 as usual for bool result-typed API entry points.

 This API can be called directly from a global object class's resolve op,
 to define standard classes lazily. The class should either have an enumerate
 hook that calls JS_EnumerateStandardClasses, or a newEnumerate hook that
 calls JS_NewEnumerateStandardClasses. newEnumerate is preferred because it's
 faster (does not define all standard classes).*/
        #[link_name = "\u{1}_Z23JS_ResolveStandardClassP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_11PropertyKeyEEEPb"]
        pub fn JS_ResolveStandardClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            id: root::JS::HandleId,
            resolved: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_MayResolveStandardClassRK11JSAtomStateN2JS11PropertyKeyEP8JSObject"]
        pub fn JS_MayResolveStandardClass(
            names: *const root::JSAtomState,
            id: root::jsid,
            maybeObj: *mut root::JSObject,
        ) -> bool;
        #[link_name = "\u{1}_Z27JS_EnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_EnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
        /** Fill "properties" with a list of standard class names that have not yet been
 resolved on "obj".  This can be used as (part of) a newEnumerate class hook
 on a global.  Already-resolved things are excluded because they might have
 been deleted by script after being resolved and enumeration considers
 already-defined properties anyway.*/
        #[link_name = "\u{1}_Z30JS_NewEnumerateStandardClassesP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClasses(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
        /** Fill "properties" with a list of standard class names.  This can be used for
 proxies that want to define behavior that looks like enumerating a global
 without touching the global itself.*/
        #[link_name = "\u{1}_Z47JS_NewEnumerateStandardClassesIncludingResolvedP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleINS1_13StackGCVectorINS1_11PropertyKeyEN2js15TempAllocPolicyEEEEEb"]
        pub fn JS_NewEnumerateStandardClassesIncludingResolved(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            properties: root::JS::MutableHandleIdVector,
            enumerableOnly: bool,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_GetClassObjectP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassObject(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z20JS_GetClassPrototypeP9JSContext10JSProtoKeyN2JS13MutableHandleIP8JSObjectEE"]
        pub fn JS_GetClassPrototype(
            cx: *mut root::JSContext,
            key: root::JSProtoKey,
            objp: root::JS::MutableHandle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z15JS_IdToProtoKeyP9JSContextN2JS6HandleINS1_11PropertyKeyEEE"]
        pub fn JS_IdToProtoKey(
            cx: *mut root::JSContext,
            id: root::JS::HandleId,
        ) -> root::JSProtoKey;
        #[link_name = "\u{1}_Z27JS_GlobalLexicalEnvironmentP8JSObject"]
        pub fn JS_GlobalLexicalEnvironment(
            obj: *mut root::JSObject,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z34JS_HasExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_HasExtensibleLexicalEnvironment(obj: *mut root::JSObject) -> bool;
        #[link_name = "\u{1}_Z31JS_ExtensibleLexicalEnvironmentP8JSObject"]
        pub fn JS_ExtensibleLexicalEnvironment(
            obj: *mut root::JSObject,
        ) -> *mut root::JSObject;
        /** Add 'Reflect.parse', a SpiderMonkey extension, to the Reflect object on the
 given global.*/
        #[link_name = "\u{1}_Z19JS_InitReflectParseP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_InitReflectParse(
            cx: *mut root::JSContext,
            global: root::JS::HandleObject,
        ) -> bool;
        /** Add various profiling-related functions as properties of the given object.
 Defined in builtin/Profilers.cpp.*/
        #[link_name = "\u{1}_Z27JS_DefineProfilingFunctionsP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DefineProfilingFunctions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z12JS_ValueToIdP9JSContextN2JS6HandleINS1_5ValueEEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_ValueToId(
            cx: *mut root::JSContext,
            v: root::JS::HandleValue,
            idp: root::JS::MutableHandleId,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_StringToIdP9JSContextN2JS6HandleIP8JSStringEENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_StringToId(
            cx: *mut root::JSContext,
            s: root::JS::HandleString,
            idp: root::JS::MutableHandleId,
        ) -> bool;
        #[link_name = "\u{1}_Z12JS_IdToValueP9JSContextN2JS11PropertyKeyENS1_13MutableHandleINS1_5ValueEEE"]
        pub fn JS_IdToValue(
            cx: *mut root::JSContext,
            id: root::jsid,
            vp: root::JS::MutableHandle<root::JS::Value>,
        ) -> bool;
        /** Defines a builtin constructor and prototype. Returns the prototype object.

 - Defines a property named `name` on `obj`, with its value set to a
   newly-created JS function that invokes the `constructor` JSNative. The
   `length` of the function is `nargs`.

 - Creates a prototype object with proto `protoProto` and class `protoClass`.
   If `protoProto` is `nullptr`, `Object.prototype` will be used instead.
   If `protoClass` is `nullptr`, the prototype object will be a plain JS
   object.

 - The `ps` and `fs` properties/functions will be defined on the prototype
   object.

 - The `static_ps` and `static_fs` properties/functions will be defined on the
   constructor.*/
        #[link_name = "\u{1}_Z12JS_InitClassP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassS5_PKcPFbS0_jPNS1_5ValueEEjPK14JSPropertySpecPK14JSFunctionSpecSH_SK_"]
        pub fn JS_InitClass(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            protoClass: *const root::JSClass,
            protoProto: root::JS::HandleObject,
            name: *const ::std::os::raw::c_char,
            constructor: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            ps: *const root::JSPropertySpec,
            fs: *const root::JSFunctionSpec,
            static_ps: *const root::JSPropertySpec,
            static_fs: *const root::JSFunctionSpec,
        ) -> *mut root::JSObject;
        /** Set up ctor.prototype = proto and proto.constructor = ctor with the
 right property flags.*/
        #[link_name = "\u{1}_Z30JS_LinkConstructorAndPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_LinkConstructorAndPrototype(
            cx: *mut root::JSContext,
            ctor: root::JS::Handle<*mut root::JSObject>,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
        #[link_name = "\u{1}_Z13JS_InstanceOfP9JSContextN2JS6HandleIP8JSObjectEEPK7JSClassPNS1_8CallArgsE"]
        pub fn JS_InstanceOf(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            clasp: *const root::JSClass,
            args: *mut root::JS::CallArgs,
        ) -> bool;
        #[link_name = "\u{1}_Z14JS_HasInstanceP9JSContextN2JS6HandleIP8JSObjectEENS2_INS1_5ValueEEEPb"]
        pub fn JS_HasInstance(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
            v: root::JS::Handle<root::JS::Value>,
            bp: *mut bool,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_GetConstructorP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_GetConstructor(
            cx: *mut root::JSContext,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z12JS_NewObjectP9JSContextPK7JSClass"]
        pub fn JS_NewObject(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z11JS_IsNativeP8JSObject"]
        pub fn JS_IsNative(obj: *mut root::JSObject) -> bool;
        /** Unlike JS_NewObject, JS_NewObjectWithGivenProto does not compute a default
 proto. If proto is nullptr, the JS object will have `null` as [[Prototype]].*/
        #[link_name = "\u{1}_Z26JS_NewObjectWithGivenProtoP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithGivenProto(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        /** Creates a new plain object, like `new Object()`, with Object.prototype as
 [[Prototype]].*/
        #[link_name = "\u{1}_Z17JS_NewPlainObjectP9JSContext"]
        pub fn JS_NewPlainObject(cx: *mut root::JSContext) -> *mut root::JSObject;
        /** Freeze obj, and all objects it refers to, recursively. This will not recurse
 through non-extensible objects, on the assumption that those are already
 deep-frozen.*/
        #[link_name = "\u{1}_Z19JS_DeepFreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_DeepFreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
        /// Freezes an object; see ES5's Object.freeze(obj) method.
        #[link_name = "\u{1}_Z15JS_FreezeObjectP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FreezeObject(
            cx: *mut root::JSContext,
            obj: root::JS::Handle<*mut root::JSObject>,
        ) -> bool;
        /** Get the prototype of |obj|, storing it in |proto|.

 Implements: ES6 [[GetPrototypeOf]] internal method.*/
        #[link_name = "\u{1}_Z15JS_GetPrototypeP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: root::JS::MutableHandleObject,
        ) -> bool;
        /** If |obj| (underneath any functionally-transparent wrapper proxies) has as
 its [[GetPrototypeOf]] trap the ordinary [[GetPrototypeOf]] behavior defined
 for ordinary objects, set |*isOrdinary = true| and store |obj|'s prototype
 in |result|.  Otherwise set |*isOrdinary = false|.  In case of error, both
 outparams have unspecified value.*/
        #[link_name = "\u{1}_Z25JS_GetPrototypeIfOrdinaryP9JSContextN2JS6HandleIP8JSObjectEEPbNS1_13MutableHandleIS4_EE"]
        pub fn JS_GetPrototypeIfOrdinary(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            isOrdinary: *mut bool,
            result: root::JS::MutableHandleObject,
        ) -> bool;
        /** Change the prototype of obj.

 Implements: ES6 [[SetPrototypeOf]] internal method.

 In cases where ES6 [[SetPrototypeOf]] returns false without an exception,
 JS_SetPrototype throws a TypeError and returns false.

 Performance warning: JS_SetPrototype is very bad for performance. It may
 cause compiled jit-code to be invalidated. It also causes not only obj but
 all other objects in the same "group" as obj to be permanently deoptimized.
 It's better to create the object with the right prototype from the start.*/
        #[link_name = "\u{1}_Z15JS_SetPrototypeP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_SetPrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> bool;
        /** Determine whether obj is extensible. Extensible objects can have new
 properties defined on them. Inextensible objects can't, and their
 [[Prototype]] slot is fixed as well.

 Implements: ES6 [[IsExtensible]] internal method.*/
        #[link_name = "\u{1}_Z15JS_IsExtensibleP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_IsExtensible(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            extensible: *mut bool,
        ) -> bool;
        /** Attempt to make |obj| non-extensible.

 Not all failures are treated as errors. See the comment on
 JS::ObjectOpResult in js/public/Class.h.

 Implements: ES6 [[PreventExtensions]] internal method.*/
        #[link_name = "\u{1}_Z20JS_PreventExtensionsP9JSContextN2JS6HandleIP8JSObjectEERNS1_14ObjectOpResultE"]
        pub fn JS_PreventExtensions(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            result: *mut root::JS::ObjectOpResult,
        ) -> bool;
        /** Attempt to make the [[Prototype]] of |obj| immutable, such that any attempt
 to modify it will fail.  If an error occurs during the attempt, return false
 (with a pending exception set, depending upon the nature of the error).  If
 no error occurs, return true with |*succeeded| set to indicate whether the
 attempt successfully made the [[Prototype]] immutable.

 This is a nonstandard internal method.*/
        #[link_name = "\u{1}_Z24JS_SetImmutablePrototypeP9JSContextN2JS6HandleIP8JSObjectEEPb"]
        pub fn JS_SetImmutablePrototype(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            succeeded: *mut bool,
        ) -> bool;
        /** Equivalent to `Object.assign(target, src)`: Copies the properties from the
 `src` object (which must not be null) to `target` (which also must not be
 null).*/
        #[link_name = "\u{1}_Z15JS_AssignObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_AssignObject(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
        /** Assign 'undefined' to all of the object's non-reserved slots. Note: this is
 done for all slots, regardless of the associated property descriptor.*/
        #[link_name = "\u{1}_Z36JS_SetAllNonReservedSlotsToUndefinedN2JS6HandleIP8JSObjectEE"]
        pub fn JS_SetAllNonReservedSlotsToUndefined(obj: root::JS::HandleObject);
        #[link_name = "\u{1}_Z18JS_SetReservedSlotP8JSObjectjRKN2JS5ValueE"]
        pub fn JS_SetReservedSlot(
            obj: *mut root::JSObject,
            index: u32,
            v: *const root::JS::Value,
        );
        #[link_name = "\u{1}_Z19JS_InitReservedSlotP8JSObjectjPvmN2JS9MemoryUseE"]
        pub fn JS_InitReservedSlot(
            obj: *mut root::JSObject,
            index: u32,
            ptr: *mut ::std::os::raw::c_void,
            nbytes: usize,
            use_: root::JS::MemoryUse,
        );
        #[link_name = "\u{1}_Z14JS_NewFunctionP9JSContextPFbS0_jPN2JS5ValueEEjjPKc"]
        pub fn JS_NewFunction(
            cx: *mut root::JSContext,
            call: root::JSNative,
            nargs: ::std::os::raw::c_uint,
            flags: ::std::os::raw::c_uint,
            name: *const ::std::os::raw::c_char,
        ) -> *mut root::JSFunction;
        #[link_name = "\u{1}_Z20JS_GetFunctionObjectP10JSFunction"]
        pub fn JS_GetFunctionObject(fun: *mut root::JSFunction) -> *mut root::JSObject;
        /** Return the function's identifier as a JSString, or null if fun is unnamed.

 The returned string lives as long as fun, so you don't need to root a saved
 reference to it if fun is well-connected or rooted, and provided you bound
 the use of the saved reference by fun's lifetime.

 This function returns false if any error happens while generating the
 function name string for a function with lazy name.*/
        #[link_name = "\u{1}_Z16JS_GetFunctionIdP9JSContextN2JS6HandleIP10JSFunctionEENS1_13MutableHandleIP8JSStringEE"]
        pub fn JS_GetFunctionId(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
            name: root::JS::MutableHandle<*mut root::JSString>,
        ) -> bool;
        /** Almost same as JS_GetFunctionId.

 If the function has lazy name, this returns partial name, such as the
 function name without "get " or "set " prefix.*/
        #[link_name = "\u{1}_Z28JS_GetMaybePartialFunctionIdP10JSFunction"]
        pub fn JS_GetMaybePartialFunctionId(
            fun: *mut root::JSFunction,
        ) -> *mut root::JSString;
        /** Return a function's display name as `name` out-parameter.

 This is the defined name if one was given where the function was defined, or
 it could be an inferred name by the JS engine in the case that the function
 was defined to be anonymous.

 This can still return nullptr as `name` out-parameter if a useful display
 name could not be inferred.

 This function returns false if any error happens while generating the
 function name string for a function with lazy name.*/
        #[link_name = "\u{1}_Z23JS_GetFunctionDisplayIdP9JSContextN2JS6HandleIP10JSFunctionEENS1_13MutableHandleIP8JSStringEE"]
        pub fn JS_GetFunctionDisplayId(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
            name: root::JS::MutableHandle<*mut root::JSString>,
        ) -> bool;
        /** Almost same as JS_GetFunctionDisplayId.

 If the function has lazy name, this returns partial name, such as the
 function name without "get " or "set " prefix.*/
        #[link_name = "\u{1}_Z35JS_GetMaybePartialFunctionDisplayIdP10JSFunction"]
        pub fn JS_GetMaybePartialFunctionDisplayId(
            arg1: *mut root::JSFunction,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z19JS_GetFunctionArityP10JSFunction"]
        pub fn JS_GetFunctionArity(fun: *mut root::JSFunction) -> u16;
        #[link_name = "\u{1}_Z20JS_GetFunctionLengthP9JSContextN2JS6HandleIP10JSFunctionEEPt"]
        pub fn JS_GetFunctionLength(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
            length: *mut u16,
        ) -> bool;
        /** Infallible predicate to test whether obj is a function object (faster than
 comparing obj's class name to "Function", but equivalent unless someone has
 overwritten the "Function" identifier with a different constructor and then
 created instances using that constructor that might be passed in as obj).*/
        #[link_name = "\u{1}_Z19JS_ObjectIsFunctionP8JSObject"]
        pub fn JS_ObjectIsFunction(obj: *mut root::JSObject) -> bool;
        #[link_name = "\u{1}_Z19JS_IsNativeFunctionP8JSObjectPFbP9JSContextjPN2JS5ValueEE"]
        pub fn JS_IsNativeFunction(
            funobj: *mut root::JSObject,
            call: root::JSNative,
        ) -> bool;
        /// Return whether the given function is a valid constructor.
        #[link_name = "\u{1}_Z16JS_IsConstructorP10JSFunction"]
        pub fn JS_IsConstructor(fun: *mut root::JSFunction) -> bool;
        #[link_name = "\u{1}_Z24JS_ObjectIsBoundFunctionP8JSObject"]
        pub fn JS_ObjectIsBoundFunction(obj: *mut root::JSObject) -> bool;
        #[link_name = "\u{1}_Z25JS_GetBoundFunctionTargetP8JSObject"]
        pub fn JS_GetBoundFunctionTarget(
            obj: *mut root::JSObject,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z22JS_GetGlobalFromScriptP8JSScript"]
        pub fn JS_GetGlobalFromScript(
            script: *mut root::JSScript,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z20JS_GetScriptFilenameP8JSScript"]
        pub fn JS_GetScriptFilename(
            script: *mut root::JSScript,
        ) -> *const ::std::os::raw::c_char;
        #[link_name = "\u{1}_Z26JS_GetScriptBaseLineNumberP9JSContextP8JSScript"]
        pub fn JS_GetScriptBaseLineNumber(
            cx: *mut root::JSContext,
            script: *mut root::JSScript,
        ) -> ::std::os::raw::c_uint;
        #[link_name = "\u{1}_Z20JS_GetFunctionScriptP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_GetFunctionScript(
            cx: *mut root::JSContext,
            fun: root::JS::HandleFunction,
        ) -> *mut root::JSScript;
        #[link_name = "\u{1}_Z18JS_DecompileScriptP9JSContextN2JS6HandleIP8JSScriptEE"]
        pub fn JS_DecompileScript(
            cx: *mut root::JSContext,
            script: root::JS::Handle<*mut root::JSScript>,
        ) -> *mut root::JSString;
        #[link_name = "\u{1}_Z20JS_DecompileFunctionP9JSContextN2JS6HandleIP10JSFunctionEE"]
        pub fn JS_DecompileFunction(
            cx: *mut root::JSContext,
            fun: root::JS::Handle<*mut root::JSFunction>,
        ) -> *mut root::JSString;
        /** A JS context always has an "owner thread". The owner thread is set when the
 context is created (to the current thread) and practically all entry points
 into the JS engine check that a context (or anything contained in the
 context: runtime, compartment, object, etc) is only touched by its owner
 thread. Embeddings may check this invariant outside the JS engine by calling
 JS_AbortIfWrongThread (which will abort if not on the owner thread, even for
 non-debug builds).*/
        #[link_name = "\u{1}_Z21JS_AbortIfWrongThreadP9JSContext"]
        pub fn JS_AbortIfWrongThread(cx: *mut root::JSContext);
        /** A constructor can request that the JS engine create a default new 'this'
 object of the given class, using the callee to determine parentage and
 [[Prototype]].*/
        #[link_name = "\u{1}_Z26JS_NewObjectForConstructorP9JSContextPK7JSClassRKN2JS8CallArgsE"]
        pub fn JS_NewObjectForConstructor(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            args: *const root::JS::CallArgs,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z28JS_SetParallelParsingEnabledP9JSContextb"]
        pub fn JS_SetParallelParsingEnabled(cx: *mut root::JSContext, enabled: bool);
        #[link_name = "\u{1}_Z36JS_SetOffthreadIonCompilationEnabledP9JSContextb"]
        pub fn JS_SetOffthreadIonCompilationEnabled(
            cx: *mut root::JSContext,
            enabled: bool,
        );
        #[link_name = "\u{1}_Z29JS_SetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionj"]
        pub fn JS_SetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            value: u32,
        );
        #[link_name = "\u{1}_Z29JS_GetGlobalJitCompilerOptionP9JSContext19JSJitCompilerOptionPj"]
        pub fn JS_GetGlobalJitCompilerOption(
            cx: *mut root::JSContext,
            opt: root::JSJitCompilerOption,
            valueOut: *mut u32,
        ) -> bool;
        /// Convert a uint32_t index into a jsid.
        #[link_name = "\u{1}_Z12JS_IndexToIdP9JSContextjN2JS13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_IndexToId(
            cx: *mut root::JSContext,
            index: u32,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
        /** Convert chars into a jsid.

 |chars| may not be an index.*/
        #[link_name = "\u{1}_Z12JS_CharsToIdP9JSContextN2JS12TwoByteCharsENS1_13MutableHandleINS1_11PropertyKeyEEE"]
        pub fn JS_CharsToId(
            cx: *mut root::JSContext,
            chars: root::JS::TwoByteChars,
            arg1: root::JS::MutableHandleId,
        ) -> bool;
        ///  Test if the given string is a valid ECMAScript identifier
        #[link_name = "\u{1}_Z15JS_IsIdentifierP9JSContextN2JS6HandleIP8JSStringEEPb"]
        pub fn JS_IsIdentifier(
            cx: *mut root::JSContext,
            str_: root::JS::HandleString,
            isIdentifier: *mut bool,
        ) -> bool;
        /** Test whether the given chars + length are a valid ECMAScript identifier.
 This version is infallible, so just returns whether the chars are an
 identifier.*/
        #[link_name = "\u{1}_Z15JS_IsIdentifierPKDsm"]
        pub fn JS_IsIdentifier1(chars: *const u16, length: usize) -> bool;
        #[link_name = "\u{1}_Z23JS_SetGrayGCRootsTracerP9JSContextPFbP8JSTracerRN2JS11SliceBudgetEPvES6_"]
        pub fn JS_SetGrayGCRootsTracer(
            cx: *mut root::JSContext,
            traceOp: root::JSGrayRootsTracer,
            data: *mut ::std::os::raw::c_void,
        );
        #[link_name = "\u{1}_Z23JS_FindCompilationScopeP9JSContextN2JS6HandleIP8JSObjectEE"]
        pub fn JS_FindCompilationScope(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z20JS_GetObjectFunctionP8JSObject"]
        pub fn JS_GetObjectFunction(obj: *mut root::JSObject) -> *mut root::JSFunction;
        /** Allocate an object in exactly the same way as JS_NewObjectWithGivenProto, but
 without invoking the metadata callback on it.  This allows creation of
 internal bookkeeping objects that are guaranteed to not have metadata
 attached to them.*/
        #[link_name = "\u{1}_Z27JS_NewObjectWithoutMetadataP9JSContextPK7JSClassN2JS6HandleIP8JSObjectEE"]
        pub fn JS_NewObjectWithoutMetadata(
            cx: *mut root::JSContext,
            clasp: *const root::JSClass,
            proto: root::JS::Handle<*mut root::JSObject>,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakMapKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakMapKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z33JS_NondeterministicGetWeakSetKeysP9JSContextN2JS6HandleIP8JSObjectEENS1_13MutableHandleIS4_EE"]
        pub fn JS_NondeterministicGetWeakSetKeys(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            ret: root::JS::MutableHandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z17JS_PCToLineNumberP8JSScriptPhPN2JS28LimitedColumnNumberOneOriginE"]
        pub fn JS_PCToLineNumber(
            script: *mut root::JSScript,
            pc: *mut root::jsbytecode,
            columnp: *mut root::JS::LimitedColumnNumberOneOrigin,
        ) -> ::std::os::raw::c_uint;
        /** Determine whether the given object is backed by a DeadObjectProxy.

 Such objects hold no other objects (they have no outgoing reference edges)
 and will throw if you touch them (e.g. by reading/writing a property).*/
        #[link_name = "\u{1}_Z16JS_IsDeadWrapperP8JSObject"]
        pub fn JS_IsDeadWrapper(obj: *mut root::JSObject) -> bool;
        /** Creates a new dead wrapper object in the given scope. To be used when
 attempting to wrap objects from scopes which are already dead.

 If origObject is passed, it must be an proxy object, and will be
 used to determine the characteristics of the new dead wrapper.*/
        #[link_name = "\u{1}_Z17JS_NewDeadWrapperP9JSContextP8JSObject"]
        pub fn JS_NewDeadWrapper(
            cx: *mut root::JSContext,
            origObject: *mut root::JSObject,
        ) -> *mut root::JSObject;
        #[link_name = "\u{1}_Z35JS_TraceShapeCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceShapeCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            shape: root::JS::GCCellPtr,
        );
        #[link_name = "\u{1}_Z41JS_TraceObjectGroupCycleCollectorChildrenPN2JS14CallbackTracerENS_9GCCellPtrE"]
        pub fn JS_TraceObjectGroupCycleCollectorChildren(
            trc: *mut root::JS::CallbackTracer,
            group: root::JS::GCCellPtr,
        );
        #[link_name = "\u{1}_Z22JS_GetScriptPrincipalsP8JSScript"]
        pub fn JS_GetScriptPrincipals(
            script: *mut root::JSScript,
        ) -> *mut root::JSPrincipals;
        #[link_name = "\u{1}_Z23JS_ScriptHasMutedErrorsP8JSScript"]
        pub fn JS_ScriptHasMutedErrors(script: *mut root::JSScript) -> bool;
        #[link_name = "\u{1}_Z14JS_CloneObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CloneObject(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            proto: root::JS::HandleObject,
        ) -> *mut root::JSObject;
        /** Copy the own properties of src to dst in a fast way.  src and dst must both
 be native and must be in the compartment of cx.  They must have the same
 class, the same parent, and the same prototype.  Class reserved slots will
 NOT be copied.

 dst must not have any properties on it before this function is called.

 src must have been allocated via JS_NewObjectWithoutMetadata so that we can
 be sure it has no metadata that needs copying to dst.  This also means that
 dst needs to have the compartment global as its parent.  This function will
 preserve the existing metadata on dst, if any.*/
        #[link_name = "\u{1}_Z49JS_InitializePropertiesFromCompatibleNativeObjectP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_InitializePropertiesFromCompatibleNativeObject(
            cx: *mut root::JSContext,
            dst: root::JS::HandleObject,
            src: root::JS::HandleObject,
        ) -> bool;
        /** Copies all own properties and private fields from |obj| to |target|. Both
 |obj| and |target| must not be cross-compartment wrappers because we have to
 enter their realms.

 This function immediately enters a realm, and does not impose any
 restrictions on the realm of |cx|.*/
        #[link_name = "\u{1}_Z36JS_CopyOwnPropertiesAndPrivateFieldsP9JSContextN2JS6HandleIP8JSObjectEES5_"]
        pub fn JS_CopyOwnPropertiesAndPrivateFields(
            cx: *mut root::JSContext,
            target: root::JS::HandleObject,
            obj: root::JS::HandleObject,
        ) -> bool;
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleINS1_18PropertyDescriptorEEE"]
        pub fn JS_WrapPropertyDescriptor(
            cx: *mut root::JSContext,
            desc: root::JS::MutableHandle<root::JS::PropertyDescriptor>,
        ) -> bool;
        #[link_name = "\u{1}_Z25JS_WrapPropertyDescriptorP9JSContextN2JS13MutableHandleIN7mozilla5MaybeINS1_18PropertyDescriptorEEEEE"]
        pub fn JS_WrapPropertyDescriptor1(
            cx: *mut root::JSContext,
            desc: root::JS::MutableHandle<root::mozilla::Maybe>,
        ) -> bool;
        #[link_name = "\u{1}_Z26JS_DefineFunctionsWithHelpP9JSContextN2JS6HandleIP8JSObjectEEPK22JSFunctionSpecWithHelp"]
        pub fn JS_DefineFunctionsWithHelp(
            cx: *mut root::JSContext,
            obj: root::JS::HandleObject,
            fs: *const root::JSFunctionSpecWithHelp,
        ) -> bool;
    }
}
