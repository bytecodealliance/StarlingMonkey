{
  "Aborting rejects with AbortError": {
    "status": "PASS"
  },
  "Aborting rejects with abort reason": {
    "status": "PASS"
  },
  "Aborting rejects with AbortError - no-cors": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's window is not null": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Input URL is not valid": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Input URL has credentials": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's mode is navigate": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's referrer is invalid": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's method is invalid": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's method is forbidden": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's mode is no-cors and method is not simple": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - RequestInit's cache mode is only-if-cached and mode is not same-origin": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode cors": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode no-cors": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Bad referrerPolicy init parameter value": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Bad mode init parameter value": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Bad credentials init parameter value": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Bad cache init parameter value": {
    "status": "PASS"
  },
  "TypeError from request constructor takes priority - Bad redirect init parameter value": {
    "status": "PASS"
  },
  "Request objects have a signal property": {
    "status": "PASS"
  },
  "Signal on request object": {
    "status": "PASS"
  },
  "Signal on request object should also have abort reason": {
    "status": "PASS"
  },
  "Signal on request object created from request object": {
    "status": "PASS"
  },
  "Signal on request object created from request object, with signal on second request": {
    "status": "PASS"
  },
  "Signal on request object created from request object, with signal on second request overriding another": {
    "status": "PASS"
  },
  "Signal retained after unrelated properties are overridden by fetch": {
    "status": "PASS"
  },
  "Signal removed by setting to null": {
    "status": "PASS"
  },
  "Already aborted signal rejects immediately": {
    "status": "PASS"
  },
  "Request is still 'used' if signal is aborted before fetching": {
    "status": "FAIL"
  },
  "response.arrayBuffer() rejects if already aborted": {
    "status": "PASS"
  },
  "response.blob() rejects if already aborted": {
    "status": "PASS"
  },
  "response.bytes() rejects if already aborted": {
    "status": "FAIL"
  },
  "response.formData() rejects if already aborted": {
    "status": "PASS"
  },
  "response.json() rejects if already aborted": {
    "status": "PASS"
  },
  "response.text() rejects if already aborted": {
    "status": "PASS"
  },
  "Call text() twice on aborted response": {
    "status": "PASS"
  },
  "Already aborted signal does not make request": {
    "status": "PASS"
  },
  "Already aborted signal can be used for many fetches": {
    "status": "PASS"
  },
  "Signal can be used to abort other fetches, even if another fetch succeeded before aborting": {
    "status": "PASS"
  },
  "Underlying connection is closed when aborting after receiving response": {
    "status": "FAIL"
  },
  "Underlying connection is closed when aborting after receiving response - no-cors": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.arrayBuffer()": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.blob()": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.bytes()": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.formData()": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.json()": {
    "status": "FAIL"
  },
  "Fetch aborted & connection closed when aborted after calling response.text()": {
    "status": "FAIL"
  },
  "Stream errors once aborted. Underlying connection closed.": {
    "status": "FAIL"
  },
  "Stream errors once aborted, after reading. Underlying connection closed.": {
    "status": "FAIL"
  },
  "Stream will not error if body is empty. It's closed with an empty queue before it errors.": {
    "status": "FAIL"
  },
  "Readable stream synchronously cancels with AbortError if aborted before reading": {
    "status": "PASS"
  },
  "Signal state is cloned": {
    "status": "PASS"
  },
  "Clone aborts with original controller": {
    "status": "FAIL"
  }
}